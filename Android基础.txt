第一章 心得


取消标题栏，mainifest中theme设置@android：style/Theme.Light.NoTitleBar
或者在oncreate方法中，setContentView之前，写：
requestWindowFeature(Window.FEATURE_NO_TITLE)

全屏的方法：
getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)

取消全屏的方法：
final WindowManager.LayoutParams attrs = getWindow().getAttributes();
attrs.flags &= (~WindowManager.LayoutParams.FLAG_FULLSCREEN);
getWindow().setAttributes(attrs);
getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);

SystemClock.uptimeMillis()  // 从开机到现在的毫秒数
SystemClock.currentTimeMillis

editText不输入数据的默认值是“”。

随机数： (int)(Math.random()*(最大值-最小值+1) + 最小值)
Math.random()返回的是无限接近于0到无限接近于1之间的数。
(int)(Math.random() * 最大值)，返回的结果是0到最大值减一之间的整数。
如果要1到最大值的随机数，就要在加1
(int)(Math.random() * 最大值 + 1)


在Acitivity中，onTouchEvent方法，测得的XY值是从整个屏幕的左上角计算0,0点的，是手机屏幕的实际绝对值；而在控件中的onTouchEvent方法中，测得XY轴值，是从控件的左上角开始计算的，左上角是0，0，如果按着移动出去，测得的XY值就是负的了，在控件的触摸方法中，获取触摸点的屏幕绝对值的方法：event.getRawX()

list中存储对象或者list的时候，每一个都必须是重新new的，才会代表一个新的。

条件运算符：（8>5）？“5”：“8”

Thread.currentThread().getId()     获取当前线程对象，的id。

float后面可以有8位数的。

list集合用String输出，直接使用list.toString()方法就可以了，输入的格式是[121,asd]这样的
String[]数组用String输入，可以使用Arrays.toString(s)就可以了，格式和上边的一样。

如果new一个子类的对象，然后赋值成父类的类型，然后调用这个对象的，子父类共有的一个方法，子类重写父类的。那么这个父类类型的对象，最终调用的会是子类的方法。因为这个类的本质还是这个子类的构造方法构造出来的。

***************************************************
把一个list传递进一个方法中，去进行增删处理，实际操作的还是外面的这个list的。不用担心不是同一个了。

接口的写法，不在用class，而是用interface。

break跳出循环；return跳出方法体；continue跳出本次操作；

new一个接口，相当于是新建一个类，这类继承这个接口，并且要实现其方法，完善方法的流程。而且会返回生成这个类的对象。

返回的接口对象，只能操作接口方法的。不能操作主类的其他方法。
接口对象也算instanceof主类的一个对象的。也可以强制成主类对象，操作主类的方法。

对象的创建，其实new对象（构造方法），会返回生成一个这个类的对象，然后新建一个这个类的对象来接收。
所以没有new某个类的对象是个null空的。

**************************************************************************
其实char内部存储的还是数字。每个字符对应的数字。所以char还可以比较大小呢。基本的代码。0-9是48--57；A-Z是65--90；a--z是97-122.


*********************************
类如果创建了tostring方法，就是直接生成一个类里面所有的属性名字+属性值的一个方法。如果直径输入对象名的时候，就是调用了tostring方法。

******************************************8
==用于比较基本类型的内容是否一致，比较类的时候，就是比较的是两个类的内存地址是否一样。
eqauls是比较两个类逻辑上是否一致。比如一个人18岁，另一个也18岁。在类中就可以自定义比较方法。如果都是18岁就判定是一致的。
如果没有自定义比较方法，那就用Object的方法，还是比较内存地址是否一致。


i++和++i都是i=i+1的意思
i++是让用i的老值。用完之后，i再加上个1.
++i是i先加上1，用i的新值再执行语句。

****************************************************
带返回值的方法，如果里面用到了if语句，最后一个if语句一定要有else语句。
这样就算上面的各种情况都不符合，都没有执行。那么最后一定还有个else
确保程序，最后怎么都会有return值。
无论什么写法，必须保证至少会有一个return值。
return在第一次return后就不再执行后面的程序。

负数乘除：负负得正  一负得负

********************************************
如果父类有显式构造方法，而且没有无参构造方法。
那么建立父类类型的子类时候，必须要调用一个父类的构造方法。

建立子类的对象时，会自动调用父类的无参构造方法。
建立一个对象，其实是整个父类和子类的对象。可以用父类和子类里面的所有属性，可以用父类的所有方法，可以用子类的所有方法，子类的方法有，重写的，新增的

*******************************************************
父类继承的接口方法，子类会同样继承的
所有的基本类型都是承接Object类的。Object继承的有很多接口的

初始化子类的时候，会自动初始化父类的构造方法。

*******************************************************
如果两个int类型的数加减乘除运算，得到的数还是int类型的，比如两个很大的数相乘，也不会自动转成long类型的。
如果一个int类型，加减乘除一个有小数的数不指定类型，比如3.2，得到的会是一个double类型的。
如果一个int类型，加减乘除一个各种指定类型的数，比如3.2f，3.2d，3l，那么运算后得到的就是指定类型的数。
float  +-*/  double   =   double
float  +-*/  long     =   flaot
double +-*/  long     =   double
得到类型后，如果赋值给别的类型后，就相当于把目标类型转换成赋值的类型，比如 10 / 3是等于3的，赋值给float或者double，不过是3.0而已，不会是3.3333的



**********************************************************************

一个类中的方法，都可以互相使用的。

如果是普通方法，是可以任意调用同类的所有静态、非静态的，属性和方法

如果是静态方法，只能随意调用本类的所有静态属性和方法
                非静态的属性和方法就要用对象名调用。

************************************************************
一个类有两个类型的元素，一个是属性，一个是方法
添加数据之类的只能写在方法里面。
外面只能定义属性呢   不能操作属性  要操作属性就要写个方法去操作

***********************************************
程序中，结果不对还要重新运行上段程序，的编写思路：
用个while（true）语句，如果结果是有能正确使用的就break；不正确的就来个提示语继续循环。一直到正确break那。

*******************************

其实设置监听器，就是set设置的时候，传进去一个接口的类的对象。
这个接口的类里面有各种抽象的方法，创建的时候就要补全这个类的方法流程了，就是做出怎么处理。

控件类的内部应该是，做出某种改变的时候，就调用接口的类对象的方法来处理。会把改变的东西，传送到接口的类的方法中来处理。


finish（）销毁页面，关闭页面

直接getTitle（）；是获取当前标题栏的内容

文本类控件，默认内容是“”空字符串，不是null；如果setText为null，不会报错的，会设置为“”的

eclipse点击变量，同一变量高亮的方法：
"Window"-"preferences"-"Java"-"Editor"-"Mark Occurrences"。



setKeepScreenOn（true）		设置屏幕长亮
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 

自定义控件的时候，构造参数的attrs是包含了这个控件的所有属性的，包括xml和自己定义的。

********************************************

在程序中设置颜色的时候，就不能直接使用#颜色代码了。
这时候有三种选择，
1.Color.BLUE  RED..    等等,这是系统定义好的颜色代码  *实际是返回一个int型
2.Color.argb(255,83,83,83)   自定义颜色代码
   **第一个参数是透明度0-255,0是完全透明，255是完全不透明 后面三个是RGB值
3.使用XML自定义，在value文件夹下，新建一个color.xml文件
   **<resources> <color name="自己定义的名称">#838383</color> </resources>
     使用的时候，在xml中，@color/名称
     在程序中，getResources().getColor(R.color.名称)
        **在程序中，调用资源文件都需要用这种方法
4.0xff535353    直接设置这个，0x代表十六位，ff代表透明值，后面是颜色代码
5.Color.parseColor("颜色代码")








**************************

ctrl + T 		快速查找方法
ctrl + shift + T 	快速查找类
ctrl + shift + R 	快速查找类和xml
F2			改变类名
alt + shift + R		快速改变对象名称
ctrl + shift + G 	查看方法变量被调用的地方
ctrl + L 		快速定位行号


XML
注释：CTRL + SHIFT + /

撤销注释：CTRL + SHIFT + \


svn提交方法：
先update一次，然后在commit提交
update的时候，可能会有冲突，如果冲突了，先把生成的.mine的三个文件给删掉，然后再删掉类中生成的.mine代码。
然后再update，再commit






***************************
获取当前屏幕的宽度和高度
DisplayMetrics  outMetrics = new DisplayMetrics();  

getWindow().getWindowManager().getDefaultDisplay().getMetrics(outMetrics)

outMetrics.winthPixels      返回当前屏幕的横向像素数
outMetrics.heighPixels      返回当前屏幕的纵向像素数


另一种方法：
DisplayMetrics  outMetrics = new DisplayMetrics();  
WindowManager wm = context.getSystemService(Context.WINDOW_SERVICE)

wm.getDafaultDisplay().getMetrics(outMetrics)

outMetrics.winthPixels      返回当前屏幕的横向像素数
outMetrics.heighPixels      返回当前屏幕的纵向像素数


****基本都是一样，先得到一个windoswManager窗口管理员服务对象。
然后.getDafaultDisplay().getMetrics(outMetrics)
最后outMetrics就有width和heigh值了


Point point = new Point()
getWindowManager().getDefaultDisplay().getSize(point)
然后point就包含屏幕宽高的信息了，使用的时候：
point.widht
point.height


最简单的一种：
screenWidth = getResources().getDisplayMetrics().widthPixels; 




*********************************
像素的转换：
这个是只能把各种单位转成px值的方法。
flota a = TypeValue.applyDimension(TypedValue.XXXX(想要的格式)，10(想要的格式数值)，getResources().getDisplayMetrics())
传入各种单位，会返回各种单位对应的px值。
比如传入50dp，就会返回50dp对应的px值。



*********************************



使用资源的方式：
在xml中使用，都是@drawable/XXX

在代码中
一种setBackgroundResource（R.drawable.XX）
  **可以直接使用int型资源文件

一种setBackground(getResources().getString(R.string.XXX))
  **需要使用一个资源类型的对应类型的对象。

getResource()		获取资源对象
getResource().getString或者getDrawable等等。。获取各个文件夹中的对象
获取到对象后，就可以用R.drawable.XXX使用了。

使用assets文件中的文件：
InputStream in = getResources().getAssets().open(“文件名”)  
  **getAssets()后，就可以文件夹的资源了。这个文件夹的使用方法，就不是R.XX.XX    了。是用open方法使用的。
    最后返回的是一个InputStream输入流
文件夹内存放的文件名，还是不能使用中文名。


使用raw文件夹中的文件：
InputStream in = getResource().openRawResource(R.raw.XX)
  **得到Raw文件夹的对象，是用openRawResourcr()方法，然后用R.raw.XX就可以了
    一样返回的是一个输入流
    这里使用R.drawable.XX也是可以的。


字符串的国际化：
右击values文件夹，选择创建xml，输入名称，strings，然后点击下一步，
选择Language语言，需要zh中国，然后再选择Region地区，输入大小CN就是简体中文。
最后点击完成，就会重新创建一个values文件夹，而且里面有个strings文件。
在里面输入，和strings文件夹里面同名的字符串，内容写成中文的。
以后再调用这个名称的字符串的时候，会根据系统的语言，自动选择调用哪一个资源。


颜色，在XML中使用系统预设的颜色：
“@android：color/XXX”
自己定义颜色：
在values文件夹中，新建个color文件，内部选择color标签，name和值
用的时候，“@color/”


用XML定义数组
在values文件夹中，新建一个arrays文件。
选择IntegerArrays或者stringsArrays，设置name
内容，选择item，直接输入内容。每一个item，就是一项
String[]str = getResource().getStringArray(R.arrays.XX)
这样就会获得到这个数组了
还可以，在XML中，ListView控件，设置属性android：entries=“@array/XX”
这样，listView就直接设置了数据源了，
可以适用于简单字符串数组，作为数据源的控件。



style样式：
多个控件，多个配置属性都一样的话，可以使用style来设置。
在values文件夹中的styles文件中，新建一个style标签，定义名字。
然后新建一个item标签，选择name，也就是要配置的属性名。然后定义数值。
最后在XML中，使用的时候“@style/XX”就一下使用好几个属性了



字体颜色使用selector效果，在res文件夹下，新建一个color文件夹，然后再创建一个selector效果，就可以选择各种状态下，设置color属性了。



控件对象.setAlpha()      设置透明度 范围是0-1,0是完全透明，1是不透明

文本控件.append(字符内容)   可以在当前的内容上追加内容



系统剪贴板
ClipboardManager clipboard = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
clipboard.setText(text);             复制内容到剪贴板

clipboard.getText().toString();      获取剪贴板的内容




***************************************************************
第三章 内部类
普通成员类

内部类可以直接使用外部类的变量
如果变量同名的话，调用时写  外部类名字.this.变量名

如果外部类要用内部类的东西（变量和方法）
要先创建外部类的对象
然后再创建内部类的对象
内部类的对象创建方法：要加上外部类对象名字.new 内部类名字

********************************************

静态内部类

如果内部类是静态static的
这时候内部类能直接外部类的只能是静态static的东西。
如果同名的话，这时候只需要加外部类名字.变量名就行了

如果要使用外部类非静态的东西
就要写new 外部类（）.名字

在外部类中使用内部类的东西。静态内部类
这时候就不需要创建外部类的对象了
直接用正常流程创建内部类的对象，就可以了使用了

********************************************

方法内部类

直接放内部类写在内部类的一个方法中
因为在内部类的方法中，别人就算调用也是调用的外部方法，不存在调用方法内的东西的。所以方法内部类不用加什么访问权限符号了。


*************************************************

类里面的方法体，可以使用类里面的属性（也就是变量）。
而且也可以用类里面的别的方法体哦。

this是代表当前调用时候的对象。




****************************************************


第四章 字符串

*********************
字符串的一些常用方法：
a.length()                          返回字符串的长度；
a.indexOf(字符串，数字)             返回字符串第一次出现的位置
a.lastIndexOf(字符串，数字)         返回字符串最后一次出现的位置
   *也可以查找定义的char型和字符串型变量的位置
   *后面可以加数字，直接从数字这个位置开始查找，查找不到返回的是-1
a.substring(数字)                   从数字这个位置截取字符串
a.substring(数字1，数字1)           截取从数字1到数字2之间的字符串
   *使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符
a.trim()                            去除字符串前后的空格
a.toLowerCase()                     转换成小写
a.toUpperCase()                     转换成大写的
a.split(字符)                       按照指定字符分割成数组
  **分割规则，第一个应该是，从开头到指定字符算一个，如果开头就是指定字符，那么截取的第一个应该是个空字符“”；中间的就是两个指定字符之间的；最后一个是，从最后一个指定字符后到结尾那。
    如果是“”，就是直接分割成每一个字符为一个单位。
    还可以使用多个字符来分割，多个字符用|分开，比如这样：（a|c）
    使用+-的时候，需要注意加双反斜杠(\\+ |\\-)
a.getByte()                         把字符串转换成字节数组
a.replace(char，char)
*或者CharSequence,CharSequence      用第二个字符替换所有的第一个字符
a.replaceAll(String,String)         用第二个字符串替换所有的第二个字符串
a.replaceFirst(String,String)       用第二字符串替换第一次出现的第一个字符串
   **这个替换操作的不是本字符串，会返回一个替换后的字符串。本字符串是不变的。
a.charAt()                          截取指定位置的单个字符。
a.startSwitch(字符串)               查看字符串是否以这个字符串开头的
a.startSwitch(字符串，位置)         查看字符串的指定位置，是否这个字符串开头
a.toCharArray()                     分割成字符数组
a.endWith(字符串)		    返回是否以指定字符串结尾的


其他类型转换成字符串，可以直接+“”或者String.valueOf(类型)
字符串转换成其他类型，用，各个包装类.valueOf(字符串)
或者各个包装类.parseInt(字符串)

字符串的创建：
可以先声明   String s=new String();再赋值
也可以直接   String s="   "

字节数组转换成字符串，写法：String s=new String(数组，可选编码)；括号还可以选择编码，如果当然是用别的编码转出来的，再转成字符串，也一样要用同样的编码

如果定义一个String类型的成员变量，不赋值的情况下，比如String s;那么默认值是null空。
如果是这样定义的，String s = new String();那么默认值是“”空字符。


新建一个StringBuffer的对象，直接equals（""）是false的。如果.toString().equals("")也就是true了。


***********************
android:id       名字
android:text     显示的内容
android:layout_width     宽度
android:layout_height    高度
android:layout_textSize    显示内容的字号
android:layout_textColor    显示内容的字号




TextView设置行间距：
android:lineSpacingExtra=“3dp”
或android:lineSpacingMultiplier=“1.2” 1.2倍


android:lines="2"
设置TextView的固定行数和高度，设置几行后，无论文字有多少行，TextView就是保持设置的行数和高度。

android：ellipsize=“end”
设置文字过长时，显示的方式：
end:显示省略号，在文字的末尾，

android:singleLine="true"
设置单行


android：ems =“9”
android：minEms  和  android：maxEms
这三个都是在wrap_content的情况下才有用的。用处是用来，限制TextView的宽的。
这样设置后，TextView的宽就变成，最小宽度是几个字符的，最大宽度是几个字符的。
如果TextView现在是充满父布局，那就没有用处了。

minHeight	minWidth	maxHeight	maxWidth
设置最小最大的宽高值。限制宽高最小最大的时候为多少

maxLines	minLines
设置最小最大行数
变相设置TextView的高度，无论内容有多少行，TextView的高度就是设置行数的高度。


maxLength 
设置能显示的最大的字数。多余的就不显示了、



android：scrollbars    设置文字过多，是否显示滚动条及样式。



第五章 基本控件

****************************************
bt2.setVisibility(View.VISIBLE);
visible就是正常可见状态，invisible是不可见状态，但其实还在占用排列空间，而gone则为隐藏状态，控件不再占用空间

获取光标位置：
int position = et.getSelectionStart();


设置EditText的光标显示在文本的最后的方法：
et.setSelection（et.getText().toString().length）
参数就是设置让光标显示在字符的第几位那里


在EditText内容中插入字符：
Editable editable = et.geText();
editable.insert(index, "aaaa");
index是要插入的位置，可以配合光标位置使用
  

设置EditEext的提示文本颜色，textColorHint


设置光标的宽度和颜色，使用textCursorDrawable属性：
需要一个drawable的xml文件
<shape >
   <size android:width="10dp" /> 
   <solid android:color="#ffffff00"/>
</shape>
size只能设置宽度的，高度用的是文字大小的实际高度。设置的话，也是无效的。
solid设置颜色。











Button   ImageButton   的点击监听事件为：
.setOnClickListener(OnClickListener接口)
     


******************************************
AutoCompleteTextView    动态匹配文本输入框
MutilAutoCompleteTextView     多输入 动态匹配文本输入框

特有属性：
android:completionThreshold    设置输入多少字符开始匹配

实现的时候需要创建一个适配器
ArrayAdapter<类型String> 名字=new ArrayAdapter<泛型指定类型>（this，选择一个系统的样式布局，选择一个要匹配的文本源《创建一个数组》）

用.setAdapter(选择适配器)  来实现功能


MutilAutoCompleteTextView 需要设置一个分隔符
.setTokenizer(new MutilAutoCompleteTextView.CommaTokeizer())




***************************
OnCheckedChangeListener接口有两个
一个是androdi.widget.CompoundButton
一个是android.widget.RadioGroup

**CompoundButton的是适用于单独一个控件的
比如复选框CheckBox、单选框RadioButton、开关按钮ToggleButton
方法的接受值是，
一个是按钮名字(就是一开始给每个按钮定义的那个)CompoundButton，
一个是点击状态isChecked


RadioGroup是适用于一个集合的
方法接受值是，一个集合名称(定义的名称)。一个是集合里面的控件id(R.id)[用于判断哪个被点击]





ToggleButton   类似开关按钮
可设置点击状态和未点击状态  显示不同文本

android:checked    点击状态   默认为false
android:textoff    off状态未点击状态   显示的文本
android:texton     点击状态    显示的文本


监听器为：
.setOnCheckedChangeListener(new OnCheckedChangeListener())*CompoundButton类型
[接口方法有两个接收值，一个是button值，一个是isChecked当前点击的状态]



**************************************

CheckBox   复选框

checked    可预先设置选中状态    


监听器为：
setOnCheckedChangeListener(OnCheckedChangeListener接口)*CompoundButton类型
[接口方法有两个接收值，一个是button值，一个是isChecked当前点击的状态]


***************************************
RadioGroup    单选框集合

android:orientation   排列方式  vertical  垂直 ； horizontal  水平

监听器为：
.setOnCheckedChangeListener(new OnCheckedChangeListener())*RadioGroup类型
[要选择接口方法为RadioGroup的选项]
[接口方法有两个接收值，一个是RadioGroup值,一个是checkedId，是指当前集合里的RadioButton的id]

单独RadioButton也可以设置监听器：
*CompoundButton类型的 OnCheckedChangeListener()就可以了

定义RadioButton的样式：
android：button=“@null”		
这个属性就是定义RadioButton前面那个Button样式的。如果设置成null，那就是不显示前面那个button了。
android：background=“”
这个是还是一样，设置整个控件的背景的。




第六章 五大布局

VierGroup的一些方法：
int count = layout.getChildCount();	获取子控件的数量；
layout.getChildAt(0)			获取指定位置上的子控件
layout.removeViewAt(0)			删除指定位置上的子控件
layout.addView(view,0)			在指定位置上插入控件。

*************************************************************************
Linearlayout   线性布局
让内部控件  垂直或者水平 方向排列

android：orientation   选择排列顺序
内部控件多于1个的时候，就必须写orientation了
android: gravity       设置整个布局的位置[靠左还是靠下...]
                       属性可以多选择的，
子控件属性
android：layout_gravity  设置子控件的位置
android: layout_weight   设置子控件的所占比例
weight：如果子控件高度设置成充满父类，那么这个比例就是反比；
具体所占比例，就是所有同级子控件设置的数值之和，再除以自身的数值。
比如三个控件，设置的为：3,6,2
那么第一个所占的比例就是 3 / 11(3+6+2);





**************************************************************************
RelativeLayout     相对布局
可以让控件相对控件或者相对父类  有个距离

子控件属性
android: layout_alignParent[Left]=true   与父布局的指定边框对齐....
                          :这里可以添加四个方向

android: layout_margin[top]=“40dp”     
对于当前相对的控件指定方向的40个dp，可以写四个方向
也可以不写方向：
  如果没有别的控件相对于自身，那就是相对父布局的上边和左边的距离值
  如果有别的控件相对于自身的某个方向，那么别的控件和自身的那个方向，默认就有40dp的距离了。
  同理，如果自身已经指定与父布局的指定方向，有多少dp了。如果再有别的控件，相当于自身的那个方向，那么别的控件就在屏幕外了。

android: layout_centerInparent       水平居中且垂直居中

android: layout_centerHorizontal     水平居中

android: layout_centerVertical       垂直居中

{相对父布局的位置，要写明alignparent相对父类的两个方向，再写margin方向的距离。}


**************


多个控件时，一个控件相对另一个控件的位置  属性有：
android:layout_below  =“另一个控件id” 指当前控件相对另一个控件的位置
               above        上边
               toLeftof     左边
               toRightof    右边
  **如果另一个控件的指定方向，已经相对父布局了，那就不能再相对另一个控件的那个方向了。

【如果RelativeLayout高度是自适应包括内容的，那么below什么的就失效了】



android:layout_alignLeft = “另一个控件id”     
与指定控件的指定边缘对齐

这时候再写margin方向多少距离，这个方向必须相对过某个物体，否则设置失效。
比如android:layout_alignLeft = 40dp
那么必须相当过父布局的左边，或者相当过某个控件的右边。必须有个参照物


对于below和alignTop的区别是：
再写margin那个方向的距离，数值below系列是从控件的自身体积外方向开始计算，align系列是从控件内部的方向边框开始计算的


android：layout_alignBaseline      控件内容 与指定控件内容位于一条线上

{总结来说，相对别的控件的位置写法。就是先要确定两个相对方向，是相当于父布局alignParent系列，还是相当于别的控件体积外above系列，还是相当于别的控件内部的方向align系列，每个方向都可以任意选其中一种。
然后再加两个margin方向的距离。 }




***************************************************************
TableLayout 表格布局

内部使用TableRow标签，一个TableRow标签代表一行，TableRow内部可以再放子控件。不写TableRow也可以，可以直接放一个子控件。
TbaleLayout的列数，由行里面控件最多的来指定。

TableLayout属性，也算列属性：
android:collapseColumns="2"              隐藏指定的列
android:shrinkColumns="2"                
  收缩指定的列，如果内容多了，自动换行显示。
android:stretchColumns="3"               拉伸指定的列 用于填充剩余空间

单元格属性：
android：layout_column="1"		指定显示在第几列
android：layout_span="2"		指定单元格占据几列





******************************
Activity的启动模式

当一个APP启动的时候，就会为这个APP创建一个任务栈Task，这个APP所启动的Activity的都会被放在这个任务栈中管理。
一个任务栈Task中的Activity，可以来自不同的APP。一个APP的Activity也可能不在同一个任务栈中。

设置方法：可以通过mainfest文件，设置activity标签的属性
launchMode
还可以通过startIntent（）的时候，设置一个flag。

如果一个activity在mainfest中已经定义了启动模式，而跳转的时候，intent中也设置了启动模式flag，那么就以intent中的模式为准。




一共有四种:standard    singleTop

默认情况下，是standard模式
这种模式，启动一个指定活动的时候，直接会创建一个新的活动Activity。

singleTop模式，启动一个活动，会检查栈顶的活动是不是现在要启动的活动。如果是，就不会再重新创建了。如果不是，还是一样重新创建一个新的活动

singleTask模式，启动一个活动，会先检查这个活动在栈中存在不存在，如果存在，就会把这个活动上面的所有活动都销毁出栈，然后就这个活动就会在栈顶显示出来了。
（如果是一个程序，来启动另一个程序的acitity，那么就会为这个activity创建一个新的任务栈。如果另一个activity已经存在后台任务了。则会把activity所在的后台任务栈，一起加入到当前的任务栈中，如果按back键回退，退到的页面也是另一个程序的）

singleInstance模式，启动一个活动，会给这个活动创建一个新的栈，而且这个栈只能有这一个acitivty。

  **如果入口和最后显示的活动页面，不在同一个栈中。那么从最后的页面中，回到桌面后，在进入，会重新从入口的栈中进入。






*********************************************
Activity 生命周期
onCreate()     		创建
onStart()       	运行
onResume()      	获取焦点
onPause()       	失去焦点
onSavaInstanceState()	保存页面状态
onStop()        	停止
onDestroy（）   	销毁
onRestart（）   	重启

onRestoreInstanceState（）	恢复页面状态
onConfigurationChanged（）	横竖屏切换时


启动一个程序的时候，先运行的是
onCreate(),onStart(),onResume()
创建，开始，获取焦点


回到手机主页：
onPause（）,onSavaInstanceState（），onStop()
先失去焦点，然后保存状态，再停止


停止状态后，重新回来：
onRestart(),onStart(),onResume()
重启，运行，获取焦点


直接退出：
onPause(),onStop(),onDestroy()
失去焦点，停止，销毁页面


切换屏幕方向的生命周期：
onPause()--onSavaInstanceState()--onStop()--onDestrou()
onCreate()--onStart()--onRestoreInstanceState()--onResume()
显示从失去焦点，销毁页面
然后重新创建页面，但是【在onStart方法后，会执行一个onRestoreInstanceState方法，恢复状态】，然后在重获焦点。
onRestoreInstanceState方法，只有在屏幕方向切换的重建页面那，才会执行。
平时的新建页面onCreate系列和onRestart系列都不会执行的。

在manifest文件中，在Activity标签中，设置：
android：configChanges = “orientation|keyboardHidden”			4.0版本以前
android：configChanges = “orientation|keybordHidden|screenSize”	4.0版本以后
这样设置后，再横屏后，Activity就不会再销毁重建了。只会执行onConfigurationChanged方法

在代码中设置横屏的方法：
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);




如果跳转到别的Activity页面时候，自己的页面会先失去焦点onPause（）后，就开始去创建别的页面了。别的页面显示后，自己的页面也会接着做后面的生命周期，比如停止或者销毁


onSavaInstanceState(outSate)方法，用于在失去焦点的时候存储一些简单信息。
把数据存储在送入的outState的Bundle中。
然后在onCreate()方法中，从bundle中提取出来。


设置Activity的方向，在manifest文件activity标签中的设置方法：
android:screenOrientation="landscape"		限制此页面横屏显示
"landscape"
- 横向

"portrait"
- 纵向

"user"
- 用户当前的首选方向

"behind"
- 与活动栈中的方向相同

"sensor"
- 方向传感器的方向






********************

启动一个Activity时候，Fragment的生命周期：
启动时候：  Activity的对应Fragment的：
onAttach(),onCreate(),onCreateView(),onActivityCreated(),onStart()onResume()


页面跳出不显示的时候：与Activity一样
onPause(),onStop()


重新回来：
少了一个onRestart（）
只有onStart（），onResume（）


销毁的时候：
onDestroyView（），onDestroy（），onDetach()




*****************************************************************
Intent的使用：
Intent是一个跳转器。
一种用法：可以先定义一个跳转器，包含起始页和跳转页面
写法：Intent a=new Intent(起始页，跳转页面)
      startActivity(跳转器a)

跳转器还可以用于返回数据的用法
第一个页面，先发出一个标识，第二个页面发回数据和一个标识。
写法：Intent a=new Intent(起始页，跳转页面)
      StartActivityForResult(跳转器a，请求码1)   请求码一会用于确定自身的标识
                                      *requestcode
      第二个页面
      先生成一个空的跳转器Intent a=new Intent
      跳转器其实也是一个map集合，是可以存储东西的
      a.putExtra(key,value)
      再写一个setResult(结果码2，跳转器)
                        *resultcod
      resultcod一般使用RESULT_OK或者RESULT_CANCELED这两个静态值

      然后在第一个页面重写onActivityResult方法(请求码，结果码，存了数据的Intent)
      然后可以根据请求码和结果码，来确定都是哪个发出的东西，来提取数据
      结果码和数据跳转器是一对的。

Intent跳转系统页面：
Intent intent =  new Intent（Intent.ACTION_VIEW,Uri）
  **uri是网址,就跳转到系统浏览器，打开
    Uri.parse("tel:12345"),就是跳转到拨号界面

Intent intent = new Intent（Intent.ACTION_GET_CONTENT）
intent.setType("image/*")
  **跳转到目录，设置类型，关于image类的所有，也就是相册

Intent intent = new Intent（Intent.ACTION_SEND）
intent.setType("text/plain")
intent.putExtra(Intent.EXTRA_TEXT,"短信字符")
  **跳转到写短信页面，并且传递数据过去




Intent存数据：
intent.putExtra(String键，各种类型value) 
  intent.putExtras(Bundle对象)

Intent取数据：
intent.getXxxExtra("key键")   get各种类型Extra
  intent.getData();	取出一个Uri对象。
  intent.getExtras(); 	取出一个bundle出来
    **bundle,也可以用常规的putExtra（key，bundle对象），getBunldeExtra（key）	


Bundle存数据.putXxx(String键，各种类型Value)
Bundle取数据.getXxx(String键)
   **Bundle存取都是要写明put、get各种类型的。
     Intent存直接putExtra就可以。取也是要写明各种类型

如果需要存储一个类对象，这个类需要继承Serializable序列号接口。
然后存储的时候，使用存储类型Serializable就可以了
getSerializableExtra（key）   接收强制转换成类名的类型就可以了


如果需要存储bitmap的话，使用Parcelable
putParcelable（key，bitmap）

如果存储的数据，体积过大的话，会报错传递不过去的，大概是250KB左右




第八章 计算器
************************************************************************



double型数字进行运算的时候，会出现不准确的现象
要使用BigDecimal  进行运算
构造方法：
BigDecimal bd=new BigDecimal(字符串、int、double、float、long)
可以传入各种类型的数据，然后转换成BigDecimal类型
最好是传入字符串，这样会更精准的


转换成各种类型的方法：
bd.doubleValue()
bd.intValue()
bd.toString()
......



运算方式
加法：   bd.add(bd)
减法：   bd.subtract（bd）
乘法：   bd.multipy（bd）
除法：
bd.divide(bd，newMathContext(数字))
   使用一个MathContext对象，当做舍入模式。MathContext的构造方法之一：
   newMathContext（5）  这样就是保留5个小数点的精度和HALF_UP的舍入模式

bd.divide(bd，舍入模式BigDecimal.ROUND_HALF_UP)
   加入四舍五入的模式，但是没有指定精度，默认是没有小数点的。

bd.divide(bd，4，BigDecimal.ROUND_HALF_UP)
   第二个参数是指定保留几位小数点，第三个是舍入精度


  *BIG运算除法，还有个bd.divide(bd)的方法，但是这样除不尽的时候，就会出错了，所以一般要使用后面指定一个舍入模式的方法。



一定要注意！！！！！！String字符串 数组 集合 都是从0开始计数的。
String的sub截取功能，指定前后位置，含前不含后。
多重if可要算好，到底是怎么执行。要算一次是的，然后怎么执行，还有不是的，怎么执行、

―――――――――――――――――――――――――――――――――――
计算器功能：
1，先保证每个数字按下后，会显示到文本框，
2，途中，点击DEL的时候，就删掉最后一位。
3. 按C的时候，就把文本框的内容都删掉
4. 按=的时候，就算结果，并且把公式显示在上面文本框，结果显示在下面文本框

5. 运算一次后，再次按键，要把两个文本框内容都清空。
   (想法是：运算一次，记录一下状态，然后看到运算状态，就清空内容，重新点一个      按键后，就把运算状态给去掉)
6. 在运算后，手贱点DEL，也不能出错。
   (想法是：如果是运算状态，我就不执行任何操作，只有不是运算状态，我才工作)
7. 手贱只点击运算符，再点击=也不能出错。
8. 输入数字加上运算符，点击=也不能出错。
―――――――――――――――――――――――――――――――――――

最终功能：
1.按下数字键，假如sum是运算状态，就清空两个文本框的内容，然后，运算状态清零
最后可以把内容输入到文本框。（一会每点一次，str就记录一次）

2.按下点键，假如sum是运算状态，就清空两个文本框的内容。然后，运算状态清零
然后判断，str内容是不是空的。
如果是空的，就正常运行，记录按键内容
如果不是空的，而且如果最后一位不是点，才继续运行记录内容。当然是点就不记了
如果一个数字已经有一个点了，再点小数点键，就不显示了
每次输出记录一个点，就计数一次。输入运算符或者等号的时候，清除。
最后，每次点一次点，就判断是否已经输入点了。

3.按下运算符，假如最后一位是个空格。就判定最后输入的是个运算符
那么就截取第一个到最后运算符中间的内容，再加上现在按的运算符
如果不是空格，那么才正常记录按键内容
而且，假如是刚运算状态，不清空内容，并且把运算状态清零

4.按下C键，就直接把两个文本框内容给清空了

5.按下DEL键，假如是刚运算状态，就把两个文本框都清空了
不是刚运算状态，并且内容不为空，才运行删除最好一位内容

6.终极问题
按下等号键，必须要有运算符；必须运算符不是在第一位；必须不能在最后一位；必须点不能是最后一位。
满足以上条件才能开始运行下面的内容
就算没运行，也要计算一个运行状态。一会好让别的按键清空这些。
除数运算的时候，第二个数字不能为零，如果是零，就提示错误。








第九章 集合

*********************************************************************
权限
系统权限写法：<uses-premission>
自定义权限写法：<premission>
自定义权限name名字 只是要有一个点。建议还是规范写三段两个点吧。
Intent.classname()可以访问别的包里面的类文件。



<!-- 禁止状态栏下拉 -->
<uses-permission android:name="android.permission.EXPAND_STATUS_BAR"/>



{我理解的map集合，一般用于单个事物的详单，比如学生信息，学号、姓名、身高、、、这些都是key键值，然后具体的东西是value值。一个map就是一个学生的信息。
然后可以用集合把map都存进去。}
就像List存对象一样。一个对象包含一个学生的具体信息。
一个map就相当于一个对象。


***********************************************************************


List集合的一个实现类：ArrayList
创建一个List集合的写法：
List a= new ArrayList()

 

List的添加方法：    a.add(对象)
也可指定位置去添加  a.add(0,对象)  
  **假如现在有4个数据。
    如果指定在0、1、2、3任意一个数，那么指定位置的数就会向后移动。
    另外也可以指定在4这个位置，输入4，那么添加的数据，就在所有数据的后面了，    也就是最后一位。如果是输入5，就会报越界错误了。

也可以添加数组进去  a.addAll(Arrays.aslist(数组名))   *这里也可指定位置



List的提取方法：    a.get(位置)   *位置是从0开始都对
注意：**如果创建的时候，没有指定泛型的，存进去的东西都会变成object类型的
取出来用的的时候，需要强转成指定类型的



List的遍历提取所有数据的方法：有三种，get方法，foerach方法，Iterator方法

普通for循环
获取List的长度：     a.size()
for(int i=0;i<a.size();i++)

也可以用foreach方法
for（类型 名字：要遍历的List名）  *一会这名字就可以代表第一个数据，第二个数据

还可以用迭代器Iterator
先新建一个迭代器， Interator i=a.iterator();
然用while循环： while（i.hasNext()）   *.hasNext如果还有数据就会返回真值



List的修改方法：      a.set(位置，对象)    



List的删除方法：      a.remove(位置)  *删除指定位置的数据
            也可      a.remove(对象内容)
还可以直接删除数组    a.removeALL(asList(数组))   


List的查找方法：      a.contains(要查的内容)
判定List中是否有这个内容、
如果存储内容是对象的话，只知道对象的属性值，想要来判定是否有这个。
可以重写equlals方法，让它对比，只要内容一样，就返回真
equals方法会传入一个Object对象，一般先比较object对象是否等于this本身，相当就return true
然后再判断是否instancesof 本类，是的话强转成类对象，然后对比两个对象的某个字段值是否一致，具体就自己写判断了。


查找并返回位置的方法：和String的indexOf差不多
a.indexOf(内容)
a.lastIndexOf(内容)   最后一次出现的位置


List的排序：
可以用Collections.sort(List集合名)
如果是数值型集合，就是按照从小到大的顺序排列
如果是字符串型集合。就是从首字母一个一个比较下去的
内容则是按照0-9，A-Z,a-z排序的

如果是对象型数据的话，就要另说了

{关于普通排序，我理解的是，其实排序的时候，这两个数据必须是承接Comparable接口的，然后用的Comparable接口的compareTO（）方法来比较的。返回正数表示大，返回负数表示小，返回0表示相等。Comparable算是系统默认的比较方法}
{其实还有一种临时自定义的比较方法，Comparator接口里面的comparae（）方法}

假如要用系统默认的Comparble比较的话。那么就在类文件那继承Comparable接口，然后重写compareTo（）方法，让他们比较。


转换成数组：
list.toArray(数组名)
需要新建一个指定长度(和List一样的长度)、和指定类型(和list一样的类型)的数组。


***********************************************************************


set集合的重要实现类HashSet
set<> a=new HashSet<>()

set是无序且不可重复的，其他基本和List差不多
添加的时候就不能add指定位置的添加了，因为没有顺序排列
也没有set修改指定位置的方法了，也因为没有顺序排列

a.add(对象)、a.addAll(Arrays.aslist(数组名))  a.remove(对象)
a.removeAll(Arrays.asList(数组名))    a.size()

set有a.add(对象)、a.addAll(Arrays.aslist(数组名))。没有指定位置的添加了

也没有get方法

遍历方法也就少了get方法，只有foerach和Iterator

修改set方法也没有

remove也是少了指定位置的删除


set的查找方法：
a.contains(内容)
判定List中是否有这个内容、
如果存储内容是对象的话，只知道对象的属性值，想要来判定是否有这个。
可以重写equlals和hashcode方法，让它对比，只要内容一样，就返回真





***********************************************************************


Map的重要实现类HashMap
map<String,String>a=new HashMap<String,String>()


map的添加方法：
a.put（key值，value值）

map的提取方法：
a.get(key)   
返回该Key值对应的value值
如果没有该key，就返回一个null值。此方法还可以用于判断map里面是否已经有这个key了

map的遍历输出方法：
其一：keySet方法
Set [String] str = a.keyset();
然后再用foerach方法遍历这个set，然后用a.get(数组成员) 输出value值

其二：entrySet方法
Set<Entry<String,String>> a1=a.entrySet();
先把map里面的所有键值对都存储到一个泛型为Entry的Set集合里面，Entry也要再次定义对应的泛型，一个Entry就是一条map键值信息。
然后再遍历Set，提取每一个Entry对象，然后调用entry.getKey()和getValue()，就可以得到键值信息了。



map的删除方法：
a.remove(key值)
删除指定key值的value值

map的修改方法：
a.put(key值，value值)
修改方法还是用put，输入已经存在的key，然后就修改后面的value值了。如果不存在那就算是添加了。


map中的判定是否有此内容的方法：

a.containsKey()
a.containsValue()
如果是新创建的对象，对比也要重写equlals和hashcode方法







类中的方法名可以相同，但是接收参数不相同就可以了。
调用传入参数的时候，会根据参数来自动选择的
构造方法也是按照传入参数自动选择的



封装就是把类的成员变量，给隐藏起来，然后给设置一个使用方法，也就是set、get。。可以在方法内，做出一些使用的规范，比如属性值范围什么的。
想使用成员变量的时候，就要调用这个使用方法来用了。


一个类，如果手动设置了构造方法，无论是有参数还是没参数的。那么程序就不会自动生成无参数的构造方法了。


继承的时候，创建子类对象的同时，其实父类也初始化了。
初始化的顺序：父类的成员变量值，初始化块，构造方法，子类的成员变量值，初始化，构造方法


final修饰的类，不能被继承
final修饰方法，方法就不能被重写了
final修饰属性，就必须先赋值了


equals比较的是，同一块内存地址

equals比较的时候，尽量把字符串放在前面，把接收值放在后面。万一接收值是个空的，也不会报错





*************************************
单例模式
也就是让一个类只能有一个实例化对象

方法就是先给类创建一个私有化的无参构造方法
那么外部就不能通过构造方法生成一个对象了，因为构造方法私有化了

在类中可以自己声明实例化一个自己的对象，然后把这个对象设置static静态的

饿汉式
可以再生成一个get对象静态方法，return这个对象
以后外部想要这个对象，调用这个静态方法就可以得到一个对象了。而且不论谁调用，得到的都是同一个对象了

懒汉式
先static声明一个对象，不实例化
然后设置get对象静态方法，判定如果为空，就实例化对象赋值。最后return对象。第二次就不会再实例化了，直接return了
懒汉模式多线程不安全





*******************************
策略模式：
如果多个对象，会重复使用一个功能，这时候可以把功能，都拆分成一个一个的接口。
但是实现的时候，还需要每一个对象实现一次的。

然后可以新建一个类，继承一个接口，实现其方法。每一个功能接口，都对应一个实现类。
然后新建一个类，创建几个接口的对象，和set方法。
最后新建类对象的时候，set每个接口对象的时候，传入一个接口实现类。这样就实现其功能了。
每个类对象，要使用重复对象的时候，只需要只有操作下就可以了。






****************************************************************
第一章 异常

异常的分类：
异常的总父类Throwable
有两个子类，一个是Error   物理上的异常
一个是Exception
其中又分为：
RuntimeException    运行异常  非检查异常
又分为：
NullPointerException    空指针异常
ArrayIndexOfBoundsException     数组下标越界异常
ClassCastException         类型转换异常
ArithmeticException        算术异常
IOException                IO异常
IllegaArgunmentException      *关于文件的一个异常

处理异常的方法：
try{
可能会出现异常的方法
}catch（各种类型的异常名称）{
处理方法
}finally{
处理语句}

异常名称要从小到大，最后添加一个总父类的异常来捕获其他不知名的异常

try语句的执行顺序，catch块先执行，然后执行finally块。
*就算没有异常，finally也会执行的。finally一般是做一些善后工作，比如关闭文件，释放内存什么的。一般是正常的程序执行完，最后执行的工作，可是要是程序出错了，那就执行不了这些了，现在放在finally里面就可以了

执行完finlly块，才开始执行他们其中的return块。
顺序是finally return、catch return、try return。


throw手动抛出异常，自定义的异常。
可以直接用系统类型，然后在构造方法那写提示语。
*抛出异常是告诉虚拟机有异常了，并不是输出了。
*一般为了见名就懂，手动抛出异常，就用自定义异常，到时候调用者看到异常名就知道是怎么回事了。

自定义异常的构建方法
创建一个类：xxxException extends Exception
然后写个构造方法，来接收提示语，然后再传给父类的构造方法
xxxException（String s）
super（）


throws声明这个方法块有异常出现。


要调用的时候，调用者就会看到那边有声明的异常，然后就要做出处理。先用try捕捉到，然后处理它，比如输出它的消息语。也可以直接用throws声明出来。




*********************************************************************
第二章 二进制

二进制的负数，就是反码加1

二进制和十进制转换

二进制转十进制，查1的位置，再减1。就是2的多少次方。然后加上每一个1的这结果
十进制转二进制，除2，每次余的数。最后从后到前数，就是二进制

怎么计算负数二进制
先减去第一位标识码，然后减一，再取反就是个正数了。


*******************************************************************

十进制转其他进制的方法
Integer.toBinaryString()               转换成二进制      作为字符串输出
Integer.toHexString()                  转换成十六进制  
Integer.toOtcalString()                转换成八进制
*如果要转换byte字节流程是：先把一个字节转换成4个字节32位的 int型，然后再转成各种进制的。
比如一个11110000，会先转换成一个int整型，byte是没有标志位的，但是int是有标志位的，看到第一位是1，就会变成一个前面超多1的负数了。
这时候，可以先让byte&与运算一个后八位是1的数0xff，这样形成的int整型数字，就是一个正数了。
 




其他进制转换成十进制的方法
Integer.parseInt("其他进制字符"，进制【2,8,16】)   
或者
Integer.valueOf("字符串"，进制【2,8，16】)  转换成什么类型，就用什么类型的包装类



byte       1个字节  8位的
short      2个字节  16位的
int        4个字节  32位的
long       8个字节  64位的
float      4个字节  32位的
double     8个字节  64位的
boolean    1个字节  8位的
char       2个字节  16位的




***************************************************************88

二进制的位运算
& 于运算   
两个二进制&与运算，两个二进制的每一位拿来相比，只有&&都是1，结果才能为1
特殊用法：1.如果想把一个算清零，就让它和一个全是0的二进制与运算。
          2.取一个数的指定位，就让它和一个【指定位置为1，其他都为0】的数，与运算

|或运算
两个二进制|运算，就是每一位拿来比较，只要有一个是1就，结果就是1
特殊用法：给一个数指定位置置换成1，那就让它和一个指定位置全为1，其他为0的数|运算

^异或运算
只有一个为真，结果才能位置。。。只有其中一个为1，结果才能是1
特殊用法：使一个数反转，让它与全是1的数，^异或运算，就反转了

~取反运算
就是直接取反值


<<左移运算
一个二进制数向左移动，指定位，左边多出去的舍弃，右边空出来的补0
如果舍弃出去的不是1，那每移一位就相当于乘以2一次。

>>右移运算
一个二进制数向右移动，指定位，右边多出去的舍弃，左边空出来的补【负数补1，正数补0】


左移右移运算，优先级别比逻辑运算高
******************************************************************

两位十六进制，正好是一个字节8byte。而且十六进制的每一位，正好对应一个4byte的二进制。
十进制转换成二进制，也是正好一个数字对应一个4byte的二进制

大小端存放方式：
小端就是把一个数的。高位放在高地址中，低位放在低地址中

大端就是把一个数的，高位放在低地址中，低位放在高地址中


转换成byte字节数组，就是把一个数转成二进制，然后再按照8byte一个字节，转换成一个十进制存储。



******************************************************************

把int转换成字节。
就是先取后八位，怎么取，&与运算8个1.   就取后八位了
然后右移8位，再&与运算8个1             就又取八位了  




把字节转换成int
先取数组第一个，也就是真正的后八位，&与运算8个1，就相当于去掉正负标识符了。就能得出真正后八位转换成十进制的数了

然后取数组第二位，也就是原数的第二段。先&运算8个1，然后左移8位就是他的真实位置了。是第几段就左移几段，就是真实位置
左移右移运算，优先级别比逻辑运算高   所以&与运算，加个括号。
最后把这些数相加。

*把一个字节8byte转换成十进制的时候，进行与运算，是可以去掉标识符的






******************************************************
第三章 IO

File类                  对文件的一些基本查看建立删掉
RandomAccessFile        对文件的基本读写操作
FileInputStream         输入流。    read读取数据，到流中
FileOutputStraem        输出流。    流中的数据，write写入到对象中


数组的创建方法：
int[] a={.......}    直接创建的同时，声明数据，分配空间，赋值
int[] a=new int[数字] 创建的时候，分配空间，不赋值

字符串转成字节数组
.getByte(["utf-8"])
还可以指定编码方式

gbk编码中文占用两个字节，英文占用一个字节

utf-8编码中文占用三个字节，英文占用一个字节

utf-16be编码中文占用两个字节，英文占用两个字节
java的jdk是用的utf-16be的，也就是双字节编码

java的项目可以设置编码方式，默认是gbk编码的，如果是别的编码的文件，放进来是乱码的







*****************************************************
File类的基本方法
新建对象的方法
new File（地址）  *地址可以是一个目录，也可以是个文件地址哦

.exists()              判定这个地址是否存在
.mkdir()               新建一个文件夹
.mkdirs()              新建多级文件夹 *如果多级的mkdir，则建立不了
.delete()              
*删除文件。如果删除文件夹，需要是一个空的文件夹才能删除
.isDirectory()         是否是一个目录
.isFile()              是否是一个文件
.createNewFile()       新建一个文件
.length()	       文件大小，字节单位Byte。如果文件不存在，返回0
.canRead()	       是否可读
.canWrite()	       是否可写
.isHidden()	       是否隐藏
直接syso输出  就是显示地址
.getName（）           返回file的文件夹名或者文件名
.getParent（）         返回该地址的名称以上的所有路径名称
.list()                把该地址的所有文件和目录转换成一个字符串数组
*相当于把每个文件名都转换成字符串了，然后编成一个数组。【只有名称，没有路径】
	list（FilenameFilter对象）方法内，可以加入一个名称过滤器对象，来过滤不需要的文件。newFilenameFilter（）后，会重写一个方法：
boolean accept(File arg0, String arg1) 
会送入当前的file对象，和字符串的文件名。可以根据这两项做判断，然后决定return什么。如果return true就是需要，return false就是不需要。


.listFile()            把该地址的所有文件和目录转换成一个File类数字
*相当于把每个文件名都转换成一个File类对象，然后编成一个数组

.renameTo(file对象)	把file名称换成指定file的名称

.getPath   		返回路径


静态方法
File.separator		得到一个路径分隔符





*****************************************************************
RandomAccessFile类的使用方法
.new RandomAccessFile(File对象，读取类型)   rw，r
     读取类型，r是读取，w写，d是删除，可以自由搭配，比如rw，rwd
新建后，指针point在第一位0那
.write()               只能写一个字节8byte    写了一个后，point在下一位1了
*要是传一个字节数组进去，也可以都写进去了
 也有writeInt、double、char   各种数据类型的write方法。可以写各种类型
.writeInt()            写一个int类型进去
.read()                读当前指针的一个字节
*要是传一个字节数组进去，就可以把所有内容读取到数组里面  
 也有readInt、double、char   各种数据类型的read方法。可以读各种类型    
.close（）             关闭文件
.getFilePointer()      返回当前指针的位置       
.seek（数字）          移动指针到指定位置

.setLength(length)	设置文件大小，长度


txt文件应该是只能解析字符串的。
存什么内容都可以的。但是打开的时候，它是按照字符串的解析所有字节的。

文件的一个基本读写操作流程：
先创建一个String存储一个字符串
然后String转换成一个字节数组

然后把字节数组写入到文件中

读的话，先把指针移动到0那
然后把读的东西都存到一个字节数组那。

然后在用String的创建方法给解析成字符串。就可以输出了

存int别的什么类型也是可以存进去的，就是把他们变成字节然后存进去了
读的时候也可以直接选择，readInt读一个int类型出来，然后就按照int类型给解析了

倒是要是想用String的解析方法就不对了，编码方式不一样啊
String能解析的都是按String方法编出去的。int的编码方法，String肯定就解析不出来









IO流

字节流有InputStream 、OutputStream
        输入流        输出流

其实是流的输入和输出。
输入流：先读别的东西，到自身内。
输出流：写自身的东西，到别的地方

*************************************************************

FileInputStream输入流的基本方法：
.read()    读取一个字节无符号填充到
.read(byte[]bu)   读取所有数据填充到一个数组内
.read(byte[]bu,int a ,int b)   读取数据填充到一个数组内，从数组的a位置开始放，长度是b个

int b=XXX.read(byte[]bu)      等于是把读取的字节个数返回给b
读取完毕后，返回的字节个数会是-1.
System.currentTimeMillis();     读取一个毫秒时间

byte的读写比单字节的读写，速度快了很多很多。

int count = is.available()		返回流数据的长度



*********************************************************

FileOutputStream输出流的基本方法：
.new FileOutputStream("XXX",true)
创建构造的时候，写的地址，如果是没有就创建一个，如果有了就删除再创建一个
true  如果加true就变成追加内容了，就不会删除原文件，重新创建了。就是在原文件的基础上追加新的内容。
写入的地址，就算是刚用file生成的文件夹，也会自动创建成文件的。


.write()     写一个字节到对象里
.write(byte[])      把一个数组里面的数据写到对象里
.write(byte[],a,b)   把一个数组里面的数据，从数组的a位置开始读取写入到对象，总共读取写入b个。    










**************************************************************

DataOutputStream的构造方法：
.new DataOutputStream(一个FileOutputStream)   构造方法必须是一个FileOutputStream

DataOutputStream主要是处理一些各种数据类型的数据的
比如.writeInt、double、long、Chars 、UTF
chars是utf-16be编码写的。中文两个字节，英文两个字节
utf是utg-8编码写的，中文三个字节，英文一个字节

其实FileOutputStream也可以写这些的，只不过是要分成好几次写。
这个就像是弄了好多写好的方法，提供给用户直接使用了


****************************************************************

DataIntputStream的构造方法：
.new DataIntputStream(一个FileInputStream)   构造方法必须是一个FileInputStream

DataInputStream就可以直接输出各种数据类型的数据了






*************************************************************************
BufferedInputStream 和BufferedOutputStream带缓冲区的输入流
构造方法：
.new BufferedInputStream(一个FileInputStream，大小)
.flush()    output的方法(立刻写入)

这种Buffered的output写入流，都是先把数据读到内存中的，也就是设置的那个大小内存。是不会把数据之间写入到文件中的。只有调用flush()方法，才是立刻把缓存的数据，写入到文件中。


******************************************************************
小结：
File类是简单的操作文件夹文件的创建删除遍历什么的。不能操作文件内容的
创建的时候，可以输入字符串的地址，也可以是file对象
地址可以是目录也可以是文件

RandomAccessFile类可以操作文件的内容，读也可以写也可以，而且可以随机访问。
可以读一字节，也可以读一个类型，一个读内容到数组。写也一样可以
创建的时候，可以输入字符串的地址，也可以是file对象。后面要写rw或者r

IO流，专门对文件的读写进行操作
输入流FileInputStream,可以对文件进行读操作，读到流内
可以读一个自己，或者读全部到一个数组内。读到数组内，效率是最高的
创建的时候，可以输入字符串的地址，也可以是file对象

输出流FileOutputStream,可以对文件进行写操作，把流内的数据写到文件内
可以读一个自己，或者读全部到一个数组内。读到数组内，效率是最高的
创建的时候，可以输入字符串的地址，也可以是file对象

DataInputStream   和  DataOutputStream   是对普通输入流和输出流的一个扩充
可以直接操作各种类型的数据进行读写
创建构造的时候，必须是一个普通输入流和输出流的对象

BufferedInputStream   和  BufferedOutputStream  也是普通版本的扩充
是带缓冲区的读写操作。   单字节读写比普通版本快很多的
创建构造的时候，必须是一个普通输入流和输出流的对象


int a=read（）；就是读一个字节赋值给a
int a=read（byte[]）  就是读取的字节个数赋值给a












**********************************************************************
字符流


字符字节转换流
InputStreamReader  和OutputStreamWriter  
跟上面的Data输入流差不多，都是对普通输入流和输出流的一个扩充
这两个是操作文本文件用的

创建的时候，一样都是要用一个普通操作流对象来构造。而且读写都支持编码的、当然要一致才不会出错的

每次读写进去的都是一个char字符，两个字节的无符号整形
用数组读写的时候，可以用char数组。

InputStreamReader的基本方法：
构造方法：
.new InputStreamReader(必须是一个FileInputStream对象，编码) 可以选择编码
.read（）         一次读一个字符的，然后转换成一个整形，无符号的
		   **读出来的是一个char字符的编码数字，比如25547


*********************************************************************

文件读写流

FileReader      和FileWriter    
直径对文件进行字符的读写操作
实例化的时候，构造方法可以直接使用字符串或者File对象

FileWrite创建的时候，也可以选择加上true，就是追加内容的意思。
这两个是不可以选择编码的。项目默认的什么编码就支持什么编码，别的就不行了
write可以写字符串进去的


**********************************************************************


BufferedReader
BufferedWriter
构造的时候，需要一个FileReader或者InputStreamReader对象来构造
.readLine         一次读取一行的内容，并且返回的是字符串

读取windows上的txt文本文档时，注意txt的默认编码是GBK的，生成输出流的时候，要选择编码为GBK。


BufferedWriter的方法
.write（）        可以直接输入一个字符串
.NewLine（）      输入一个换行符
.append()         追加内容


PrintWriter的创建方法：
.new PrintWriter（file对象、字符串、普通操作流、字符操作流都可以）
方法：
.print          不换行的写入
.println        换行的写入
可以写入char【】  string  单个char


**********************************************************************
对象的序列号和反序列化
就是Object转换成byte存储和解析出来  各种类型

对象必须要继承Serializable接口   

ObjectOutputStream的创建方法：
.new ObjectOutputStream(FileOutputStream对象)
.writeObject(对象名)              写入一个对象进去
.writeXxx(_)                      写入各种类型件


ObjectInputStream的创建方法；
.new ObjectInputStream(FileInputStream对象)
.readObjcet()                     读一个对象出来 *需要强转成需要的类名
.readXxx(_)                       读出各种类型件
 
**********************************************************************

如果对象中有属性和方法加上transient，就是不会被默认的序列化方法给序列化了
但是自己也可以强制给序列化和解析

在ArrayList源码中，找到writeObject的源码，然后拷贝复制到类中
s.defaultWriteObject(); 默认能赚序列化的元素给序列化
s.writeInt(属性名)   自己把要序列化的属性给写进去；
      *这里要看属性名是什么类型就用什么类型 
解析也是一样，找到readObject的源码
s.defaultReadObject()    
this.属性名=s.readInt()    自己读出序列化的属性值给指定的属性

多个属性要自己强制写进去的时候，wirteInt和readInt的顺序不能弄错了，也就是读出的时候，也是按照当时写进去的顺序读的

这个操作也相当于之前的重写方法了。正常的序列化方法，是只能序列化普通元素的，现在给手动改写了

**********************************************************8

父类有无参构造方法的时候，建立子类的无参构造方法，会自动调用父类的无参构造方法

反序列化解析的时候，如果当前对象的类的父类没有继承Seriazable序列化接口，那么父类的无参构造方法就会被调用。





ByteArrayOutputStream      缓存输入流
创建的时候，不需要指定文件路径，
普通的out流，就是把数据写入到指定文件中
这个是直接写入到缓存中了
回头要用这些数据，直接用.tostring就可以读出来了。






ZipOutputStream:
压缩文件输出流
构造方法，需要是一个ouputStream，可以使用一个FileOutpuStream生成一个压缩目标文件。

使用时，需要先设置一个子元素名。也就是压缩文件内部的实际文件名
zop.putNextEntry(new ZipEntry(字符串(文件名)))

然后还使用普通的，读取流，写入流就可以了。


压缩文件夹的时候，需要遍历文件夹子文件，每一个文件，先设置子元素名putNextEntry，然后再写入流。








File                           字符串，File对象
RandomAccessFile               字符串，File对象


InputStream   字节输入流的超类
OutputStream

FileInputStream                字符串，file对象
FileOutputStream               字符串，file对象，true（是否追加内容）

DataInputStream                输入流对象
DataOutputStream               输出流对象

BufferedInputStream            输入流对象
BufferedOutputStream           输出流对象 


InputStreamReader              输入流对象，选择编码
OutputStreamWriter             输出流对象 ，选择编码，true

FileReader                     字符串，file对象
FileWriter                     字符串，file对象

BufferedReader                 Reader流对象
BufferedWriter                 Writer流对象

ObjectWriteStream              输出流对象
ObjectReadStream               输入流对象












***************************************************************************
多线程

Thread类是不能创建一个对象使用的，应该是一个抽象类吧
要先新建一个类，extends继承Thread类，然后重写run方法，方法体内的程序，就是线程体

然后再创建这个类的对象，就可以用线程了，当然这个对象也有线程的所有方法

多线程执行的时候，是多个线程交替抢占cpu执行程序的

**********************************************************************

Runnable生成一个线程的过程：
先创建一个类，implement继承Runnable接口，然后重写run方法，把线程体写进去。
然后再创建一个这个类的对象。
最好实例化一个Thread类的对象，把Runnable对象作为构造方法传进去。
Runnable可以让多个线程，共用一个Runnable对象。共享Runnable的数据


******************************************************

在线程体中可以直接使用Thread的方法  *这些方法是静态的

Thread.sleep(毫秒数)       在线程体中可以直接使用Thread的sleep方法，让线程休眠多少毫秒，休眠结束后，线程变成就绪状态
Thread.yield()             在抢到CPU后，让出cpu。但是下一次还会继续抢占CPU
Thread.currentThread()     返回一个运行当前线程的对象


***********************************************************************
线程的方法：
new Thread(runnable,名称)   在传入Runnable的时候，还可以传入名称
.start()                    启动线程，线程进入就绪状态
.getPriority()              取得当前线程的优先级
.setPriority()              设置当前线程的优先级
            *优先级默认是5，最大是10，最小是1.
            *Thread.MIN_PRIORITY   最小优先级
            *Thread.MAX_PRIORITY   最大优先级
优先级高的抢到CPU的几率高一下
.setName(名字)              设置线程名字 
.getName(名字)              取得线程名字


********************************************************************

多个线程操作同一个数据块的时候，数据同步的时候有可能出错。
线程是有可能就执行一条语句后，就被另一个线程给抢走CPU了，

比如一号线程用了数据，还没同步数据呢，二号线程就用数据了，就会导致数据出错了
对于这种情况，可以引入同步锁代码块

synchronized（this）{ }这种时候，同一个对象的一个线程在执行的过程中，如果被另一个线程抢走CPU，也执行不了，必须等待拥有同步锁的线程彻底执行完毕，释放同步锁后。才能执行。
**this这里可以选择只锁定指定的对象。


synchronized锁的是对象，如果多个线程用了同一个对象的数据，同一个对象又有多个同步锁代码块，一旦一个线程拿到同步锁，那么这个对象的所有同步锁代码块都被锁了，其他系统就执行不了这些代码。如果是其他的代码块，还是可以执行的。


synchronized也可以加在方法上，写在返回值之前就可以了。
这时候默认的是锁定this当前对象。也相当于是锁定了所有的对象，每个对象的线程调用的时候，就相当于锁定当前对象的所有线程了。



守护线程
会伴随着用户线程工作，一旦用户线程都结束了。守护线程也会结束掉，所以不适合做读写操作或者逻辑操作。

就像垃圾回收线程一样，别的线程工作的时候，它就会运行处理垃圾。别的都结束了，它也就不用再工作了，就结束了。

设置守护线程的方法，在start方法前面写，Thread.setDeamon(true)









***************************************************************
InetAddress的方法：
InetAddress.getLocalHost（）      获取当前主机.*可当创建对象
.getHostName()                    返回当前IP地址的主机名
.getHostAddress()                 返回IP地址的字符串。
.getAddress()                     返回原始IP地址。byte[]字节数组形式的
直接syso输入对象名，输出的是该对象的主机名和ip地址
.getByName(字符串)                可以根据输入的主机名网址或者IP地址创建对象




URL的基本属性：
构造方法：
.new URL(字符串)                 根据输入的字符串创建URL对象
         *也可以指定主机、端口、文件名等创建
         *也可以输入一个URL对象，再加，字符串。在原有对象的后面加上子名称
.getProtocol()                   返回协议名称
.getHost()                       返回主机
.getPort()                       返回端口号
.getPath()                       返回文件路径                        
.getFile()                       返回文件名
.getRef()                        返回相对路径


.openStrem()                     获取URL的字节输入流  用InputStream对象接收
  *可以包装成InputStreamReader 再包装成BufferedReader,更好操作






端口号，是从0-65535的。0-1024被系统保留了。

************************************************
TCP的通信

ServerSocket的创建方法：
new ServerSocket(端口号)

.accept()              设置监听器，一旦监听到客服端的请求，就生成一个Socket
                       *新建一个socket来接收

服务器端的Socket的方法：
.getInputStream()      返回一个Socket的字节输入流  *可以包装成BufferedReader
.shutdownInput()       关闭socket的输入流
.getOutputStream()     返回一个Socket的自己输入流 *可以包装成PrintWrite
.shutdownOutput()      关闭socket的输出流，并重新会到accept监听状态
.getInetAddress()      返回一个连接的主机地址的对象
                       *新建一个InetAddresss对象来接收，然就可以查看对象的ip



客服端的创建方法：
创建一个Socket  new Socket（主机地址，端口号）
客服端的Socket方法：
.getOutputStream()     返回一个Socket的自己输出流 *可以包装成PrintWrite
.shutdownOutput()      关闭输出流，把流传输给服务器，触发服务器的accept监听器



链接多客服端的方法，就是用死循环和线程。
先设置一个while死循环，等待接收请求，生成Socket。生成后，就用一个线程处理这个socket的请求。然后接着又循环回来，等待接收请求。




**客服端链接到服务器后，执行完任务，链接是没有断开的。
多客服端通过服务器端，互相通信。也就是所谓的聊天室功能
基本思路就是：
创建一个类，把所有的客服端链接对象，加到一个数组中。
然后其中一个客服端链接，发消息给服务器的话，
就自动转发给数组内的所有客服端链接。


用一个单例模式创建一个管理msg消息的类
每生成一个客服端链接对象，就加入到管理类中的一个数组中。
每次送客服端读取到消息后，就调用管理类中的一个转发方法；把消息转发给所有客服端链接对象。




buffered流写入的时候，是不会直接把数据写入到流中的。是先写入到缓存中的。
如果想要直接写入到流中，写完一次后，就调用一次flush()方法。flush方法就是把缓存中的信息，清空直接发送出去。


socket的getInputStream（）方法是线程阻塞的。
调用后，线程会停在这里不停调用的。会阻塞在read方法那。
会一直等待从流中读取信息，如果没有或者读完后，还会等待对方再写入，然后读。



不管服务器还是客服端的Socket，假如用了getInputStream方法，就会一直阻塞在read方法那，等待读取数据。
然后，只要对方的getOutputStream使用了close方法。就会跳出阻塞了。用了close也就是确定不再写了，那也就确定读不到了，所以就跳出了。
服务器端的Socket线程，执行完任务后。就断开链接了。所以保持长链接，可以使用getInputStream，一直阻塞在那就行了、













**********************************************************************


UDP的通信：
是不需要建立链接的，每个数据报限制在64kb。是不可靠的
在服务器端创建：
DatagramSocket a=new DatagramSocket(端口号)；
DatagramPacket b=new DatagreamPacket(接收数据的数组，接收的长度)

a.receive(b)            用服务器的receive方法接收数据，把数组存储在DatagreamPacket数据报中

然后把数组转换成String，new String（数组，0，b.getLenght()）

服务器端的回应：
也是创建一个完整参数的数据报，然后用Dsocket的seed发出去

客服端的主机对象该怎么创建呢？通过刚才存储发来数据的数据报来获得，.getAddress()就获得刚发来数据的主机对象了
端口号也是一样，.getPort()



客服端的创建：
直接创建一个完整参数的DatagramPacket，来存储各种信息
new DatagramPocket(数据数组，长度，InetAddress主机对象,port端口号)

然后在创建一个无参数的new DatagramSocket()
用.send(数据报)   来发送数据报



【数据报DatagramPacket有接收器和发送器的功能，做接收器的时候，创建时，需要一个字节数组，和长度。然后用Dsocket的receive接收方法，把数据存储在数据报中

做发送器的时候，创建时，需要完整的参数，带数据的字节数组，长度，主机对象，端口号。然后用Dsocke的seed方法发出去】


【多线程的时候，服务端的接收器数据报，要循环一次一个线程创建一个新的。不要共享同一个了，总会出错。数组也循环一次创建一个新的空的。】

【多线程的时候，可以适当把处理客服端的线程给降低，让主程序跑的快些】







*******************************************************************
转义符\会自动转义后面的字符，如果不想让它转义，那么就再加一个\，那它就转义反斜杠了，那就转义成空了。


正则表达式

String的  matches方法   是否匹配这个正则表达式的规则
[字符]                第一个位置上的字符必须是属于这里面的字符。
[^字符]            非 这个位置上的字符，只是不要这里面的字符就行
   字符的写法：可以abc、a-zA-z、a-d[m-p]、a-z&&[d-s]、a-z&&[^bcd]、
\u4e00-\u9fa5   中文的第一个到中文的最后一个

第几个字符代表第几个位置的规则，最后一个字符，就代表剩下的都是这个规则了

.                      可以代替任意字符
\d                     数字0-9
\D                     非数字               反斜杠要成对
\s                     空白字符：[ \t\n\x0B\f\r] 
\S                     非空白字符：[^\s] 
\w                     单词字符：[a-zA-Z_0-9] 
\W                     非单词字符：[^\w] 
     ***用的时候前面再加个\，不然就当做转义符处理了。

数量：
表达式后面跟上这些符号
？                     没有或者一次
*                      没有或者多次
+                      一次或者多次
{n}                    必须指定N次
{n,}                   至少n次
{n,m}                  至少n次，最多m次


边界符号:
\b                     单词边界
\B                     非单词边界
^                      行的开头
$                      行的结尾


.split方法     按照指定字符切割成字符串数组
按照叠词切割的方法。（.）\\1   
*括号就是把字符包装成一个组了，以后可以调用，用\\位置就可以调用了。


.replace方法    替换功能

不但要替换的字符，可以使用正则表达式规则来表示。
替换成的新字符，也可以使用正则表达式来表示

$加位置，就可以使用上一个表达式中的组的内容




正则表达式的类：Pattern
创建对象：
Pattern.compile(表达式)      返回一个Pattern对象
.matches(字符串)             和输入的字符串生成一个匹配器对象

这个匹配器对象，有很多方法，用表达式规则来操作这个字符串。
其实String的类的很多方法，底层就是用的这个方法来操作的。
当然还有一些别的功能，String没有封装。
这时候，就可以自己弄个匹配器来操作了。

匹配器类的方法：
.find()                      拿表达式的规则去寻找符合规则的子串 *返回真假值
.group()                     返回find查找到的子串
.start()                     返回find查找到的子串的开始位置
.end()                       返回find查找到的子串的结束位置+1

匹配器相当于有指针游标的。无论哪个操作之后，指针游标就指向最后操作的位置了。每次操作开始都是以指针游标位置开始的





************************************************
每一个类都是Class类的实例化的对象。
如果要实例化一个Class的对象，可以用三种表达方式：
1、Class c1 = 类名.class
2、Class c2 = 类名的对象.getClass()
   **也就是每个类中，都有个静态成员，class
     每个类中，都有个方法getClass（）
     这个实例化对象，就是这个类的类类型
3、Class c3=Class.fromName("包名.类名")
   **用Class的静态方法fromName来实例化


现在这个Class的实例化对象，就代表一个类了。
然后可以通过这个Class对象，再创建类的对象。
需要类有无参构造方法
用Class的newInstance()方法。 比如：
Foo foo = (Foo)c1.newInstance();





访问修饰符：
		本类	同包	子类	其他
private   	可以
默认		可以	可以
protected	可以	可以	可以
public		可以	可以	可以	可以



main方法中的接收值，String[]args
就是在命令行中，运行的时候，是可以传入几个参数的。



类的静态加载：
编译的时候，会把所有的new 类对象，都会加载了。
如果类不存在，就会报错

动态加载：
Class c1 = Class.fromName("字符串")
会在运行的时候，才会加载这个类






Class对象的操作：



获取对象类信息：

c1.getName()		返回类的全称（包名+类名）名称
c1.getSimpleName()	返回类的类名，不含包名
  **其实也就是返回类的类型名称，是int类型，还是String类型...
int void也都有class成员，也就是类类型



获取对象类方法信息：

c1.getMethods()		返回该类所有public权限的方法集合，包括父类的publci
c1.getDeclaredMethods()	返回该类所有自己声明(自己写)的方法，不管访问权限
Method[] ms = c.getMethods()
然后可以通过for循环，获取每一个方法

ms[i].getName()		返回方法名
Class type = ms[i].getReturnType()	
  **返回该方法的返回值类型，是个Class对象。要获得名次，在用getName就可以了
Clss type2 = ms[i].getParameterType();
  **返回该方法的接收参数类型，返回的是一个Class类型的集合。
    然后再循环遍历这个集合，用getName()获取类型名称



获取对象类的成员变量：

c1.getFieldes()		返回所有public权限的成员集合
c1.getDeclaredFields()	返回所有自己声明的(自己写的)成员变量。不管权限
Fields[] fields = c1.getDeclaredFields()

field[i].getName()	返回成员变量的名称；
filed[i].getType()	返回成员变量的类型，是一个Class对象。
filed[i].getType().getName()	这样就获得成员变量类型的名称了
filed[i].getAnnotation(Class<T> annotationClass) 
         返回该成员变量的指定类型的注解，如果没有就返回null


获取对象类的构造函数：

c1.getConstructor()	返回所有public权限的构造函数
c1.getDeclaredConstructor()	返回所有的构造函数
Constructor[] const = c1.getDeclaredConstructor()

Class[] paramTyepes = const[i].getParamTypes()	
  **返回该构造函数的所有接受参数类型，Class数组
paramTypes[i].getName()		这就是类型名称了



Package package = c1.getPackage()	返回该类的包对象
package.getName()	返回包的名称
Class[] interfaces = c1.getInterfaces()	返回该类的接口类型数组
................还有很多方法，可以看API



获取指定某个方法：
c1.getMethod（） c1.getDeclaredMethod（）
  **还是一样，getM是查找public的，getD是查找自己写的。

Method method = c1.getMethod("方法名"，接受参数的类型)
  **接受参数类型，是一个Class对象数组，可以用new Class[]{"""""};
    也可以直接一个一个写类型，不用数组。
    写法是：比如int.class  String.class

现在method就代表一个指定的方法了。用method也可以执行方法体；
Object o = method.invoke(类的对象名，实际参数)；
  **实际参数，可以用Object数组传入，new Object[]{10,20}
    也可以，直接一个一个写，10,20
    o是返回值，方法体如果没有返回值就是null，如果有，o就接收了
    如果方法没有接收参数，那么实际参数可以不写，




泛型不算是一个特定的类型。
和泛型和没泛型的类。都是同一个类型的。
集合本来是什么都可以添加的。加泛型，只是防止输入进去错误类型。
在编译的时候，会检查泛型的输入。
但是可以用方法的反射，直接输入进去不同的类型，编译的时候，就不会检测到了


泛型类的使用：
定义一个类，后面加上<T>,内部的变量也使用T类型。那么实例化这个类的时候，传入的类型，就是内部T类型变量的类型了。
public class Test<T>{
    public T str;
}
Test<String> test = new Test<String>();
这样的话，str的类型就是String类型的了。

还可以使用多个泛型的，内部的变量，也可以使用选择使用某个泛型
public class Test<T，U，E>{
    public T str;
    public U a;
    piblic E b;
}
Test<String，Integer，Boolean> test = new Test<String，Integer，Boolean>();
这样实例化的时候，传入的类型，就会自动对应到变量使用的T、U、E了。

泛型的名称：
使用大写字母，可是是任意大写字母，一般有些通用规则的；
K,V   代表Key，Value   键和值
T     代表type类型
N     代表Numble数字
E     代表Element 元素，一般在List中使用。



泛型接口：
一个接口可以使用泛型；一个类implements实现它的时候，必须制定泛型的。
或者实现类也使用同一类型的泛型，那么生产实现类对象的时候，指定的泛型，也同样使用到接口上了。
public interface Test<T>{
    public T getStr();
}
public class Test2 <T> implements Test<T> {
}


泛型方法：
在返回值前面写上泛型；
传参和返回值也都可以使用泛型。
使用的时候，在方法名前面指定泛型就可以了。
public <T> void getStr (T a){ 
}
test.<String>getStr("str");


泛型Class对象：
如果一个方法，要不确定的Class对象，直接使用Class<T> object
public <T> List<T> parse (Class<T> object)
比如指定一个Test类泛型，那么返回值就是List<Test>,传入值就是一个Test类型的Class对象


泛型数组：
public static <T> T[] fun1(T...arg){  // 接收可变参数    
    return arg ;            // 返回泛型数组    
}   


泛型绑定类，如果传入一个T类型的参数，因为还不知道具体是什么类，那么在方法内就是用不了T的方法了，如果传入的参数都是某一个类的子类，那么就可以先绑定指定父类，这样就可以使用父类的方法了。
public <T extends Parent> void get (T test){
	test.get();
}
也可以指定绑定多个类，和多个泛型绑定
public <T extends Parent & Super, U extends Parent> void get (T test)




通配符<?>
可以接受各种泛型的类。
Point<?> p = new Point<String>("test");
Point<?> p = new Point<Integer>(1);
只能使用在定义变量的时候；new生成实例化对象的时候，不能使用这个的。


通配符的限定类型
通配符也可以限定类型的，写上? extends 类型就可以了
然后后面赋值给它的，实例化对象，就必须是继承或者就是这个类型的。


通配符的super绑定：
可以限定为指定类型的所有父类。后面赋值给它的，实例化对象，就必须是或者是这个类型的父类。





****************************
定义一个枚举，
public enum ColorEnum{
a,b,c,d,e,f}

使用的时候：
.values()方法会返回一个包含所有数据的数组，数组类型就是定义的枚举名称ColorEnum
ColorEnum[] values = ColorEnum.values();

使用方法：
枚举名.数据 会返回一个枚举名类型的对象。
ColorEnum a = ColorEnum.a









第十章 高级控件

*************************************************************************
自定义适配器的写法
SimpleAdapter a=new SimpleAdapter(context,data,resource,from,to)

context:上下文对象
data：数据源，类型是List<map<String,?>>
resource: 布局  android.R.layout.XXX
from: 就是map中的键名数组，对应布局中的控件数量
to：就是布局中的控件ID数组

ListView：

不设置背景，默认是透明的。其他的控件也是一样的。比如textView，没有内容的地方就是透明的。
一些特有属性：

android:headerDividersEnabled
android:footerDividersEnabled="false"    
是否在页头页脚视图下，显示分割线，默认是true


android:divider="#ffffff"       	 设置分割线颜色
android:dividerHeight="1px"              设置分割线高度
分割线颜色设置为“@null”，就是没有颜色了，也就不显示了。分割线高度还可以再设置成0dp高 
divider只能使用drawable资源的，使用图片或者xml绘制的。使用颜色值的话，是无效的，也就成透明没有分割线了。
使用shape绘制的时候，使用这两个属性，必须要有size属性的
<solid android:color="@color/account_line" />  
<size android:height="1px" />  
dividerHeight的高度也可以设置分割线高度的





android:choiceMode="singleChoice"        设置选择模式   单选
                  **multipleChoice       多选模式

android:overScrollMode="never"		拖拉到不能再拖拉的时候，不显示阴影

android:fastScrollEnabled="false"
当内容超过4页的时候，这个属性设置为true，会显示一个快速滑动的滑动块。默认为false的

android:scrollbars="none"		隐藏滚动条
android:listSelector="@drawble/seletor"	设置点击Item的效果
有时候效果会被覆盖，这时候设置这个属性drawSelectorOnTop = true



listView.setSelection(mDatas.size() - 1)
  手动设置翻到指定条目

int position = listView.pointToPosition(x,y)
  根据xy坐标点，返回条目item的位置号码

Object ob = listView.getItemAtPosition（2）
  根据条目位置，返回条目内容，也就是Adapter的getItem（）方法返回的数据。可以自己强制转成自己的内容类型

int position = listView.getPositionForView(view)
  根据传入的view，返回条目item的位置号码。传入条目里面的任何一个子控件的view就可以的。【可以利用这一点把，item中的子控件的点击事件，放在activity中处理，实例化适配器的时候，让activity传入一个点击事件进来。然后在activity中，根据点击事件中的view，来找到点击的是第几项。】

listView.getFirstVisiblePosition()
  返回当前可见的第一个item位置号，是从headView开始计算的。

int end=listView.getLastVisiblePosition();  
  返回当前可见的最后一个的item位置号


listView.getChildAt(0)
listView的这个方法，是从当前屏幕内显示的条目内，开始计算的。比如当前屏的第一行是第6个item，那么getChildAt（0），返回的就是第六个item。
【在刚设置Adapter后，其实listView内容还没有离开加载完毕item呢。如果这时候使用getChildAT这类的方法，是获取不到的。可以使用一个list.post的方法，也就是在UI队列加个操作，等UI加载后再执行这个方法了。】


listView.getHeaderViewCount()
返回listView的HeaderView的数量



listView.getAdapter();
返回ListView的适配器，返回的类型是ListAdapter类型，强转成传入的类型就行了。如果有headView的时候，那么返回的适配器，就不是传入的类型了，强制也没用的。


添加HeadView，在页头添加一个view：
新建一个xml，生成一个view，然后调用listView的方法：
listView.addHeaderView(view)
还可以设置是否可以点击：
listView.addHeaderView(view,null,false)   不可点击




Listview的监听器
onItemClickListener     监控组件被点击
onScrollListener        监控Listview滚动
onItemLongClickListener	长按监听器

长按监听器是有返回值，是否消费事件，如果不消费事件，那么就会给单击监听器了，如果长按那也写了处理方法，这样就会单击长按的方法都执行了。如果不想让单击的执行，那么就返回ture消费了。

onItemClickListener方法的接收值，第三个int类型为Position  数据源的位置
第二个是选择的view，可以配合Listview的一个方法使用
.getItemAtPosition(position值)       可以提取选择的位置信息。



onScrollListener接口有两个方法
一个是onScroll方法
第二个接收值，是当前页面的第一个条目的位置 
  **只要上面的item还漏一点点在屏幕内，就算第一条的
第三个接收值是，当前页面显示了几个条目
  **只要最下面的item，已经显示一点点在屏幕内，也算一条的。
第四个接收值是，总共有多少个条目



一个是onScrollStateChange方法 第二个接受值是滑动状态
一般可以用switch判断，然后做出反应
一个是SCROLL_STAFF_FLING            滑动之后然后松手，屏幕会惯性滚动
一个是SCROLL_STAFF_TOUCH_SCROLL     滑动之后没有快速松手，手指没有离开屏幕
一个是SCROLL_STAFF_IDLE             滑动停止

适配器.notifyDataSetChanged()       更新ListView的数据

notify失败的大部分原因，都是数据源List，不是同一个对象了。就算改变数据了，也是改变的另一个list对象，不是adapter原始的那个List。所以刷新的时候，刷新的还是老的List的数据。



适配器的notify大致过程，会重新加载视图给ListView。从第一个加载，加载到当前屏幕上显示的最后一条记录那。之后的就不再加载了。相当于是从第一屏加载，然后滚动到当前屏幕位置那，当前中间的都会加载了。



notify的时候，如果在getView中，使用scrollTo（）方法，也有可能会失效的。因为getView的时候，view正在生成刷新呢，scrollTo()效果可能就会被覆盖了，也可以使用post方法了。


如果ListView一开始有多个一屏的Item，后来修改了adaList。使Item少于一屏，但是缓存的那些view并不会被删除的。

ListView如果被别的控件覆盖了，如果别的控件被隐藏了后，那么ListView会重新加载一个数据的。
所以说，如果在加载数据的时候，遮盖了ListView，然后在数据加载后，notify数据源后，把遮盖物隐藏了，那么就会进行两次的加载数据，就有可能会冲突了。
1、遮盖物消失，ListView会重新加载一次老数据。
2、notify后，ListView会加载一次新数据。
所以，这个问题要注意。



如果在页面发生跳转后，比如跳转过来，或者关闭了某个页面回到了当前页面。这时候再notify的话，需要把adapter和listview在绑定一次：listView.setAdapter(adapter).





********************************************
关于适配器：
ArrayAdapter，只能适用于简单数组和集合，数组或集合中的一条数据，就是一个条目。
如果存储对象的话，输出的就是对象的toString方法


对于条目内容，有很多种数据的话，就只能使用SimpleAdapter和BaseAdapter了
用SimpleAdapter，数据源是一个List<Map<String,String>>集合，集合中的每一项，都是一个Map对象，一个Map对象可以put很多属性进去。
这样适合所有数据都是同一个类型的。因为Map的value只能统一一个属性的。

用BaseAdapter，数据源可以用类对象、list集合、也可以用一个游标。

SimpleAdapter，必须用List<Map<String,XX>>泛型的数据源；
实例化适配器对象的时候，构造方法中，需要指定数据的key数组；然后对应布局控件ID的数组；
之后适配器会自动把数据和控件，用内部的getView方法组合，生成view来显示。


BaseAdapter，是由自己手动的生成一个view，最后return这个view来显示的。
在getView中，用LayoutInflater来绑定自定义xml布局，生成一个view。
最后对view中的控件，设置上数据。

对于适配器的第一次生成的数据，是可以传递进去一个空数据的。
适配器会先检查总共有几个条目，如果是0的话，就不会执行getView加速数据的操作





ArrayAdapter适配器的一些方法：
ada.add(数据)		手动添加一个数据	
ada.getCount()；	返回适配器的条目总数
ada.getItem(条目位置)	返回指定位置的条目数据
ada.remove(条目数据)	删除指定的条目数据

对于适配器中的数据，可以用数据源操作后，用ada.notifyDataSetChanged()刷新。
也可以直接用适配器直接操作。这样就不用刷新了。



适配器的优化：
适配器加载的时候，每一个列表项。都要生成一个view，然后每次都要实例化控件。
这些都是重复的，可以优化下，让第一个生成和实例化后，之后复用这个就行了

在getView方法中，第二参数个是View对象。
是一个缓存View，缓存的是上一个生成的View对象。接下来复用这个就可以了
  如果是第一次加载，缓存View肯定是空，然后手动成一个View对象。
  如果不是第一次不为空，那么就直接使用这个View就可以了

对于控件实例化的复用：
  先新建一个内部类ViewHolder，设置几个指定的控件类型对象。
  第一次生成View的时候，实例化一个ViewHolder对象。
  实例化控件的时候，使用ViewHolder的属性名来赋值holder.bt=
  最后把ViewHolder对象存储在view中。
  如果不是第一次，ViewHolder对象就等于，就从convertView中取出ViewHolder。view.getTag();

最后直接用holder对象的属性名来设置数据



ViewHolder holder;    ViewHolder的类名随便起
if（convertView==null）{
   holder = new ViewHolder();
   convertView=LayoutInflater.from(上下文对象).inflate（布局地址，null）；
   holder.bt=(Button)convertView.findViewById(id地址)
   convertView.setTag(holder)
}else{
   holder = convertView.getTag();
}

holder.bt.setText();

return convertView


使用holder后，理论上每个布局view应该都一样的，不一样的地方只能是内容。每一项填充不同的内容。

如果需求不同类型的内容，布局view也不一样的话。
比如一种少数类型使用的时候，需要改变了一些布局view的属性，比如设置背景色，文字颜色，文字大小等等...那么下次缓存过来，让多数类型内容使用的时候，布局view的这些设置可还都在的哦。
【所以，这种情况，一定要切记，使用的时候，布局view设置，要先恢复成初始状态再使用。】


多类型数据多布局的适配器使用：
重写两个方法：
getViewTypeCount（）		返回总共有多少种类型
getItemViewType(position)	返回当前Position的类型。


getItemViewType方法，返回类型的时候，类型值必须从0开始的，比如0,1,2..

然后在getView方法中，自己可以先使用getItemViewType方法，返回类型判断是哪个类型的，就加载哪种布局。


加载后，系统内部就把这个布局，和当前类型值绑定上了。
下次再getView的时候，系统内部应该是：
先判断下当前要生成的item是什么类型的，
然后再去查看缓存的View都是什么类型，
会把缓存所有的View，都看下是什么类型的，如果有类型相同的，就把缓存View拿出来用，
如果没有一个类型一样的，就返回个为空的缓存View。







*********************************************************************
Calendar 日历类 
Calendar.getInstance（）		返回一个当前日期的对象
calendar.get(Calendar.YEAR)    	   	获取当前对象里面的年
calendar.get(Calendar.MOUTH)  		获取当前对象里面的月   默认是从0开始的
calendar.get(Calendar.HOUR_OF_DAY)  	获取当前对象的24小时制的小时数
calendar.get(Calendar.HOUR)  		获取当前对象的12小时制的小时数

calendar.set(Canlendar.XX，8)	  	给当前对象的指定时间段，设置数据
  **比如给小时这个字段，设置个8的数据。就是把当前对象的小时改成8点了。

Calendar.DAY_OF_WEEK			获取当前是这个星期的第几天。
排序是从日一二三四五六这样的，返回数字是1234567，也就是星期日是1，星期一是2.
设置的时候，这是这样的逻辑


calendar.add(Canlendar.XX，-8)		将指定的日期字段，加或者减指定的数字。
calendar.getActualMaximum(Calendar.DAY_OF_MONTH)	返回当前月的天数



calendar.getTimeInMillis();	   把当前对象的时间转成毫秒数

calendar.setTimeInMillis（毫秒数） 把传入的毫米数，转成日期



Date date = new Date();		返回一个当前的时间对象
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
String str = format.format(date)
把date的日期，按照format的格式，返回成一个字符串对象
  **yyyy-MM这个格式，自己随便写，最后只是把中间的yyyy和MM换成日期数字而已。       在这个字符串中，yyyy代表年，MM代表月，dd代表天。HH小时，mm分钟，ss秒
如果要24小时制，小时就用HH，如果用12小时制，小时就用hh。


DateFormat format = DateFormat.getDateTimeInstance()  
返回一个当前环境的默认时间格式


*********************************************


DatePicker的监听器
.init(年，月，日，OnDateChangedListener)  *年月日是要填写的默认年月日

OnDateChangedListener接口方法有四个参数，
第一个是DatePicker的地址，用于判断哪个选择的
后面依次就是年月日      *月还是要加1



【我理解的监听器，就是各种控件被操作后，控件的一些属性被改变了，然后得到的新的新的属性值，供我们使用。】
 


TimePicker设置监听器：
.setOnTimeChangedListener()
对应的接口：
OntimeChangedListener()
有四个接收值，第一个是控件的地址，后面依次是小时、分钟

******************************

对话框的DatePicker写法：
直接new DatePickerDialog（）  最后.show()
有五个参数，第一个上下文，第二个监听器OnDataChangedListener（），后面三个依次是年月日
月份是从0开始的，如果是一月的话，就传0了
返回的月份也是从0开始的

******************************
对话框的TimePicker写法：
new TimePickerDialog()
有五个参数，第一个是上下文，第二个是监听器OnTimeSetListener(),小时，分钟，布尔值是否需要24小时




*************************************************************************
GridView的使用方法：

新建一个数据源
然后新建一个适配器，把数据源放在适配器里。

最后.setAdapter（适配器）


*关于自定义布局，其实就是设置的大布局中的子布局的样式。

GridView的一些重要的属性
numColumns                 每一行有多少列
horizontalSpacing          每列之间的列距
verticalSpacing            每行之间的行距


GridView的监听器：
setOnItemClickListener  (new OnItemClickListener)



***************************************************************************
Spinner的使用方法：
可以使用数组适配器，也可以使用简易适配器
*适配器这里要加载一个下拉布局.setDropDownViewResource

Spinner的监听器：
.setOnItemSelectedListener(new OnItemSelectedListener())



*************************************************************************
关于ProgressBar的使用方法：
requestWindowFeature(Window.FEATURE_PROGRESS); 
给窗口加载有进度的进度条

requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
给窗口加载有没有进度的进度条

setProgressBarVisibility(true);
设置有进度的进度条的 可见值

setProgressBarIndeterminateVisibility(false);
设置没有进度的进度条的 可见值

setProgress
设置可见进度条的  进度值


一些重要属性
max                    最大值
progress               初始值
secondaryProgress      第二初始值
 
一些重要方法：
setProgress（int）               设置第一进度值
setSecondaryProgress(int)        设置第二进度值
getProgress（）                  获取第一进度值
getSecondaryProgress()           获取第二进度值
incrementProgressBy()            增加或减少第一进度值
incrementSdcondaryProgressBy()   增加或减少第二进度值
getMax（）                       获取最大值（）
setIndaterminate(布尔值)         不精准的显示（是否）


**********************************************************
ProgressDialog的使用方法
新建对象
new ProgressDialog(上下文对象)

.setTitle(字符串)      设置标题
.setProgress(值)       设置进度值
.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)   设置样式

.setMessage(字符串)    设置对话框里面的文字信息

.setIcon()             设置图标
.dismiss()             关闭对话框
.setMax(int)           设置最大值
.incrementProgressBy()      设置进度
.setIndaterminate(布尔)     不精准的显示（是否）

.setButton(DialogInterface.BUTTON_POSITIVE,"确定"，new DialogInterface.OnClickListener())
设置对话框里面的按钮，第一个选择按钮类型，第二个按钮的文本
第三个是按钮的监听器

.setCancelable(布尔值)     设置是否能通过手机返回键返回。

.show()   显示出来


****************************************************************
ProgressBar的自定义样式
新建一个layer-list的xml
再建三个item   名字是确定类型的
第一个是background
第二个是secondaryprogress
第三个是progress

*顺序不能弄混的
第二个和第三个在item下面要有<clip>，然后再写形状，填充色什么的



圆圈进度条的自定义样式：
在xml中，设置indateminateDrawable属性
android：indaterminateDrawable = “@drawable/XX”
可以是一个图片，也可以是一个drawable资源，自定义的图形或者自定义的动画。

使用动画的方法：动画操作对象可以是一个图片，也可以是自定义的形状，把形状写到动画标签内部就可以了。这样就是指定动画就是操作这个图形的。
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromDegrees="360"
    android:toDegrees="0" >
    <shape
        android:innerRadiusRatio="3"
        android:shape="ring"
        android:thicknessRatio="8"
        android:useLevel="false" >
        <gradient
            android:endColor="#ffffff"
            android:startColor="#88ff0000"
            android:type="sweep" />
    </shape>
</rotate>
动画持续时间，设置是没有用的。progressbar是自己的动画持续时间的。而且这个动画是会循环播放的。
在progressbar的xml中设置持续时间：
android:indaterminateDuration = "500"

设置动画播放方式：
android:indeterminateBehavior="repeat"		循环（默认）
cycle	正一圈倒一圈






******************************************************************

webView的方法：

webView.loadUrl()           加载页面
  **可以是个网址，可以是本地页面（assets）本地页面的写法：
    "fiel:///android_asset/xx.html"
webView.requestFocus()	    页面获得焦点
webView.reload()	    重新加载页面，刷新
webView.setWebViewClient(new WebViewClient(){})
  **设置浏览网页客服端的监听器。设定使用哪个浏览器。
    需要WebViewClient接口对象,其中有多个方法：
    
    shouldOverrideUrlLoad（）方法
    会传输进来两个参数，一个是webView，一个是Url。
    用webView.loadUrl(url)就可以了
 
    onReceivedError（）方法，网页流量出现错误，打不开的时候调用
    第一个是view，第二个是错误码
    可以用view.load("")一个本地网页，或者设置个textView显示提示语



WebSettings settings = webView.getSettings（）          
  **返回一个WebSettings对象，对WebView的设置

settings.setJavaScriptEnabled(true)     启用javascript  
settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); 使用缓存模式


webView.getUrl()                  返回当前显示的url地址
webView.canGoBack()               能否返回上一个页面
webView.goBack()                  返回上一个页面
    
手机物理按键，后退键的设置方法：
重写Activity的onKeyDown方法   
两个接收参数：KeyCode:按键编码       KeyEvent:按键事件
默认是return super.onKeyDown(KeyCode, event)是会关闭当前活动页面的。
如果设置return true。就是不关闭了
然后可以，设置web.goBack()返回上一个网页，可以加判断，什么时候关闭页面。


webView.setWebChromeClient(new WebChromeClient(){})  
  **用于网页浏览器的控制。需要一个WebChoromeClient接口对象。
    有一个onProgressChanged方法：  网页进度条的设置，有一个progress进度值
    可以创建一个ProgressDialog来接收这个值，来显示进度。
    还有一个onReceivedTitle方法，第二个就是网页的titile信息文本


webView.setDownLoadListener(new DownLoadListener(){})
  **设置下载监听器
    接口有个onDownLoadStart方法，第一个参数就是下载页的URL地址
    然后可以用个子线程，发起个HttpURLConnection链接请求，新建一个文件地址，然    后用下载页的inputStream读取出来，然后写入到文件地址那。
    
    使用系统的下载页面，把uil解析成uri，然后设置个Intent，从系统浏览器跳转到网页就行了
    Uri uri= Uri.parse(agr0);
    startActivity(new Intent(Intent.ACTION_VIEW,uri))





*******************************************************************
Fragment的使用：

新建继承Fragment类的时候，导入的最好是v4包里面的。
然后Activity也使用FragmentAvtivity的。

想要在Activity中使用fregment，先在Activity的xml文件中，写一个fragment标签，name为fragment类的包名类名，还要定义一个id。

然后在fragment类中重写onCreateView方法。
然后把fragment类对应的xml文件，包装成一个控件视图view返回去。
inflater.inflate(R.layout.fragment2, container, false);  
inflater.inflate(xml文件，viewgroup，是否加载到viewgroupp中)
就生成一个view了，然后return这个view

LayoutInflater inflater = getActivity().getLayoutInflater();  
inflater的另一种创建方法;

inflater.inflate(布局对象，viewGroup，布尔值)

viewGroup就是要是用的父布局；
如果填入父布局这个选项，那么布局对象的，根布局宽高值就有用了，如果填成null，那么自定义布局的根布局宽高就无效了，这个自定义布局的实际宽高，就是由内部控件的宽高来决定的。
  **控件设置的宽高，都是相应对父布局的来设定的。如果没有父布局，那么宽高就没效果了。所以这里才引入一个父布局的选项。

布尔值，如果是true，就是直接把当前布局，添加到父布局中，生成的view对象就是父布局对象。
如果是flase，就是不添加到父布局中，只是用父布局的宽高信息。


如果使用了父布局，父布局的宽高，就会替代布局地址中的顶级布局的宽高信息。








静态加载，就相当于在主Avtivity页面中，找一款区域放一个fragment标签，标签name那设置为fragment类的路径。     回头fragment的页面就显示在那块了。

fragment的页面基本上正常设置



**************************************************

动态加载方式：
就不直接在主Activity页面上放一个fragment标签了
现在是在主页面放一个布局，布局要有id，回头来接收fragment页面，把fragment当做一个view控件放在这个布局中

然后在类代码中，先新建一个fragment类的对象。
然后再新建一个Fragment事务管理员对象
FregmentManager fm = getFragmentManager()
如果是用的v4包，就要使用getSupportFragmentManager()这个方法，获取管理员对象

然后在用管理员对象的方法生成一个事务对象；
FragmentTransaction ft = fm.beginTransaction()

ft.add(R.layout.layout1，fg1);
添加一个Fragment对象；参数是（要放的布局地址，fragment对象），还可以有个string的tag，方便以后查找对象。

ft.remove（fg对象）              删除一个Fragment对象
ft.replace（布局地址，fg对象）   把布局地址内的fg对象，替换成指定的fg对象。这个是把所有的fg对象都删除掉的。  

ft.hide(fragment对象)		隐藏指定的fragment页面
ft.show(fragment对象)		显示指定的fragment页面

ft.commit()		操作完后，commit提交才算真正完成操作。
addToBackStack（null）    	允许返回到上一个状态


如果允许按返回键返回到上一个状态，可以在提交前加入addToBackStack（）


manager.findFragmentById();  /静态加载的方法，生成Fragment对象。

manager.findFragmentByTag();//根据TAG找到对应的Fragment实例，主要用于在动态添加的fragment中，根据TAG来找到fragment实例  

manager.getFragments();//获取所有被ADD进Activity中的Fragment  



**************************************************


Activity与Fragment通信
在放置add()前，新建Fragment对象后，用对象的.setArguments(Bundle对象)传递数据给自己的页面。
新建一个Bundle对象，用Bundle对象的.putString（key，vulue）添加数据
【Bundle是一个map集合，而且是没有指定泛型的，什么都可以存】

Fragment页面接收数据的方法：
在onCreateView方法中直接.getArguments（）生成的是一个Bundle类型的对象
然后用Bundle类型的.get(key)方法，接收数据
.getActivity()可以获得宿主的地址

【实时的信息，应该用事务的replace替换功能
因为add是新增的意思，直接在后面新增加一个fragment对象，之前的fragment对象还在呢。
replace是替换的意思，
是把之前的fragment替换成新的fragment对象。】



在onActivityCreated方法中，才能获取父Activity的控件，使用findviewByID

****************************************************


Fragment给Activity回传数据

【相当于是在Fragment页面新建一个Activity的对象，然后在Fragment中用Activity对象的方法，直接操控Activity的数据。当然也要在Activity中新建一个方法来让这个对象操作数据哦】

先在Fragment页面新建一个接口，定义一个有接收值的方法
然后让Activity继承这个接口，实现这个方法

然后创建一个这个接口的对象

重写onAttach获取activity对象，或者直接getActivity（）获取宿主对象
然后用activity对象强转，赋值给接口对象

最后在onCreateView用的到的地方，写接口对象.方法名（要传的信息）
【接口对象也就是实现了接口的Activity了，相当与用Activity的对象操作自身】

在Activity页面接口方法那，再处理接受到的数据就行了






静态加载Fragment传递数据

在Activity页面生成一个fragment管理员，
然后用管理员的.findFragmentById(布局地址)方法，找到放在布局中的fragmentId
生成一个Fragment对象
然后实例化加载的Fragment类，对象是刚才生成的那个

最后直接用这个对象操作数据，用set属性的方法。




多Tab的fragment界面，后台久了被系统杀掉，重启后界面fragment重叠的解决方法：
后台久了，内存不足的时候，系统会把Activity给杀掉，但是fragment还存在，在下次启动软件的时候，系统会自动把附在Activity上的Fagment全部加载上去。
这样就会造成重叠了。然后Activity初始化的时候，会重新创建各个Fragment的对象，然后显示一个对象，这样界面上就又叠加了一个Fragment。

解决方法：
Fragment附加在Activity上的时候，会调用Activity的一个生命周期方法onAttchFragment
在第二次恢复启动全部加载的时候，也会一一调用这个方法的。
然后判断送入的fragment是哪个Fragment类的实现，然后就把fragment赋值给那个类的对象。
然后再通过管理员对象全部隐藏，显示需要显示的那个。

如果需要恢复页码的话，可以通过onSaveInstanceState方法来保存下页面，最后在onCreate方法中，提取页码。然后再显示这个页码的页面。





************************************************************************
ViewPager的使用

在主页面XML中加入标签
<android.support.v4.view.ViewPager>      页卡
在ViewPager内部添加
<android.support.v4.view.PagerTabStrip> 页卡标题

1.PagerAdapter适配器的用法
数据源 List<View>

新建多个布局，把布局转换成一个View对象的方法：
View.inflate(上下文，布局地址，父组件)   生成一个View对象
然后都加入到List集合中

适配器 PageAdapter
然后新建一个类，继承PagerAdapter
定义一个List<View>属性
定义一个构造方法用于接收传送来的List<View>

重新它的几个方法【现在重写，它自己会按照需要选择什么时候用】
getCount()              返回页卡的数量   *return List集合的长度size
isViewFromObject()      view是否属于这个对象   *return arg0==arg1
instantiateItem()       添加一个view对象
   **写入container.addView(list.get(position))
         return list.get(position)
destroyItem()           销毁一个view对象
   **写入container.remove(list.get(position)).取消super语句


这种adapter也不会一次全部加载完所有View的。也是只加载3个，如果多了就删除掉的、



viewPager.setCurrentItem(0)
手动设置跳转到指定页面。
viewPager.setCurrentItem(1,true)
第二个参数，是指是否需要切换效果。


如果跳转到中间的页面时，是会加载3个页面的，但是加载顺序和视图顺序就不一样了。实际加载视图顺序会是213的，也就是先加载中间的，然后前面后面的。getChildAt的时候，想获取中间的，就是0了。



点击事件的顺序，是先由父控件接受，然后传递给子控件，如果子控件有点击属性，就让让子控件去处理的。
如果不想让子控件处理，就给子控件设置个属性，不处理点击事件。
clickable=“false”

如果子控件没有点击属性，但是想让子控件去处理。
就在需要处理的时候，设置个：请求父控件不拦截触事件
getParent().requestDisallowInterceptTouchEvent(true);




添加标题，数据源List<String>然后传递给Adapter类加载
getPageTitle             返回当前页面的标题
return 标题集合.get(position)

PagerTabStrip的一些属性设置
.setBackgrounndColor()              设置背景颜色
.setTextColor()                     设置文字颜色
.setDrawFullUnderline()             设置标题栏的分割线是否显示
.setTabIndicatorColor()             设置标题下划线的颜色

PagerTitleStrip标题栏和tab几乎一样
就是没有分割线和下划线。还有不能点击标题跳转。




*****************
给ViewPager添加当前页码的方法：
可以使用RelativeLayout布局。这个布局内控件是可以重叠的。
最先放个ViewPager控件，然后再放个LinearLayout在上面显示页码。




2.FragmentAdapter适配器的方法
数据源 List<Fragment>

新建多个Fragment类，并且各自绑定XML
然后直接add加入到List集合中

适配器 FragmentPagerAdapter
自定义类继承FragmentPagerAdapter

新建两个List集合，接收Fragment数据集合和Title标题集合
重写三个方法：
标题的还是getPageTitle
getCount（）                          设置页面个数
getItem  ()             返回第几个页面显示的数据源  返回对应位置的List数据

实例化适配对象的方法：
new FragmentPagerAdapter（FragmentManager对象，....）
  这个类的构造参数，必须要有个fm对象的。后面的参数还可以自己增加。
但是第一个参数要必须要传递一个Fragment管理员对象的。
可以先把类继承的Activity改成FragmentActivity
然后获取管理员的方法是getSupportFragmentManager（）


【其实也可以不用自定义适配器，可以直接新建一个FragmentPagerAdapter对象，这时候构造方法，只需要传进来一个FragmentManager对象就可以了。至于那两个方法操作的数组，直接在内部用Activity的数据就可以了】

如果要想着几个view页面里面有各种控件操作监听处理，就要使用Fragment适配器了，它可以配置自己的XML页面


3.FragmentStatePagerAdapter适配器
需要再重写两个方法：
instantiateItem             创建一个list集合的页面显示到主页
destroyItem                 销毁指定页面
这两个不用改写[不用写的]
这个适配器是有创建销毁动作的
如果有很多页面的话，适合使用这个，减少内存





PageView的监听器：
OnPageChangelistener（）
里面有三个方法


onPageSelected这个比较常用
返回的值是当前页面的Position位置【从0开始的】
  **这个值变化的时机问题，这个值是什么时候才改变的呢？
原本想的是，页面切换后，页面不动了，然后就改变了。
其实不是的，这个值在滑动进度到一大半的时候，就开始改变了。


onPageScrolled方法
有三个接受值：
第一个，是显示在当前屏幕左边的页面的页码，不管往哪滑动。

第二个，如果是往左滑动，显示的是0-1之前的滑动进度
        如果是往右滑动，显示的是1-0之间的滑动进度
第三个，如果往左滑动，显示的是屏幕左边显示的当前页面的像素


使用手动指定页面的方法viewPager.setCurrentItem(0)，一样会调用onPageScrolled方法的




给ViewPager设置切换动画：
viewPager.setPageTransformer(true,new一个动画类)
新建一个动画类，实现动画效果。传入这个类的对象就可以了
新建一个类，implements继承一个接口，PageTransformer
实现其方法。
if (position <= 0) {}就是左边的页面，
从左边的页面，滑动到右边页面的时候。
左边页面的移动值，也就是从0到-1了。(正常移动，移动个1，不就是往右移动一点嘛)
   现在左边页面都往左边走了，也就是-1那了。
else if (position <= 1) 这是操作右边的页面
正常滑动，这个页面的滑动进度值，也就是从1到0了。原本是在移动了1的位置那。



viewpager禁止滑动的方法：
新建类继承Viewpager，然后重写onTouchEvent和onInterceptTouchEvent方法，return那里，设置成return false；
viewPager的滑动方法，也是在ouTouchEvent里面的。不执行super.onTouchEvent方法，自然就不会执行滑动的效果了。



viewpager的适配器，notifyDataSetChanged方法，如果只改变view内容，适配器是不会刷新的。这时候可以直接，再设置一次适配器viewPager.setAdapter（）
或者，重写一个适配器的方法，getItemPosition（），修改成retrun POSITION_NONE.就可以使用notifyDataSetChanged方法了。









*************************************************************
ViewFlipper

动态加载的方法
先新建一个ViewFlipper标签
动态加载是，直接用ViewFlipper对象的.addView()增加几个View对象进去

把准备好的图片换成View对象添加进去
新建一个空的ImageView对象
用.setBackgroundResource()  添加背景图片
最后把这个ImageView对象添加到ViewFlipper那里


自动播放：
最后设置一些动画参数
.setInAnimation()            设置入场动画 
.setOutAnimation()           设置出场动画
.setFlipInterval()           设置切换时长
.startFlipping()             启动


手动切换的方法：
重写Activity的onTouchEvent方法    会传进来一个手势事件对象
对象event.getAction()            获取动作
 关于动作的几个常量
 MotionEvent.ACTION_DOWN     手指落下
 MotionEvent.ACTION_MOVE     手指移动
 MotionEvent.ACTION_UP       手指离开

关于逻辑：
先定义一个float单精度的变量
在手指落下时候，记录一下x轴的数值  event.getX()

手指移动的时候，在用x轴的值与之前记录的值相减。
可以设定一个偏差值，大于多少再执行

ViewFlipper对象.showPrevious()          显示前一页
               .showNext()              显示后一页





********************************************************************
.getResources().getString(R.string.XXX)
在主程序中调用string文件里面的自定义字符串内容的方法

ScrollView   滚动条
在xml文件中，把要使用滚动条的控件写在ScrollView中
xml设置：       scrollbars=“none”     设置滚动条不显示
程序中设置：    setVerticalScrollBarEnabled(false)    滚动条不显示


监听器：
new OnTouchListener          监听滚动条滚动的状态。
sv.getChildAt(0)             获取ScrollView第一个子控件
子控件.getMeasuredHeight()   获取子控件的高度
sv.getHeight()               获取屏幕默认第一屏状态sv占的高度
sv.getScrollY()              获取滚动条Y滚动的距离  从最顶部的位置到现在滚动位置的距离

如果想获取滚动条是否滚动到底，可以判断子控件高度，等于第一屏sv占的高加上滚动的距离。就是到底了


如果在滚动的途中，动态的往内部添加控件的话，滚动位置是不会变的。比如滚动了100px，如果在顶部添加了一个控件，那么现在滚动的距离，还是100px。



按钮程序控制滚动距离
scrollTo（x,y）     滚动到指定位置
scrollBy(x,y)       滚动到现有位置的各加x,y的地址上





*********************************************************************
Gallery的使用
也是数据源  适配器  加载适配器

数据源把drawable里面的图片，弄成一个数组

适配器是baseAdapter类型的
新建一个类继承BaseAdapter
创建一个构造方法，接收数据源和context上下文

此类有四个方法：
1，getCount    返回数据源的长度
2.getItem      返回指定位置上的数据
3，getItemid   返回指定位置上的id。*直接返回参数就行
4.getView      返回指定位置上的view对象
    新建一个ImageView对象，设置对象的背景.setBackgroundResource
    .setLayoutParams(new Gallery.layoutParams(x,y))   设置在Gallery上的大小
    .setScaleType(ScaleType.FIT_XY)   设置缩放模式，按宽高缩放
    返回这个ImageView



监听器：
new OnItemSelectedListener（）




***************************************************8
ImageSwitcher
可以设置图片的切换动画
监听器   setFactory（new ViewFactory（））  生成一个ImageView返回






**********************************************************************
SeekBar
比progressbar多了个圆点，用户可以自己按住圆点拖拉
progresss  只能用程序方法去改变进度值
seekbar  可以用户自己滑动去改变进度值


监听器：
OnSeekBarChangeListener       有三个方法
一个是监听滑动中   一个是滑动结束
一个是监听滑动改变的数值



***********************************************************88
布局优化
重复的布局可以用
include标签 来直接链接使用
layout=@layout/XXX


merge相当于framelayout


Viewstub引入的内容不会显示的
需要在程序中手动开启

使用方法：
在XML页面，就像正常使用一个控件一个
<ViewStud  android:layout=@layout/test  />
使用android：layout属性加载一个布局。
android：inflateId="@+id/XXX" 		给引用的布局指定一个id
还可以设置各种正常的属性。

这个加载的布局，在程序初始化的时候，是不会加载在布局树上的。所以如果不需要一开始就显示的话，用这个控件是比较节省时间的。

需要显示的时候，显示的方法：
在代码中也需要，创建实例化对象：
ViewStud mViewStud = (ViewStud)findViewById(R.id.XX)

1、mViewStud.setVisibility(View.VISIBLE)
2、View view = mViewStud.inflate();

两种方法都可以使用，第二种可以返回一个加载出来的布局。
一旦，引用布局显示后，ViewStub就消失了。ViewStub的XML的ID也就消失了，如果在再使用findviewbyid就会为空的。




*****************************************
添加断点
双击行号
右击选择切换短点
c+s+b


*****************************************************8
Toast：
toast文本可以用R.string.xx   
时长可以自己设置  以毫秒为单位
toast对象.setDuration()       设置显示时间
toast对象.setGravity(Gravity.CENTER,X,Y)      设置显示位置
第一个参数选择Gravity的静态参数，选择所在位置上下左右
XY是当前位置XY轴的偏移量。

toast对象.setText()           设置内容

toast对象.getView()           会生成一个View对象
新建一个LinearLayout对象，把getView强转成LinearLayout
然后新建一个ImageView，添加上图片，
LinearLayout对象的.addView(ImageView，0)  0是位置
最后LinearLayout对象.show()  
就是一个显示图片的toast了


自定义Toast
新建一个布局文件
LayoutInflater a=LayoutInflater.from(this)
a.inflate(R.layout布局地址，null)
新建一个Toast对象
Toast对象.setView(a)   就可以了








**************************************************
对话框
new AlertDialog.Builder(this)    创建一个Builder来设置各种参数

.setTitle()                      设置标题
.setIcon()                       设置图标
.setMessage()                    设置信息
.setPositiveButton()             设置一个确定按钮
.setNegativeButton()             设置一个取消按钮
   *监听器new DialogInterface.OnClickListener（）
   *这两个监听器点击后就会关闭对话框
.setNeutralButton()              设置普通按钮
AlertDailog dailog=Builder对象.create（）   创建一个对话框

dialog.setCanceledOnTouchOutside(false)		点空白处是否消失
dialog.setCancelable(false)		点空白处或者后退键是否消失
dailog.setOnDismissListener（监听器）	设置对话框关闭时的监听器


dialog.isShowing()	返回是否是在显示的布尔值
dialog.dimiss()	关闭对话框


单选对话框
不能设置内容，必须设置标题。
.setSingleChoiceItems(数据源，默认选择的位置，监听器)
   *监听器中第二个参数就是选择的位置


多选对话框
.setMultiChoiceItems(数据源，可以选择多少，监听器)
   *监听器new DialogInterface.OnMultiChoiceClickListener()

.dismiss（） 关闭对话框


列表对话框
.setItems(数据源，监听器)  和单选几乎一样
数据源，是字符串的数组或者集合
监听器 new DialogInterface.onClickListener(){}方法内第二个参数，是选择的列表位置。是从0开始的。


自定义对话框
新建一个XML布局。
LayoutInflater.from(this)    生成一个LayoutInflater容器
然后用这个容器的.inflate(布局文件，null)   把一个布局生成一个view控件
如果想设置布局内的控件监听器，在生成一个view后，就立刻设置。初始化时候，find前加view对象名称。

最后用Builder.setView(view)     设置自定义布局


自定义layout布局，然后生成View，关于这个布局的宽高：
理论上有个隐藏的父布局，宽度是屏幕的大概80%，自己设置多少都没用的。
高度就是自适应包括内容的。真正的高度，是由最底层的view类控件的高度来确定的。





自定义Dialog的样式style
<style name="自定义名称" parent=“android:style/Theme.Dialog”>
parent是父类是Dialog，或者说是继承是Dialog
item名称就是要设置是属性名：

<item name = "android:windowBackground"> @android:color/transparent </item>
  设置背景颜色    
  @android:color/transparent  这个是系统自定义的颜色，#00000000全透明的。透明的也就是没有背景了。。
  如果不设置这一项，会有一个黑色的半透明背景，而且有阴影效果。


<item name = "android:windowNoTitle"> true </item>
  不要标题栏吗     true是的

<item name = "android:windowFrame"> @null </item>
  边框样式	@null就是空，也就是不要边框

<item name = "android:backgroundDimEnabled"> false </item> 
  弹出时，是否需要后面的页面变暗 	不需要
一般来说，用上面这四个就可以搞定了。





<item name = "android:windowIsFloating"> true </item>
  activity是否是活动的		true是的

<item name ="android:windowIsTranslucent"> true </item>
  背景是否需要半透明		是的


然后使用新的方式，使用Dialog
Dialog dialog = new Dialog(上下文对象，主题样式)
dialog.setContentView(view);
添加一个自己定义的布局View。用layoutInflater生成View
  **这个时候，对话框的宽高，都是取决于内部控件的宽高了，最外层的父布局设置的宽高是没用的。
    在添加view布局的时候，还可以添加个宽高的。用LayoutParams对象设置宽高。
dialog.setContentView(view，LayoutParams对象);
    然后最终显示的时候，就以这个宽高为准，布局内部怎么样设置都没用。




自定义Diolog，新建类继承之Dialog。
修改Dialog布局的宽高为全屏大小。
Window window = getWindow();
window.setGravity(Gravity.TOP); 
WindowManager.LayoutParams lp = window.getAttributes();
lp.width = context.getResources().getDisplayMetrics().widthPixels;
lp.height = context.getResources().getDisplayMetrics().heightPixels;
window.setAttributes(lp);

这样设置的话，点击空白处消失那个属性就会失效了。因为那个属性应该是说点击布局外的地方，就关闭对话框，但是这样设置宽高后，相当于没有布局外了。可以给自定义布局的父布局设置个点击事件，点击后关闭对话框。


设置进入退出动画：
window.setWindowAnimations(R.string.ani)
在style文件夹，新建一个动画style。
<style name="right_to_left_style" parent="android:Animation">
        <item name="@android:windowEnterAnimation">@anim/in_rightleft</item>
        <item name="@android:windowExitAnimation">@anim/out_leftright</item>
</style>





DialogFragment的使用：
新建一个类，继承之DialogFragment，可以重写两个方法中的一个：
onCreateView，和Fragment一样，使用XML文件，生成一个view，然后return这个view
onCreateDialog，使用AlertDialog创建一个dialog，然后return这个dialog对象

使用的时候，创建实例化这个类的对象。
然后使用show(getFragmentManager(), "EditNameDialog")方法，就显示出来了





**********************************************************************
Notification  通知栏

显示通知
新建一个NotificationManager  通知栏管理员对象 
初始化=(Notification)getSystemService(Content.NOTIFICATION_SERVICE)  

最后管理员对象.notify(id.Notification对象)


取消通知
管理员对象.cancel(id)



先创建一个Notification的Builder 来设置参数
Builder builder=new Notification.Builder(this)

.setSmallIcon(图标地址)                 设置图标
.setTicker(字符串)                      设置手机状态栏提示
.setWhen(System.currentTimeMillis)      设置时间
.setContentTitle(标题内容)              设置通知栏标题
.setContentText(通知栏内容)             设置通知栏内容
.setContentIntent(pendingintent)        设置点击相应时间
  *设置一个PendingIntent pin=PendingIntent.getActivity(this,0,intent,0) 
   *需要一个普通Intent，指定跳转到主页class就可以了。

.setDefaults(Notification.DEFAULT_SOUND) 设置提醒方式
                                 *LIGHTS 指示灯
                                 *VIBRATE 震动效果
                                 *ALL    三个提醒都有
   **FLASHLIGHT       指示灯权限
   **VIBRATE          震动权限

设置完毕，把Builder生成Notification
builder.build()    就生成一个Notification的对象  *4.1以上用这个生成
4.1以下要用builder.getNotification() 






也可以不用builder来生成对象，可以自定义布局来生成对象显示。
Notification notifi = new Notification();

设置生成通知时，状态栏滚动显示的信息：图标和提示文本
notifi.icon = R.drawable.XXXX
notifi.tickerText = "正在下载"

设置点击后跳转的页面：
notifi.contentInten = PendingIntent对象。和上面的一样生成方式

设置布局：
notifi.contentView = RemoteViews对象
RemoteViews contentView = new RemoteViews(getPackageName(),R.layout.xxx);
第一个参数是包名，后面是布局地址

布局高度大概是65dp左右。
更新












**************************************************************
菜单OptionsMenu

在Activity中重写OnCreateOptionsMenu方法
getMenuInflater().inflate(R.menu.main,menu)
return true;

菜单监听器
重新方法onOptionsItemSelected


动态加载菜单的方式：
在onCreateOptionsMenu方法中
直接用menu.add(组名，id名，排序，Title菜单名)
就可以手动添加一个菜单了

.setItent(intent)        可以加载一个Itent意图。跳转到指定位置



onPrepareOptionsMenu()   在程序创建的时候，会调用一次onCreateOptionsMenu和onPrepareOptionsMenu一次。
然后每次点菜单键的时候，就会重新调用一次。

所以可以在这里对菜单做一些动态的改变。一开始可以做一些进入判定设定，防止程序一开始就调用了。

invalidateOptionsMenu（）刷新菜单，然后会自动调用onPrepareOptionsMenu（）





********************************************************************
上下文菜单ContextMenu

使用的时候，先创建一个声明
this.registerForContentMenu(要使用菜单的控件名称)

然后重写方法onCreateContextMenu
menu.setHeaderTitle()                设置标题
menu.setHeaderIcon()                 设置图标
menu.add(组名，id名，排序权重，选项名称)

监听器
重新方法onContextItemSelected


XML加载菜单方式，
先在menu中创建xml
在onCreateContextMenu方法中
getMenuInflater（）  生成一个Menuflater菜单容器
然后菜单容器.inflate(菜单布局XML，menu)    把菜单布局XML变成一个view控件





************************************************************************
subMenu子菜单

动态加载
重写方法onCreateOptionsMenu()
menu.addSubMenu("文件")             添加一个有子菜单的选项  *再生成一个对象
子菜单对象.setHeaderTitle()         添加标题
子菜单对象.setHeaderIcon()          添加图标
子菜单对象.add(组名，id名，排序权重，“选项名称”)

监听器还是onOptionsItemSelected（）   还是直接重写

如果不是子菜单不是屏幕中间显示的
修改下程序样式就可以了，选择不显示标题栏的
@android:style/Theme.Light.NoTitleBar



静态加载 在XML中建立菜单
在menu下新建XML，写一个itme标签
在item标签里面再写一个menu标签，menu标签下再写item就是子菜单了
getMenuInflater（）  生成一个Menuflater菜单容器
然后菜单容器.inflate(菜单布局XML，menu)    把菜单布局XML变成一个view控件







********************************************************************
动画

创建一个实例化一个Animation对象:
AnimationUtils.loadAnimation(上下文，R.anim.XX)

控件使用动画效果的方法：
控件对象.startAnimation(动画对象)


<alpha>                        透明度
fromAlpha                动画开始时候的透明度  *1-0
toAlpha                  到结束的透明度   



<translate>              移动动画
fromXDelta               当前位置X轴的加值     *填多少就是当前位置加多少
fromYDelta               当前位置Y轴的加值
toXDelta                 到达位置X轴的加值     *填多少就是当前位置的加上多少
toYDelta                 到达位置Y轴的加值



<scale>                  形变动画
fromXScale               X轴缩放的大小       *1-0   放大是1以上
fromYScale               Y轴缩放的大小
toXScale		 最终X轴的大小
toYScale		 最终Y轴的大小
pivoX			 以X轴的什么位置做缩放中心点  *可也是用百分比例 10%
pivoY			 以Y轴的什么位置做缩放中心点


<rotate>                 旋转动画
fromDegress              初始角度
toDegress		 最终角度
pivoX                    以X轴的什么位置做中心点   *可也是用百分比例 10%
pivoY                    以Y轴的什么位置做中心点
  **旋转动画，如果只设置x轴，就是上下翻转，如果是y轴，就是左右翻转的

****共有的属性:
fillAfter                是否保留动画后的状态
duration                 持续时间    *毫秒
startOffset              多少毫米后执行动画
repeatCount              循环多少次   *-1就是无限次



<set>                     内部可以添加这四个标签
*是同时进行的


************************************

interpolator             加速器
           *@android：anim/bounce_interpolator      回弹效果
	   *		   decelerate_              逐渐减速
           *		   accelerate_              逐渐加速
           *               accelerate_decelerate_   先加速在减速
           * 		   cycle_                   循环

AccelerateDecelerateInterpolator   
  在动画开始与结束的地方速率改变比较慢，在中间的时候加速
AccelerateInterpolator           *构造方法还可以接收个速率值。          
  在动画开始的地方速率改变比较慢，然后开始加速
AnticipateInterpolator                      
  开始的时候向后然后向前甩
AnticipateOvershootInterpolator     
  开始的时候向后然后向前甩一定值后返回最后的值
BounceInterpolator                          
  动画结束的时候弹起
CycleInterpolator                             
  动画循环播放特定的次数，速率改变沿着正弦曲线
DecelerateInterpolator                    
  在动画开始的地方快然后慢
LinearInterpolator                            
  以常量速率改变
OvershootInterpolator                      
  向前甩一定值后再回到原来位置

   **动态设置加速器的时候，需要新建实例化一个加速器对象。
    BounceInterpolator inter = new BounceInterpolator();
    .setInterpolator(inter)  这样设置加速器




*****************************



动态添加动画
在Activity中代码添加动画
new AlphaAnimation（初始值，最终值）   就得到一个Alpha渐变动画对象
对象.setDuration                       设置持续时间
对象.setInterprolator(上下文，android.R.anim.XXX)   设置加速器


newTranslateAnimation（初始X值，最终X值，初始Y值，最终Y值）
*这几个值都是单精度的，如果有小数点的要加f

newScaleAnimation（初始X缩放值，最终X缩放值，初始Y缩放值，最终Y缩放值，ScaleAnimation.RELATIVE_TO_SELF,X轴比例位置，ScaleAnimation.RELATIVE_TO_SELF,Y轴比例位置）
  **如果直接选用XY轴位置参数的那个构造方法，那XY轴的值是整个屏幕的XY轴像素值
    ScaleAnimation.RELATIVE_TO_SELF是相对自身的。后面XY轴值就是指自身的XY轴比    例了。是0-1之间的单精度值。


newRotateAnimation（初始角度，最终角度，
ScaleAnimation.RELATIVE_TO_SELF,以X轴的什么位置为中心，ScaleAnimation.RELATIVE_TO_SELF,以Y轴的什么位置为中心）


   **动态设置加速器的时候，需要新建实例化一个加速器对象。
    BounceInterpolator inter = new BounceInterpolator();
    .setInterpolator(inter)  这样设置加速器的





newAnimationSet（false）     新建一个set动画集   *参数是否共享加速器
set动画对象.addAnimation(别的动画对象)    就是添加一个动画对象进去了


animation.setFillAfter(true)和控件的visibility是会冲突的。
如果设置了，保留动画后的状态；然后再设置控件动画后隐藏，就会冲突了。实际是会保留状态的，visibility设置无效。

如果一个控件设置了INVISIBLE隐藏，但是设置了动画，一样是可以的。动画的时候会把控件给显示出来的。动画结束的时候，还会变成隐藏状态的。
gone就不行了


set动画集和子动画，之间的属性设置优先级问题。
如果是动画持续时间，如果set动画集没有设置时间，就以子动画设置的时间运行。
如果set动画集设置了时间，那么子动画设置的时间就是无效的了。都以设置的时间为准
如果是是否保留动画后状态，子动画的设置是无效的，一切以集合的设置为准，如果集合没设置，就用默认值不保留。


关于添加动画的顺序，
如果有移动动画和旋转动画，要先添加旋转动画，然后再添加移动动画




动画监听器
.setAnimationListener(new AnimationListener())
三个方法，一个开始，一个循环，一个结束






*******************************************
ValueAnimator数值产生器：
简单来说，就是给定一个开始值和结束值，再给定一个时间，这个类就会计算在这个时间内数值的变化

生成对象：
ValueAnimator value = ValueAnimator.ofInt(0,100)
返回一个生成0-100之间数值的动画对象。
还可以使用ofFloat(0f,100f),生成的数值就是有小数点的。
后面参数是可变长数组的，也就是可以使用任意个数值的，
比如：
ValueAnimator value = ValueAnimator.ofInt(0,800，200,500,100)
会自动计算从前一个数字到后一个数值的变化的





value.setDuration（1000）；
  **可以设置持续时间，会在指定时间内生成数值。
value.setInterpolator(new 加速器)
  **可以设置个加速器，以加速器的速度生成数值。
    不设置，默认是AccelerateDecelerateInterpolator，两头慢，中间快。

setStartDelay()方法    	设置延迟时间
setRepeatCount()	设置循环次数  ValueAnimator.INFINITE 无限循环
setRepeatMode()		设置循环模式
  RESTART和REVERSE两种，分别表示重新播放和倒序播放的意思
cancel（）		取消动画

value.start(); 开始运行


value.addUpdateListener(new AnimatorUpdateListener(){})
  **添加数值更新监听器
接口中有个方法，会传递一个对象，用对象的getAnimaorValue，获取当前产生的值
value.getAnimatedValue();会返回一个Object对象，所以要用数值的包装类来接收
Integer intValue = value.getAnimatedValue();
然后就可以利用这些数值做各种操作了。

addListener(new AnimatorListener())
添加动画状态监听器，有四个方法 
    void onAnimationStart(Animator animation);  	开始
    void onAnimationEnd(Animator animation);  		结束
    void onAnimationCancel(Animator animation);  	取消
    void onAnimationRepeat(Animator animation);  	重复


removeUpdateListener(AnimatorUpdateListener listener)
removeAllUpdateListener()
取消指定的监听、取消全部的监听
取消状态监听，也是一样的方法





ValueAnimator的大致实现原理。
当前数值 = 总长度 * （进度值 * 差值器）

加速器就是算出（进度值 * 差值器）的加速值，其中进度值是系统给出的匀速的。各个加速器的速度不同，就在于差值器的算法上。


加速器都是继承之TimeInterpolator接口的。
此接口有一个方法：
float getInterpolation(float input);  

input就是传入的当前进度值，从0到1的。比如0.2324.
返回值就是经过计算的加速值
像线性加速器就是直接返回的进度值，也就是匀速的。别的加速器就是经过处理的，就不是匀速的了。


自定义加速器：
新建类继承之TimeInterpolator接口
getInterpolation在返回值那，根据传入的进度值，做相应的差值处理。




*************************

Evalutor的使用：(一般来说，用于ofObject，传入两个类，自己手动写类的值的变化)
Evalutor就是具体计算当前过渡值的一个类。
利用加速器计算返回的加速值，和开始值结束值，来计算得出当前值
当前数值 = 总长度 * （进度值 * 差值器）
比如ofInt和ofFloat的，系统都有自带的Evalutor的。

自定义Evalutor
新建类实现TypeEvaluator<自己定义的泛型>，实现以下方法
public Integer evaluate(float fraction, Integer startValue, Integer endValue) ，
根据传入的加速值，和开始值结束值；自己操作最后返回当前数值


如果泛型定义成一个类，那么传入的开始和结束值，返回值都会是这个类的对象。
具体使用：
ValueAnimator的getAnimatorValue（）返回值也要强制成这个类对象。
ObjectAnimator和PropertyValueHolder的查找set属性方法时，查找的是set属性传参是这个类对象的方法。也就是写set方法的时候，接收值必须要是这个类对象。


使用方法：
valuerAnimator.setEvalutor(new MyEvalutor())
这个数值产生器，就会使用自定义的Evalutor来产生数值了。

还有个系统定义的，ArgbEvaluator可以直接使用，会计算过渡颜色值的。


*****************


ValueAnimator.ofObject（）的用法：
可以产生对象之间过渡的数值

ValueAnimator value = ValueAnimator.ofObject(TypeEvaluator,对象a，对象b)
简单来说就是传入两个对象，传入一个自定义的数值计算器。
在Evalutor类中，会传入加速值，开始对象和结束对象，然后自己写计算方法，最后返回计算数值。
value.getAnimatorValue（）方法就会返回计算的当前值了。







*****************************************************
属性动画ObjectAnimator：
算是ValueAnimator的变种吧，ValueAnimator只能根据设置的参数，来产生数值，然后要自己在监听方法中根据数值做操作，不太方便。使用ObjectAnimator就可以直接传入控件和属性，就会自动执行了，不用自己操作了。

使用ObjectAnimator的静态方法ofFloat或者ofInt，生成一个ObjectAnimator对象:
ObjectAnimator anima = ObjectAnimator.ofFloat(控件对象，"属性名称"，value...)

大概执行原理
会自动调用传入对象的，set属性名方法，然后传入产生的数值。比如传入“name”，那么对象就要有setName（）方法。
一般控件View都有下面这几个set属性方法，所以可以直接传入这几个属性名。
set方法，传入参数如果是float，那么新建对象的时候，就要使用ofFloat。这个类型一定要对应。


//1、透明度：alpha  
public void setAlpha(float alpha)  
  
//2、旋转度数：rotation、rotationX、rotationY  
public void setRotation(float rotation)  
public void setRotationX(float rotationX)  
public void setRotationY(float rotationY)  
  
//3、平移：translationX、translationY  
public void setTranslationX(float translationX)   
public void setTranslationY(float translationY)  
  
//4、缩放：scaleX、scaleY  
public void setScaleX(float scaleX)  
public void setScaleY(float scaleY)  


value是可变长数值，可以写多个数值。
value值，指的都是控件当前位置的加值，100,800，就是从当前位置+100，到当前位置+800那里。
而且执行后，控件的点击区域移动过去了，但是实际的位置还是没有变的。
比如执行一次100,800.再执行一次100,800，那么是不会从800那里开始的。




这个类，就是简单的，找到对象的属性名set方法，然后把产生数值传入到set方法中，就结束了，没有别的绘制什么的操作。
(产生的数值方法内部还是用的ValueAnimator的方法)
系统那四个能有动画执行方法，是因为这几个set方法，内部有重绘方法的。

自定义的话，关键就在于写个set属性名方法，然后在set方法内根据传入的数值做操作后，重绘




如果ObjectAnimator.ofInt(mPointView, "pointRadius",100);  
只输入一个数值的话，这个类会自动找getPoinRadius（）方法，获取值当做初始值，100为最终值。
如果找不到的话，会默认用0当做初始值



设置属性：
时长，循环、开始、取消。监听，监视器。Evalutor，都和ValueAnimator一样的









**********************
ObjectAnimator的ofPropertyValuesHolder方法：

PropertyValuesHolder多个效果同时进行:
用PropertyValuesHolder的静态方法ofFloat，生成一个对象
PropertyValuesHolder value1 = PropertyValuesHolder.ofFloat("属性名"，值...)

相当于是给一个控件设置多个属性，不用每次都设置控件对象，时长什么的了。
现在每次设置一个属性，最后用ObjectAnimator的ofPropertyValuesHolder方法还是生成一个ObjectAnimator对象
ObjectAnimator anima = ObjectAnimator.ofPropertyValuesHolder(控件对象，holder对象....)

然后再设置时长，加速器什么的。最后执行

ofObject也是差不多的用法，和ValueAnimator一样，构造的时候需要自定义的Evalutor








*******************
PropertyValuesHolder.ofKeyframe方法：

Keyframe的使用：
类似加速器吧，又能和加速器共存。
如果要用加速器定义自己想要的速率，需要很复杂的数学函数，太麻烦了。
用Keyframe可以定义简单的多段不同速率。

Keyframe frame0 = Keyframe.ofFloat(0f, 0);  
Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);
第一个参数是进度值，第二个是具体数值。
就是说要在指定的进度值那，走到指定的数值那。上面那个就是进度值10%的时候，就从0走到-20.
当然下面还可以添加进度值，这样就会产生多段不同的速率了。
简单的说，就是控制多段，指定进度值内执行的距离。

最后使用：
PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe(属性名，Keyframe对象...)
再使用ObjectAnimator生成动画对象。设置时长什么的，运行。

frame0.setInterpolator(new BounceInterpolator());  
还可以设置加速器。相当于在这一段内的速度用加速器的速率走。默认是用线性加速器的，也就是匀速的。

Keyframe.ofObject();
用obj的话，肯定就是要用自定义的Evalutor来产生数值的。
这个是要在PropertyValuesHolder对象那设置的。









*************************************

还可以使用AnimatorSet对象，来操作多个属性动画或者ValueAnimator：
AnimatorSet animSet = new AnimatorSet()

同时进行的方法：
用playTogether方法，加载多个属性动画进来就行了。  
animSet.playTogether(animator1，animator2.....)
animSet.setDuration(1000)	animaSet.start()就运行了
如果不设置时长，就以各个属性动画自己设置的为准，或者各个没有设置时长，那就以这个为准。
如果时长和单个属性动画时长冲突，那么还是以animSet的为准
设定时长是设定个属性动画的运行时长的，不包含延迟运行的时间的。



按照顺序执行的方法：
animSet.Sequentially（animator1，animator2.....）
一个属性动画的开始，是从延时计算的。延时、动画运行，结束后，才会执行下一个动画。如果有循环，第一次动画结束，就算结束了。





还可以精准控制多个
animSet.play(anim1).with(anim2)      1和2同时进行
animSet.play(anim1).after(anim2)     1在2之后进行   before在之前进行

after(Animator anim)   	将该动画插入到上一个动画之前执行
after(long delay)   	将现有动画延迟指定毫秒后执行
before(Animator anim)   上一个动画执行后，再执行该动画。
with(Animator anim)   	将该动画和上一个同时执行

监听器：
animator.addListener(new AnimationListener(){})
有四个方法 开始 结束 取消  循环

也可以添加一个动画监听器适配器，只重写需要的监听器方法
new AnimationListenerAdapter（）{}



更便捷的ViewPropertyAnimator：
textview.animate().x(500).y(500).setDuration(5000)  
        .setInterpolator(new BounceInterpolator());  
这样就直接形成一个动画了，可以各种连缀的使用。







*************************************************************************
帧动画
在drawable中新建XML
选择animation-list标签
animation-list自身属性 oneshot               是否只循环一次

内部再加item标签
android：drawable=“@drawable/图片名称”
android：duration                            设置显示时长


给ImageView控件，设置背景资源.setBackgoundResource(xml地址)
新建一个AnimationDrawable变量
赋值=imgage对象.getBackground()  强制转换

AnimationDrawable对象.start() 运行动画，.stop()停止动画
**动画必须有停止动作，才能再次播放




动态加载的方式：
先创建一个AnimationDrawable对象=new AnimationDrawable（）
对象.addFrame(getResource().getDrawable(R.drawable.XX)，显示时长)
添加一个图片资源为一个页面

.setOneshot()         是否只循环一次




【有过渡的切换动画】：
在drawable文件中，新建xml文件，
标签要自己写：
<transition 
    xmlns:android="http://schemas.android.com/apk/res/android">
   <item android:drawable="@drawable/a13"/>
   <item android:drawable="@drawable/a1"/>
</transition>
【只能设置两项。】

然后给控件，设置图片，选择这个xml文件，@drawable/XX

在程序中：
TransitionDrawable drawable = (TransitionDrawable)img.getDrawable()
drawable.startAnimationTransition(200)
开始动画，设置动画持续时间，从第一项，到最后一项

drawable.reverseTransition(200)
反向开始动画，从最后一项到第一项。



【有层次的切换动画】
在drawable文件中，新建xml文件，标签：
<level-list 
    xmlns:android="http://schemas.android.com/apk/res/android">
   <item android:drawable="@drawable/a13"
         android：minLevel="1"
         android：maxLevel="10"/>
   <item android:drawable="@drawable/a1"
         android：minLevel="11"
         android：maxLevel="20"/>
</level-list>
可以只设置maxLevel。

在程序中，可以控制显示哪一张
img.setImageLevel(8)
设置的是哪个区间内的，就显示哪一张。
【只能当做src使用，不能当做background使用】



【设置有边距的图片，可以当背景图】
在drawable文件夹中，写标签
<inset 
android:drawable="@drawable/XX
android:insetLeft="50dp"
.....其他方向>



【剪切】：
在drawable文件夹中，写标签：
<clip
android:drawable="@drawable/XX"
android:gravity="left"
android:clipOrientation="horizontal"
/>
设置剪切方向，为垂直的

在程序中写：
ClipDrawable drawable = (ClipDrawable)img.getDrawable()
drawable.setLevl(5000)
设置剪切多少，最大值是10000,设置5000就是剪切50%





******************************************************************8
SharedPreferences

创建对象的方式：
PreferenceManager.getDefaultSharedPreferences(上下文)
或者
上下文.getSharedPreferences（“文件名”，“读写权限mode”）
mode类型有，MODE_MULTI_PROCESS	可以多线程使用的
MODE_PRIVATE		私有的

对象.edit()                      生成一个edit编辑器对象

edit对象.putXxx（key，value）    写入各种类型的键值对
edit.commit()                    提交数据
edit.remove()                    删除
**没错操作后都需要conmit提交才能有效

读取
直接shared对象.getXxx(key,默认值)


getSharePreferences并不会生成这个文件，只是会返回这个文件的对象。
只有用edit写入数据的时候，才会生成这个文件。


【Shared的一般使用方法：第一次先直接提取值，设定一个默认值。
然后判定值是不是默认值，如果是默认值，也就是空的了，没存过数据的。
那么就判定为第一次使用什么的。然后就做些第一次使用的操作或者存数据进去，供下次判定。
反之，判断值不是默认值的话，就说明提取到之前存的东西了，
那么就判定不是第一次使用了。就做处理数据或者什么的。】











*******************************************************************8
SQLite
支持的数据类型：
NULL     INTEGER    REAL      TEXT     BLOB
空值     整型       浮点型    字符串   二进制
可以把各种类型的数据保存到任何字段中，而不用关心字段声明的数据类型是什么
定义为INTEGER PRIMARY KEY的字段只能存储64位整数， 当向这种字段保存除整数以外的数据时，将会产生错误


SQLiteOpenHelper
先创建一个类继承SQLiteOpenHelper类
需要重写构造方法和两个方法

构造方法有四个参数，第一个是上下文，第二个是数据库名称，第三个是查询游标，第四个版本号
版本号只能用int的，1、2、3、这样的，必须大于0的


onCreate方法，一般在这里写个建表操作。
onUpgrade方法，更升级数据库用的

调用的时候，先实例化一个对象：
SQLiteOpenHelper database = new Sql。。。。
  **这就是完成了创建一个数据库的操作。

然后调用其中两个方法，就可以获得这个数据库的对象了。
SQLiteDatabase sql = database.getReadableDatabase()       获取一个只读的对象
SQLiteDatabase sql = database.getWritableDatabase()       返回可读可写对象
	调用这两个方法的时候，会检测，是否存在数据库，如没有存在，就会创建数据库，并且调用onCreate方法。onCreate只会在数据库不存在的时候调用，也就是只会调用一次的。

并且会检测自身这个对象的，版本号是否比之前数据库的版本号高，如果高就需要升级，就会调用onUpgrade方法。



检测表是否存在，插入语句，如果返回-1，不崩溃，就有可能是表不存在，或者字段不存在。


如果后期需要新增表的话，在onCreate方法中，新建所有的表，来应对第一次安装的情况。然后在onUpgrade方法中，来判断老的版本号，来做升级策略，把新增的表的创建语句放在其中。

如果后期要新增表字段或者删除的话，可以先把当前表重命名，然后新建一个表，然后复制表数据到新建表中。








生成一个数据库对象  *如果没有就创建并打开，如果有就打开
SQLiteDatabase db = 
openOrCreateDatabase(文件名，读写权限，null)
                             *MODE_APPEND          追加型
                             *MODE_PRIVATE         私有型
                             *MODE_WORLD_RADABLE   只读
                             *MODE_WORLD_WRITEABLE 读写
db.execSQL()                 执行一条SQL语句

create table if not exists Book (_id integer primary key autoincrement,author text,price real,pages integer,name text)
**创建一个表，假如不存在就创建
  primary key  设置为主键   autoincrement表示自增长的
  _id也是唯一的，不会说删除后，又重新把id分配给某一条了。
  text not null		就是把这个属性设置成不能为NULL的了
  也就是写入每一条数据的时候，都必须把这个表属性的值给写上。


SQL插入语句：
insert into userName(webName,name,password)values('京东1','a443465334','123456')
**在userName表中插入一条数据，（）内写上不能为空的属性名，values内容（）内对应写入要添加的内容，字符内容要用单引号。



execSQL可以执行insert、delete、update和create table语句
rawQuery只可以执行select查询语句。


db.rawQuery(sql语句，查询条件没有就为null)
会返回生成一个Cursor游标对象。
游标对象的方法
.getCount()		总记录条数
.getFirst()		是否是第一条
.getLast()		是否是最后一条
.moveToFirst()		移动到第一条
.moveToLast()		移动到最后一条
.moveToNext()		移动到下一条
.moveToPrevious()	移动到上一条
.move()			移动这一条
.moveToPosition(1)	移动到指定行


**获得当前这一行的这个索引的值
.getColunmnIndex(列名)      获取指定列名的索引值(也就是列号，第一个字段索引值就是0)
.getString(列索引)  	    获得当前行的，索引值的String值（也就是获取第几个字段的值）
getLong各种类型，内部都是强转的。从表中查出数据，应该都是Object类型的，然后要get什么类型，最后就转换成什么类型。


.getColunmnName(5)	    获取指定列的列名
.getColumnNames()           把所有列名返回成一个String数组。
.getColumnIndexOrThrow(列名) 如果不存在，就报错。
提取数据的流程：
使用cursor.getString(列索引)：
就是提取当前行上，指定列索引上的值。

提取列索引的方法，cursor.getColumnIndex(列名)
根据提供的列名，产生一个列索引。

提取列名的方法：
可以直接输入，或者cursor.getColoumnName(2)：提取指定列的列名。
或者cursor.getColunmnNames(),生成一个所有类名的String数组。

【获取到游标对象的时候，游标默认位置是不存在的，必须手动移到第一，或者moveToNext】

如果记录是0条，在操作游标移动第一条或者某一条，会返回flase。
如果再提取数据，就会报错了

interger型数据，如果是空值，提取出来的就是0.



自带函数操作数据库

插入操作
long insert = db.insert(表名，nullColumnHack，values（ContentValues）)     
会返回一个行数，如果插入失败比如没有对应的字段，返回的就是-1.

new ContentValues       生成一个ContentValues对象
类似一个hashmap
添加内容的方法：
.put(“password”，“123”)   key是表中属性名，value是内容

nullColumnHack：空列的默认值；

再写一行的时候，.clear() 就清空这个容器了

如果插入一条数据的时候，有些属性没有填写。那么属性值就是NULL。
如果是text类型的，提取的时候，赋值给String类型，会是null空的
如果是integer和real类型，提取出来后，赋值给会是0.

一次只能插入一条数据的。也就是ContentValues只能装一条数据的。


使用Sql语句插入：
String sql = "insert into userName(webName,name,password)values('京东1','a443465334','123456')"
database.execSQL(sql);

还可以这样：
String sql = "insert into userName(webName,name,password)values(?,?,?)"
database.execSQL(sql,new String[]{"1","2","3"} )
后面的数据会自动对应填充前面sql语句中缺少的值；

还可以：
SQLiteStatement mStatement = database.compileStatement(Sql);
mStatement.bindLong(1,121233)
......
mStatement.executeInsert()
可以使用bind方法为sql中？的参数赋值，是从1开始的。



插入数据，从另一个表读取数据：
"insert into Book select * Book2"
选择Book2中所有的数据，插入到Book中。两个表必须都有相当的字段

"insert into Book(name,price) select name,price Book2"
选择插入另一个表中的指定数据。

"insert into Book(name,price) select name,price Book2 where price > 15"
选择插入另一个表中，符合条件的指定字段数据。






更新操作
db.update(表名，values，条件，条件用的数据)
         *values，把values容器内写入要更新的内容
         *条件比如_id>?
         *条件数据，比如new String[]{"3"}
          

删除操作
database.delete("Book", "pages=?", new String[]{"1"})
db.delete(表名，条件，条件用的数据)
	 *比如条件 name like？
         *条件数据 new String[]{"%丰%"}
	 就是name里面有丰字的就给您删除了

这两个操作，其实还有个返回值的，返回值就是操作成功了几条

关于条件和条件数据：
如果确定了条件，可以不使用条件数据，条件可以使用= 、>、>=比如：
database.delete("Book", "pages=1", null)；
database.delete("Book", "pages>1", null)；

当然，也可以使用条件数据，写法：
database.delete("Book", "pages=?", new String[]{"1"})
关于条件数据类型，不管什么类型，都可以写到字符串数组中。

like的使用：
database.delete("Book", "pages like?", new String[]{"%xiao%"})
就是查找pages的属性值中，只要含有xiao这个字符，就满足条件了

关于条件数据的通配符:
_  可以代表一个字符的任意字符
比如：xiamin_   就可以匹配xiaoming

%  可以代表一个或多个字符的任意字符
比如：%ming	就可以匹配xiaoming
      %ao%	前后两个这样就可以匹配xiaoming

多条件可以使用and 和 or。后面的条件数据也要匹配上。



查询操作
db.query(表名，列数，条件，条件数据，null，null，按照什么属性排序)
也会返回生成一个游标对象      

列数可以使用 new String[]{"name","pages"}   查询只需要的列数。




select语法查询：
SELECT 列名称 FROM 表名称
select * from Book
*这里是需要的列名，如果是*就是全部，如果指定列名的话， select name，id这样就可以了，中间用逗号分开。
from后面是指表名。


条件查询：
SELECT 列名称 FROM 表名称 WHERE 列 运算符 值
select * from Book where money>1
需要注意：值、如果是文本值，需要用单引号，比如name=‘xiaoming’。如果是数字，就不需要用单引号了。

DISTINCT 在选列名称的时候，在selct和类名称中间加这个，就是有重复的，只要一个。是可以指定多个列名称的，也都是全部都一样的时候，才选取。



逻辑运算符：
多条件and和or，如果where后面，多个条件，可以使用and和or，比如
select * from Book where money>1 or name=‘xiaoming’

between and  用于查找最小值和最大值之间的，比如：
select sum(shouJia) Book where shouJia beteen 15 andr 17;
统计售价字段的和，条件：售价字段在15-17之间的。(这个是包括15和17的) 



order by 结果排序：
select * from Book order by money
对结果，根据money值，进行排序，默认是升序排列；
多条件排序：
select * from Book order by money, name
先根据第一个条件，进行排序，如果有相同的，就按照第二个条件排序
降序排序：
select * from Book order by money desc
列名后面加desc就是降序排序
多条件升序降序：
select * from Book order by money desc，name asc
这样就是先按照金额降序排，如果一样的话，就按照名称升序排序



函数：avg、count、sum、max、min、
select sum（money）from Book
返回的cursor，就只有一个列名：sum（money），值就是money列所有的值总和。
如果值为null，一样是算作0计算。

count(*)	返回总共有多少行数据



group by分组
比如统计的时候，想把某个属性的多个记录值统计出来，就可以使用group by 
select sum（money）from Book gruop by name
就是把同一个名字的书的价格，给统计出来。
PS:必须要在order by前面。也就是排序的函数要在后面。



alter table语句：
rename to	可以进行对表名重命名
alter table Book rename to Book1
这样就把Book表名改成Book1了。这个需要使用execSQL（）方法

add column	可以新增一个字段列名
alter table Book add column price
给Book表新增一个price字段














***************
事务：
相当于是把多个操作放在一起处理，先加入任务栈，最后一起处理。
如果中间有错误，就会把所有的操作回滚到未执行时的状态。
使用方法：
database.beginTransaction();在执行Sql操作前，开启事务

在最后结束的时候，先设置一个处理成功的flag
database.setTransactionSuccessful（）；

database.endTransaction()
end后，就会开始执行所有加入的事务








************************************************************
file类
android中SD卡的路径
/mnt/sdcard/             内置sd卡路径
/mnt/extsdcard/		 外置sd卡路径

database和share表格，在设置中点击清理数据，就会被清除了。
file类在本目录下的文件和外置内存卡的本程序目录文件，在app卸载后会被清除。

this.getFilesDir() 
**调用此方法后，会在当前程序的内部目录下，创建生产一个files文件夹。然后会返回这个files文件夹的对象。
  比如：/data/data/com.example.mediatest/files


this.getCacheDir()       
**返回生成当前程序的缓存文件夹对象

this.getDir(文件名，权限MODE_XXX)   
**会在当前目录下创建一个指定名称的文件夹，并返回其对象.如果有的话，就直接返回对象。
创建的时候好像在名称前会加个app_，比如
getDir("img",MODE_PRIVATE)	会生产这样的路径文件夹
/data/data/com.example.mediatest/app_img


this.getExternalCacheDir()    返回生成外置内存卡上的默认路径对象 

File dir = new File("/")	生成根目录的文件对象

openFileOutput（文件名）   获得一个默认目录下文件名的FileOutputSteam 输入流
openFileInput（文件名）   获得一个默认目录下文件名的FileInputSteam 输入流

读写内存卡的权限名称
WRITE_EXTERNAL_STORAGE



使用assets文件中的文件：
InputStream in = getResources().getAssets().open(“文件名”)  
  **getAssets()后，就可以文件夹的资源了。这个文件夹的使用方法，就不是R.XX.XX    了。是用open方法使用的。
    最后返回的是一个InputStream输入流


使用raw文件夹中的文件：
InputStream in = getResource().openRawResource(R.raw.XX)
  **得到Raw文件夹的对象，是用openRawResourcr()方法，然后用R.raw.XX就可以了
    一样返回的是一个输入流


关于SD卡的操作：
Environment.getExternalStorageDirectory()    会返回一个SD卡根目录的file对象

getDataDirectory() 			     获得SD卡的data目录

Environment的一些静态方法：

MEDIA_BAD_REMOVAL 	在没有挂载前存储媒体已经被移除。
MEDIA_CHECKING 		正在检查存储媒体。
MEDIA_MOUNTED 		存储媒体已经挂载，并且挂载点可读/写。
MEDIA_MOUNTED_READ_ONLY 存储媒体已经挂载，挂载点只读。
MEDIA_NOFS 		存储媒体是空白或是不支持的文件系统。
MEDIA_REMOVED 		存储媒体被移除。
MEDIA_SHARED 		存储媒体正在通过USB共享。
MEDIA_UNMOUNTABLE 	存储媒体无法挂载。
MEDIA_UNMOUNTED 	存储媒体没有挂载。



Environment.getExternalStorageState()		获取SD卡的状态
可以用.equals()和上面的静态方法做对比。获取是什么状态






**********************************************************************8
ContentProvider
数据接口，可以让别的程序通过这个接口来用自己的数据。


【ContentProvider的流程，我个人的理解，先创建一个类，继承ContentProvider，这个类就具备了数据库的基本操作了。自己生成数据的时候，可以使用类来保存处理数据，然后在AndroidMainfest中声明一个地址，然后这个类就可以被别的程序来共用操作处理了。
别的程序操作的时候，是要写明地址的，也就是uri。这个uri可以写的很清楚的，可以让别的程序，只访问到哪个表，甚至哪几条数据。】

providers.contacts         联系人content


自定义ContentProvider的方式：
新建一个类，继承抽象类ContentProvider，实现其方法
然后在AndroidMainfest.xml中完成注册
android：name为类名
android：authorities=“com.providers.名称”


ContentProvider抽象类的抽象方法：
onCreate            在创建的时候会被调用
delete              根据uri删除指定的记录
getType             返回当前uri的MIME的类型
                   *如果只有一条记录，MIME就是以vnd.android.dir开头
                   *如果有多条记录，就是以vnd.android.dir.cursor.item开头



uri通用资源标识符
content：//com.imooc.provider/music/#
第一段就是固定的，表面是个provider
第二段就是在AndroidMainfest中注册的autoorities名称
第三段是具体操作哪个条目
第四段是具体操作条目下的哪几条记录



uriMatcher类
新建一个对象
new UriMatcher（UriMatcher.NO_MATCH）    生成一个空的UriMatcher对象
UriMatcher对象.addURI("com.imooc.provider","music",1)
往这个对象里面添加一个uri
地址，条目  返回码code

matcher.match(uri)
如果匹配成功就返回code值，如果不成就是-1


*****************************


ContentResolver  用来操作Contentprovider
ContentResolver cr=getContentResolver（）生成一个对象
cr.query(uri,查询要的属性，条件，条件数据，排序属性)
  **联系人的URI：ContactsContract.Contacts.CONTENT_URI   *类似表名
  **通讯录的URI：Phone.COUTENT_URI

  Contacts._ID                  联系人id
  Contacts.DISPLAY_NAME         联系人姓名               *表里面属性名

  Phone.CONTACT_ID              手机号码ID
  Phone.NAMBER                  手机号码
  Phone.DISPLAY_NAME		联系人姓名

这个查询就和操作自己的数据库操作基本一样，就是把表名换成uri了




写入手机号的操作
RawConteacts.CONTENT_URI         写入联系人的uri地址

Uri uri = cr.insert(RawConteacts.CONTENT_URI,空values)
**向联系人表中写入一行数据
**返回一个这一行的uri

long parseId=ContentUris.parseId(uri)
**解析这个URI，只留最后一个标识，也就是行数了

这时候再忘values中写入数据
先是联系人的ID，也是刚才得到的行号
values.put(StructuredName.Raw_CONTACT_ID,parseId)
写入显示的姓名
values.put(StructuredName.DISPLAY_NAME,"李四")
写入MIMETYPE
values.put(StructuredName.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);

最后写入到
cr.insert（Data.COUNTENT_URI）




读取联系人和写入联系人权限
READ_CONTACTS
WRITE_CONTACTS





******************************************************************
BroadcastReceiver 广播接收

关于发送：

intent对象.putExtra（key，value）      给intent对象写入内容
intent对象.setAction()                 写入一个动作

context.sendBroadcast（intent对象）   发送一条普通广播

sendOrderedBroadcase（intent对象，权限null）   发送一条有序广播



关于接收：
新建一个类继承BroadcastReceiver，然后就实现一个onReceiver方法，方法会接收一个Contenxt对象，一个Intent对象

当系统广播发出去后，所有注册过的BroadcastReceiver类，就会检测自己IntentFiler滤波器里面的条件，是否和Intent中的动作一样，如果一样就会调用这个类的onReceiv方法。在方法里面，可以把intent的内容解析出来。也可以做别的操作，比如启动程序保存数据什么的。

String s=intent.getStringExtra(key)       就能提取里面的数据了
Bundle bundle =getResultExtra（true）     提取处理过的数据
bundle.getString(key)                     提取bundle里面的数据



普通广播和有序广播

普通广播，同级别接收是随机无序的
级别低的后收到广播
接收器不能截断广播
同级别动态注册高于静态注册

有序广播

就是可以截断广播或者处理广播




静态注册和动态注册

静态注册
<receiver  android:name="包名，类名">        注册这个类为一个广播接收者
至于接受什么，是要写过滤条件的，满足条件就接受了
<intent-filter></intent-filter>
滤波器内部可以写<action android:name=“XXX”>
              和<catagory android:name="XXX">  来过滤广播
滤波器设置优先级，<intent-filer  android:priority="1000">   -1000--1000



动态注册
在程序中注册
IntentFilter a=new IntentFilter(滤波器内容action android:name=的内容)
然后再新建一个广播接收器类的对象
registerReceiver（接收器类对象，过滤器对象）     就把这两个给绑定注册了




广播截断
在接收器类内部写abortBroadcast（）可以截断有序广播

广播处理
Bundle b=new Bundle（）；
b.putString(key,value)
setResultExtras(b)       就是处理广播内的数据再发出
广播处理相当于是又重新发了一条新的广播出去，后面的程序可以接到两条






*************************************************************************
Service

新建一个类继承Service
在AndroidMainfest中注册下，<Service android:name="类地址"/>

新建一个含有本页面和Service服务的Intent
Intent intent=new Intent（this，Service继承类.class）


运行一个Service
startService（包含服务的Intent）
这样就是启动Intent里面的服务了

停止Service
stopService（Intent）



Service的方法：
onStartCommand         在启动服务的时候，会执行这个方法


绑定Srevice启动
bindService（intent，服务连接器this，Context.BIND_AUTO_CREATE）
*如果用this，就要让Activity继承ServiceConnection借口，并且实现其两个方法
 onServiceConnercted            服务绑定的时候用
 onServiceDisconnected          服务销毁或崩溃的时候用

然后在Service类中，onBind方法中，return new Binder（）；


暂停BindService
unbindService（服务连接器this）



启动服务和绑定服务的区别：
启动服务，相当于是启动后，Service会默认执行那个任务，Activity和Service就没什么关系了。
而绑定服务，可以创建一个Binder继承类，然后创建多个方法，绑定后，return这个Binder继承类对象，然后在Acitivity那，就可以选择调用哪个方法了。
一旦绑定服务后，activity如果退出了，那么绑定的service会自动调用onUnbinder方法，和ondestroy方法。自动销毁。
一个service只能和一个avtivity绑定。





Service的生命周期

startService对应的生命周期：
onCreate（）                          onStartCommand（）
第一次启动或绑定时会启动onCreate      然后每次启动服务会启动onStartCommand

stopService对应的生命周期：
onDestroy（） 销毁


绑定服务
bindService对应的生命周期：
onCreate（）                        onBinde（）
如果之前已经启动过，则不会运行      每次绑定服务会启动

解除绑定服务
unbindservice（）对应的生命周期
onDestroy（）销毁



如果同时启动服务和绑定服务了，就要停止服务和解除绑定都运行后，才会真正销毁服务。

Service是运行在主线程中的，也不能做太耗时的操作的，如果太耗时的操作，可以再开一个子线程运行。



通知栏Service：
在onCreate（）方法中，使用startFreground（1，notification对象），可以让service变为前台service，并且在通知栏显示，不能被关闭的。
1是id，notification是个通知栏对象。





startService方式Activity和Service通信：
把内容写在Intent中，然后启动服务，在服务类中onStartCommand方法中再提取出Intent中的内容



Activity和Service通信传递数据
bindService方式，
【要先理解一点，bindService的流程，绑定成功后，onBind方法是需要返回一个IBinder对象的，这个对象会被Activity的onServiceConnected方法接收的。】

先在Service中新建一个类继承Binder类
再新建一个方法，接收参数为一个数据，然后把接收参数传递给Service
最后在onBinde方法中，设置return  这个类的对象

在Activity中定义一个Binder内部类的对象，
然后的onServiceConnected方法中，用这个对象强转接受传进来的IBinder对象

最后在Activity中操作这个对象的方法，传一个值进去。

【其实这一串传递，就是传递那个内部类的对象呢，一直传递到最后，最后直接操作这个内部类对象，调用自己的方法就完成传值了】





Service回传信息给Activity

用回调的功能
先新建一个接口，定义一个有接收参数的方法

然后在Service中定义一个这个接口的对象。
然后再设置一个set和get这个对象的方法。

在onBind中的新建Binder内部类中，再重新定义一个方法，就是return这个Service类的对象。

在Activity中的onServiceConnected方法中会接受到从Service类onBind方法中返回来的Binder对象

【刚才不是已经定义过一个Binder对象来接收这个对象了】
然后调用这个Binder对象的第二个方法，就能接收到Service的实例对象了

然后用Service的实例对象.set接口对象，给之前定义的空接口对象赋值
赋值，是需要传进去一个接口类型的对象的。
那么就new一个新的接口对象。
new一个新的接口对象。【相当于是新建了一个类继承了这个接口，并且实现其方法，补写了接口方法的流程。也就是所谓的匿名内部类。最后而且还返回生成了这个类的对象。】

现在赋值完以后，之前定义的空接口对象，相当就有接收过new对象返回的对象了。
现在就不是空的了。现在这个接口对象的实体类，就在刚才Acitivy那里new出来的地方上呢。刚才new的时候也新建类了。

最后在线程中写上，假如这个接口对象不是null空的。就是有实体类后，那么就调用自身的传参方法，把值放在传参位置上
最后实体类那里的方法，就有了传递进来的参数，就可以执行流程了。




但是现在是个线程，并不能直接操作UI线程的数据

所以要用一个Handler.sendMessage(Msg)把内容发出去
sendMessage发送的是一个Message对象
所以新建一个Message对象    Message msg=new Message（）；
Message对象存储的内容.setData(Bundle)。是不能直接存储String的
所以要再新建一个Bundle对象，然后Bundle对象.putExtra(key,传进来的值)，把数据存进去。
最后发送这个msg

发送之后。
新建一个Handler的对象
Handler a=new Handler（）
然后重写方法handlerMessage
可以直接得到传递的Messaged对象
Message对象.getData()得到M存储的Bundle对象
Bundle对象.getString（key）就得到数据了





AIDL的使用：
现在src文件夹下，新建一个文件。XXXX.aidl后缀的文件
第一行，先指定报名，package com.XXXXXXXX
第二行，interface XXXX文件名和上面一样
下面定义抽象方法，没有{}的方法体。

然后点击保存后，在gen目录下就会生成一个java文件。

然后在Service类中，创建生成这个对象
xx文件名.Stub mBinder = new Stub(){
   实现其方法
}；
然后在，onBinder方法中，return这个mBinder对象就可以了。
最后在AndroidMainfest文件中，给Service加上个intent-filter，加个action动作


在使用方：
也需要一份一模一样的，AIDL文件，连包名和文件名内容都要一样。
然后绑定service的时候，使用隐式的Intent。使用指定动作

然后在ServiceConnection连接器的，onServiceConnected方法中：
使用aidl文件名.Stun.asInterface(传过来的IBinder对象)
myAIDLService = MyAIDLService.Stub.asInterface(service);  
然后就可以使用这个类的方法了。







**************************************************************************
系统服务

上下文.getSystemService(服务常量名)   
就可以得到对应的系统服务了， 需要强转下。
****************************
CONNECTIVITY_SERVICE              
获得的是ConnectivityManager类型对象，网络信息对象

ConnectivityManager.getActiveNetWorkInfo()  得到一个NetworkInfo网络信息对象
NetworkInfo.isAvailable()           是否可用
NetworkInfo.isTypeName()            获取网络类型名字

ACCESS_NETWORK_STATE               【系统权限】获取网络的权限

******************************
WIFI_SERVICE                      
获得的是WifiManager类型对象，wifi管理员对象

wifiManager.isWifiEnabled()        wifi是否打开状态
wifiManager.setWifiEnabled()       设置wifi打开状态


ACCES_WIFI_STATE                   【系统权限】获取wifi的权限
CHANGE_WIFI_STATE                  【系统权限】改变wifi的权限


*******************************

AUDIO_SERVICE                      
获得的是AudioManager类型对象，系统音量服务对象

AudioManager.getStreamVolume(AudioManager.STREAM_RING) 获取当前铃声的音量
AudioManager.getStreamMaxVolume(AudioManager.STREAM_SYSTEM) 获取最大音量值


*********************************************

ACTIVITY_SERVICE                   
获得的是ActivityManager类型对象，应用程序的系统状态对象

ActivityManager.getRunningTasks(1).get(0),topActivity.getPackageName()
获取运行的进程的第一个活动页面的包名

List<RunningAppProcessInfo> list = am.getRunningAppProcesses()
获取运行中的app的进程信息列表。
list.get(i).pid获取进程号
list.get(i).processName  获取进程名

android.os.Process.myPid()   获取当前进程的pid号

content.getPackageName()	获取包名




GET_TASKS                          【系统权限】获取进程的权限  


**************************************

ALARM_SERVICE	
获得的是AlarmManager类型对象，		   闹钟服务
AlarmManager alarmManager = getSystemService(ALARM_SERVICE)
alarmManager.setRepeating(类型，启动时间，重复提醒时间，PendingIntent对象)
  **类型有AlarmManager.RTC和AlarmManager.RTC_WAKEUP。加WAKEUP就是手机休眠了也     会执行。
    启动时间，需要一个long型数据，也就是毫秒数 
    重复提醒时间，就是闹钟响了后，不操作，多少时间后再次启动，也是long毫秒
    【PendingIntent对象，可以打开一个Activity，也可以打开一个Broadcast。实例化对象，是用一个静态方法获得：
PendingIntent pi = 
	PendingIntent.getBroadecast(上下文，返回码0，Intent对象，flag)
Intent对象，可以直接是个Broadcast类地址，也可以是个Action动作消息。
flag有PendingIntent.FLAG_CANCEL_CURRENT
和PendingIntent.FLAG_UPDATE_CURRENT】

取消闹钟：
alarmManager.cancel(PendingIntent对象)
取消和PendingIntent对象相符的闹钟。
主要是靠返回码的不同，来区分各个闹钟的。

在Broadcast类的页面中，可以用getResultCode()获得返回码
在广播接收类中，如果要打开一个intent，要设置下intent的启动方法
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)     设置启动为新的任务栈













***************************************************************************
控件都可以再设置一个监听器    监控触摸的监听器
setOnTouchListener(new OnTouchListener())

手势识别

先设置监听触摸的监听器，得到MotionEvent手势事件对象。这个对象可以记录X和Y的值，利用这一点再根据3个动作方法，可以做出各种各样的处理。


也可以用GestureDetector的方法.onTouchListener(手势对象)。把手势事件对象传进去做进一步处理。
GestureDatector类封装了很多识别各种手势的方法。可以识别各种手势

创建实例化GestureDetector对象的时候，是需要传进去一个指定接口的类的对象

内部流程应该是，当GestureDetector识别了是某种手势时，就调用接口的类的某种方法来处理。


OnGestureListener就是含有各种单击手势处理方式的接口。内部提供了各种手势的处理方式的抽象类，它只是提供各种手势对应的各种数据，然后创建的实例化对象的时候，来补全具体的处理方法。
OnGestureListener的方法
onDown                  单击
onSingleTapUp           抬起
onShowPress 		短按
onLongPress 		长按
onScroll		滚动
onFling			滑动

			
OnDoubleTapListener含有各种双击手势处理方式的接口。
OnDoubleTapListener的方法：
onDoubleTap             双击
onDoubleTapEvent	双击按下和抬起
onSingleTapConfirmed	单击确认



SimpleOnGestureListener类继承了OnGestureListener和OnDownTapListener这两个接口的所有方法



控件的手势事件：
给控件设置手势监听器setOnTouchListener（），
然后新建一个GestureDetector的对象，
再新建一个内部类继承SimpleOnGestureListener，重载需要的手势方法。
然后实例化GestureDetector对象，构造参数选择，new一个SimpleOnGestureListener的对象。
最后用GestureDetector的对象.onTouchListener(手势对象)






**********************************************************************
使用自定义手势


先在GestureBuilder中新建手势，然后在内存中找到，导出到电脑上。
然后在项目的res下新建一个目录raw，把手势文件导入到目录下

然后在XML中新建一个android.gesture.GestureOverlayView标签，里面可以包括别的各种控件。在Activity类中，新建初始化GestureOverlayView对象。

然后加载手势文件：
GestureLibrary a=GestureLibraries.fromRawResource(上下文，R.raw.XX)
a.load()   这样就完成加载了

给自定义手势对象添加监听器：
GestureOverlayView有三个监听器：
OnGestureListener			手势监听器
OnGesturePerformedListener		手势执行监听器
OnGestureningListener			手势执行中监听器
GestureOverlayView.addOnGesturePerformedListener(new XX)  添加执行中监听器


用手势目录对象识别对比当前的手势a.recognize(接收参数gesture)
这样会拿当前手势，和手势目录里面的每一个手势，都去对比。
然后会把手势目录的所有手势以相识度从高到低排序，生成一个ArrsyList<Prediction>类型的手势相识度【包含手势名和相识值】集合。【所以一般来说取第一个就可以了】



手势相识度.score  相识度   返回相识度的值（0-20左右）
手势相识度.name            返回当前的手势名称         



GestureOverlayView的XML属性：
eventInterceptionEnabled
fadeDuration				画完后淡出的时间
fadeEnabled				画完后是否自动淡出
gestureColor                            手势颜色
gestureStrokeType			笔画的类型  单指还是多指
gestureStrokeWidth			笔画的粗细






************************************************
ListView 添加页头和页尾
新建一个类，继承ListView
addHeaderView（view）    页头
addFooterView(view)      页尾








接口回调的方法；多重情况
1、如果第二个类能获取到第一个类的对象
先在第二个类中，新建一个接口，再创建一个传递数据的方法；
然后在定义一个变量a，为这个接口类型的。现在是一个空的，没有对象赋值的

然后让第一个类，继承这个接口，实现方法，现在第一个类的对象，已经是这个接口类型的一个实例化对象了。


在第二个类中，给接口类型变量a，赋值，把第一个类的对象赋值给a。
然后a就能调用第一个类实现的接口方法了。然后传参数过去。
第一个类的接口方法那，就能接受到参数了。然后再做出处理。




2、第一个类能获取到第二个类的对象。
先在第二个类中，新建一个接口，再创建一个传递数据的方法；
然后在定义一个变量a，为这个接口类型的。现在是一个空的，没有对象赋值的

然后让第一个类，继承这个接口，实现方法，现在第一个类的对象，已经是这个接口类型的一个实例化对象了。

然后给a设置一个set方法，这个方法也就是需要，接收一个接口类型实例化后的对象，然后赋值给自身的空接口对象。

然后第一个类，获取到第二个类的对象后，用第二个类的set接口方法，传入this也就是第一个类的对象过去。
这时候把第二个类的接口变量，也不是空的了。这时候就算是第一个类的对象了。

然后再要传递数据的时候，判定下，接口变量是否为空，如果不为空，就是第一个实现其方法，并且给自身赋值了，然后就用接口方法传递参数过去。




3、如果是第一个类，需要调用第二个类的一个方法。这个方法又不能正常的返回值，比如子线程。

那么在方法的接受参数那，设置下，必须传递过去一个接口类型的实例化对象过去。
然后用这个实例化对象，操作其接口方法就可以了。














**************************************
接收最新短信的方法：
动态注册一个广播接受值
实例化一个BroadcastRecevier
再实例化一个IntentFilter
IntentFilter.addAction("android.provider.Telephony.SMS_RECEVIER")
   **这个就是系统来短信的广播
最后registerRecevier（广播接收者对象，滤波器对象）

然后在内部创建一个广播接收器的内部类
Bundle bundle = intent.getExtras()       
Object[] pdus=(Object[])bundle.get("pdus")










***********************************************
自定义View来绘制自定义图形

先新建类继承View，重写onDraw方法。可以得到convas

然后在构造方法那实例化Paint画笔对象，
设置一些参数：
paint.setColor()                     	设置画笔的颜色  0x必须要有透明度的8位的
paint.setStrokeWidth(3)			设置画笔的粗细  
   这个线的宽度，是从绘制的基准线，往两边扩的。比如线宽50，从100，100处画一条线。这条线的底边Y轴应该是在125那里的。从100那里往下面扩。画圆的话，圆的边也是一样的原理。


字体效果参数
paint.setTextSize()                    	设置文字大小
 setFakeBoldText(boolean fakeBoldText);   
     * 模拟实现粗体文字，设置在小字体上效果会非常差   
   
setSubpixelText(boolean subpixelText);   
     * 设置该项为true，将有助于文本在LCD屏幕上的显示效果   
 
     * setTextAlign(Paint.Align align);   
     * 设置绘制文字的对齐方向   绘制文字的时候，设置的起点XY，如果是设置成Paint.Align.CENTER，那么起点XY就会成绘制文字的中心点了。

    * setTextScaleX(float scaleX);   
    * 设置绘制文字x轴的缩放比例，只会变长或短1是正常。2是一倍。。。  

     * setTextSkewX(float skewX);   
     * 设置斜体文字，skewX为倾斜弧度    0.25f上边在前倾斜，-0.25f下边在前

     * setTypeface(Typeface typeface);   
     * 设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等   

     * setUnderlineText(boolean underlineText);   
     * 设置带有下划线的文字效果   
   
     * setStrikeThruText(boolean strikeThruText);   
     * 设置带有删除线的效果    





paint.setAlpha(0-255)                   设置画笔的透明度
paint.setAntiAlias(true)		设置是否使用抗锯齿
paint.setDither(true)                	设置是否使用图像抖动，使用了更清晰
paint.setShader(Shader渐变对象)         设置渐变色

paint.setXfermode(xFermode重叠对象)     设置重叠样式
paint.setStyle(Paint.Style style); 	设置画笔样式，充满、描边   
paint.setStrokeCop(Cop.ROUND)		设置笔触的样式
   **类似铅笔的笔尖是什么形状的，比如圆的，点下去，就是个圆点。方的，点下去就是个方点。有三个参数，Cop.ROUND（圆点）Cop.SQUARE（方点），Cop.BUTT无笔触
设置画笔宽度，相当于画笔的上下那有宽度了，但是画笔左右是没有宽度的。
设置了圆点或者方形笔触，相当于设置了画笔左右的宽度。
比如设置50的画笔宽度，从100,100处画线。相当于画笔的中心点，点在了100,100那里，因为画笔左右是有宽度的，所有实际绘制的起点，在X轴起点左侧加25的位置。



paint.setStrokeJoin(Join.ROUND)		设置连线的结合处样式，线段拐角处外侧的样式。
Join.MITER	锐角，默认普通的锋利的转折
Join.BEVEL	直线，转折的外侧像被斜着切了一部分。
Join.Round	圆弧，圆润的转折，不那么锋利
	



画笔渐变色：
BitmapShader渐变
就是用一个图片，来代替渐变来填充图形。
BitmapShader bitmapShader = new BitmapShader（bitmap，xmode，ymode）
mode模式有三种，
TileMode.CLAMP		拉伸，如果图片不够大，就拉伸图片边缘的颜色
TileMode.REPERTA	平铺，如果图片不够大，就多个平铺显示
TileMode.MIRROR		镜像，也是平铺，只是下面的图像，是上面的倒影

最后给paint设置渐变
paint.setShader(bitmapShader)

然后在画一个图形，图形内就是这个图片了。




线性渐变
LinearGradient gradient = new LinearGradient(x0，y0,x1,y1,color1,color2,mode)
x0	是渐变起始点的x坐标
yo	是渐变起始点Y的坐标

x1	是渐变终点的x坐标
y1	是渐变终点Y的坐标

color1	是渐变的起始颜色
color2	是渐变的最终颜色
mode  	还是TileMode.CLAMP这三种
   color这里一般用带透明度的颜色

然后设置画笔的渐变
paint.setShader(gradient)

最后用画笔画个图形，图形内就有这个渐变颜色了。
可以先画一个图片，在图片上面再画个有渐变的图形。




paint.setPathEffect(PathEffect路径对象)	设置画笔路径样式
1.CornerPathEffect    圆角样式，使用后，绘制的折线，就是像波浪线一样有弧度的。使用方法：
new CornerPathEffect(50)	参数设置弧度的半径。

2.DashPathEffect	    虚线样式。
new DashPathEffect(float intervals[]，float phase)
intervals[]是自定义的虚线长度样式，比如100,100,50,50就是一段100的显示，100的不显示，一段50的显示，一段50的不显示。还可以自定义更多的。两个为一组。定义后，绘制的路径就会以定义的样式循环显示下去。
phase，是偏移量。比如设置为50，同样以上面的线段为例，绘制开始的时候，第一段100就会偏移少50，变成50显示，100不显示...

phase可以配合ValueAnimator生成进度值，然后产生动画。
也可以搞成一个路径的逐渐显示出来的动画，把线段样式，写成{路径长度，路径长度}，然后用动画不断产生偏移量。


3.DiscretePathEffect	离散路径样式
把路径分成多段，每段都有些偏移的效果。
new DiscretePathEffect(float segmentLength, float deviation)
segmentLength每段离散路径的长度
deviation每段离散路径的可以偏移距离


4.PathDashPathEffect	图章效果
使用自定义的样式，来绘制路径
new PathDashPathEffect(Path shape, float advance, float phase, Style style)
shape	图章路径，自定义个Path路径
advance	边是两个图章路径间的距离
phase	偏移距离
style	转角处理效果
PathDashPathEffect.Style.MORPH    转角会变形图章
PathDashPathEffect.Style.ROTATE   转角会旋转图章
PathDashPathEffect.Style.TRANSLATE	转角不做处理，有可能会缩小图章


5.new ComposePathEffect(路径样式对象，路径样式对象)
new SumPathEffect(路径样式对象，路径样式对象)
合并两个路径样式效果。
ComposePathEffect是两个效果结合。比如虚线和圆角。就会变成有圆角的虚线样式
SumPathEffect就是绘制两条不同样式的路径，然后叠加在一起




paint.setShadowLayer(float radius, float dx, float dy, int shadowColor)
   **radius表示阴影的扩散半径；dx和dy表示阴影平面上的偏移值；shadowColor就不说了阴影颜色。注意：阴影，需要关闭硬件加速





setColorFilter   设置颜色滤镜

色相
就是颜色的传递，一个颜色和另一个颜色

饱和度
类似颜色的浓度吧，比如红色，0就是没有颜色了，黑白了，100就是黑红的颜色了

明度
一个颜色在不同的明亮度下，颜色也是不同的。


创建ColorMatrix，来设置色相，饱和度，明度
new ColorMatrix()
new ColorMatrix(float[] src)  使用一个5 * 4的数组来构建
ColorMatrix(ColorMatrix src)  使用另一个对象来构建，完全复制一个

也可以创建一个空的，然后用set()方法，可以用另一个对象或者设置。
matrix.reset()		重置为RGBA数组都为1


这里需要创建多个ColorMatrix来分辨设置每一项

matrix.setRotate(0,hue1)
matrix.setRotate(1,hue2)
matrix.setRotate(2,hue3)
setRotate方法就是设置色相的，第一个参数0/1/2，是代表要修改R G B的颜色，
后面是设置每个色相，一般-180到180.


matrix2.setSaturation(float saturation)
就是设置饱和度的。 0是没色彩灰色的。1是不变原本的色彩。大于1时，开始增加饱和度


matrix3.setScale(r,g,b,a)
设置各个颜色的亮度，参数是R的亮度值，G,B的亮度值，a是透明度
0是直接没有这个颜色了。1是不变。大于1是加高亮度
比如把rg都设置为0，b设置为1，就是蓝色单通道了。


matrix4.postConcat(matrix1)
matrix4.postConcat(matrix2)
matrix4.postConcat(matrix3)
再创建一个ColorMatrix使用postConcat，每次传入一个设置过的ColorMatrix，最后这个matrix4就糅合了这三个设置。


setColorFilter，需要一个ColorFilter对象。可以使用子类ColorMatrixColorFilter对象
生成ColorMatrixColorFilter对象可以使用一个ColorMatrix来构造
paint.setColorFilter(new ColorMatrixColorFilter(matrix4))




LightingColorFilter 光照颜色过滤器（类似上面那个设置亮度）
new LightingColorFilter（int mul, int add）
mul和add都是颜色值，0xRRGGBB,六位对应RGB的，没有AA透明度的
内部调整算法为：
结果R值 = (r*mul.R+add.R)%255;  
结果G值 = (g*mul.G+add.G)%255;  
结果B值 = (b*mul.B+add.B)%255; 

比如，如果设置为（0x00ff00,0x000000）,就等于把红色和蓝色给屏蔽了，只有绿色通道了。和上面那个设置亮度就一样了。

设置为（0xffffff,0xf00000）,前面的mul设置等于各个颜色不变，后面的add是让红色给增强了。

设置（0x000000,0xff0000）,mul按照算法，每个颜色乘以00，当然就变为没有颜色了。最后再加上后面的颜色的，也是说add的颜色，会当做整个图像的颜色了。




PorterDuffColorFilter
图层混合滤镜	和PS一样的图层混合模式，变暗，正片叠底什么的
new ProterDuffColorFilter(int srcColor, ProterDuff.Mode mode)
srcColor	要混合的颜色，0xAARRGGBB八位的ARGB颜色值
mode		图层叠加模式
Mode.CLEAR  		清空(使用后，图像就没有了)
Mode.SRC  
Mode.DST  
Mode.SRC_OVER  
Mode.DST_OVER  
Mode.SRC_IN  		图像的形状使用下面图片的，显示的图像为混合的颜色，可用于给图标上色(使用LightingColorFilter也可以做到的)
Mode.DST_IN  
Mode.SRC_OUT  
Mode.DST_OUT  
Mode.SRC_ATOP  
Mode.DST_ATOP  
Mode.XOR  		使用后，只会显示混合的颜色了，没有图片了
Mode.DARKEN  		变暗
Mode.LIGHTEN  		变亮
Mode.MULTIPLY  		正片叠底
Mode.SCREEN  		滤色
Mode.OVERLAY  		叠加
Mode.ADD  		饱和度相加





setXfermode（）
设置setXfermode后，再绘制的图层相当于就是个辅助滤镜功能了。所以一般使用后就会再设置为null了。辅助对比的是整个canvas画布，会与自身所占画布大小的区域，按照指定模式计算生成颜色。
对应区域，如果滤镜图层是个圆形，那么对应的一个圆的区域，如果是离左右100距离，宽400的区域，那对应的也是这样的一个区域。
计算颜色，也只是计算对应的区域哦。

AvoideXfermode  颜色替换效果
使用此效果，需要关掉硬件加速
new AvoideXfermode(int opColor, int tolerance, Mode mode)
opColor		图片中要替换掉的颜色，ARGB颜色值
tolerance	颜色容差值，比如设置替换掉白色，可以需要有一定的容差 0-255
mode		Mode.TARGET和Mode.AVOID   TARGET就是替换模式；AVOID是反选模式，比如设置成白色，就是除了白色外的其他颜色都替换。

具体使用：
需要先绘制一个图片
然后再给画笔设置paint.setXfermode()
然后再绘制图片或者矩形路径什么的。就会把指定的颜色换成画笔色了。

如果滤镜图层是图片的话，可以理解成，这个滤镜图层就显示在所有图层的下面的。滤镜图层对应的画布区域，会把指定的颜色给扣掉，变成透明的，就会显示下面的滤镜图层了。








PorterDuffXfermode
paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN))
Mode.SRC_IN    计算方式Sa * Da, Sc * Da   
SRC是滤镜图层，DST是canvas画布，a是透明度，c是颜色；前面是计算透明度，后面是计算显示颜色。
Sa * Da,也就是说，对应重叠区域如果有一方是0透明的，那么肯定就会变成透明的了。

Sc * Da, 也就是说，最终显示是SRC滤镜图层的颜色，但是会乘以底图的透明度来显示。
也就是说需要两方都有颜色的地方，才会显示出来的。

制作圆形图片的话：
先绘制一个实心圆形，然后paint设置SRC_IN的模式，再绘制一个图片就成了。圆形大小和图片显示大小都计算好对应大小。

先绘制图片的话，再设置DST_IN的模式，再绘制圆形的话，是不行的。需要把滤镜图层弄成一个正方形的，中间画圆形，把四个角弄成透明的，这样就可以把图片的四个角弄透明了。


Mode.ADD		Saturate(S + D)  
Mode.Mode.CLEAR		[0, 0]  
Mode.DARKEN  		[Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)]  
Mode.DST		[Da, Dc]  
Mode.DST_ATOP		[Sa, Sa * Dc + Sc * (1 - Da)]  
Mode.DST_IN		[Sa * Da, Sa * Dc]  
Mode.DST_OUT  		[Da * (1 - Sa), Dc * (1 - Sa)]  
Mode.DST_OVER		[Sa + (1 - Sa)*Da, Rc = Dc + (1 - Da)*Sc]  
Mode.LIGHTEN		[Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]  
Mode.MULTIPLY		[Sa * Da, Sc * Dc]  
Mode.OVERLAY
Mode.SCREEN		[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc]  
Mode.SRC		[Sa, Sc]  
Mode.SRC_ATOP		[Da, Sc * Da + (1 - Sa) * Dc]  
Mode.SRC_IN		[Sa * Da, Sc * Da]  
Mode.SRC_OUT		[Sa * (1 - Da), Sc * (1 - Da)]  
Mode.SRC_OVER		[Sa + (1 - Sa)*Da, Rc = Sc + (1 - Sa)*Dc]  
Mode.XOR		[Sa + Da - 2 * Sa * Da, Sc * (1 - Da) + (1 - Sa) * Dc]  


Mode.ADD		Saturate(S + D)  
饱和度相加
滤镜图层和Canvas图层叠加的部分，如果有颜色，就饱和度相加，如果有一方没有颜色，那有颜色的饱和度也就不变。照常显示。


Mode.LIGHTEN		[Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)] 
Mode.DARKEN  		[Sa + Da - Sa*Da, Sc*(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)]   
变亮、变暗
都和上面饱和度的一样，重叠的部分，颜色会变亮变暗。其他区域照常显示


Mode.MULTIPLY		[Sa * Da, Sc * Dc]  
正片叠底
Sa * Da也就是说，只有两方都有颜色叠加的地方才会显示。显示的颜色是相乘的颜色。


Mode.OVERLAY
叠加部分，canvas变成半透明，滤镜图层在下。不叠加部分正常显示


Mode.SCREEN		[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc]  
滤色
叠加部分变成一个新的颜色。不叠加部分正常显示


Mode.SRC		[Sa, Sc]  
滤镜图层的透明度，滤镜图层的颜色。
滤镜图层就直接显示在canvas上，如果滤镜图层有部分是透明的，直接就把canvas对应的那区域变成透明的了，不会说透明了，就显示下面canvas上的图像。


Mode.SRC_OUT		[Sa * (1 - Da), Sc * (1 - Da)]  
滤镜图层透明的地方；和双方都不透明的地方；就会变成透明的。
只有滤镜有颜色的地方，就显示滤镜图层的颜色。
可以用这个效果，来做橡皮擦的效果。先绘制图片，或者橡皮擦路径都可以。
关键是绘制把橡皮擦路径时，把路径控制在图片大小内。用裁剪恢复图层，或者把路径绘制在一个指定大小的空bitmap中都可以。


Mode.SRC_OVER		[Sa + (1 - Sa)*Da, Rc = Sc + (1 - Sa)*Dc]  
完全没变化，就是滤镜图层在Canvas图层上。


Mode.SRC_ATOP		[Da, Sc * Da + (1 - Sa) * Dc]  
和SRC_IN基本一样。只有滤镜图层透明度在0-1之间的时候，ATOP会更亮一些


Mode.DST		[Da, Dc]  
完全不显示滤镜图层


Mode.DST_IN		[Sa * Da, Sa * Dc]  
都不是透明，才会显示，显示的是canvas的颜色，乘以滤镜的透明度
可以绘制一个文字，然后设置滤镜，再绘制一个动态的路径。就会显示成动态路径只显示在文字上了


Mode.DST_OUT  		[Da * (1 - Sa), Dc * (1 - Sa)] 
只要滤镜图层有颜色的区域，直接就变成透明的。滤镜图层透明的区域，显示下面canvas的颜色。


Mode.DST_OVER		[Sa + (1 - Sa)*Da, Rc = Dc + (1 - Da)*Sc]  
就是滤镜图层显示在canvas图层下。


Mode.SRC_ATOP		[Da, Sc * Da + (1 - Sa) * Dc]  
都有颜色的地方，显示canvas的颜色，滤镜图层是透明的时候，那就是透明的；只有滤镜图层有颜色的地方，就显示滤镜图层的颜色。


Mode.Mode.CLEAR		[0, 0]  
直接就把滤镜图层大小对应canvas区域，置为透明















在onDraw方法中就可以画了。
drawRect(左，上，右，下，paint)     这些值都是px的
  **左是指  画布左边框  和  控件左边框  之间的距离。0就是贴边的
    上是指  画布上边框  和  控件上边框  的距离
    右是指  控件左边框  到  画布右边框  的距离
    下是指  控件上边框  到  画布下边框  的距离
  **画布宽高是从控件的边框到画布的边框计算的。


drawText("内容"，X轴值，Y轴值，paint)
  **画文本       在x,y点处开始绘制文字。
其实实际上，文字并不是以XY点为左下角开始绘制的。
y的位置，是绘制文字的基线，也就是一般字母都是贴着这个线绘制的，但汉字和g之类的，是实际绘制在这个基线之下的。实际下文字的真正的下边界是fm.descent

绘制文字时的基线和宽高
给paint设置好文字大小后，可以获取一个包含基线信息的对象
FontMetrics fm = paint.getFontMetrics();   或getFontMetricsInt（）返回int的数值对象
绘制的文字会有一个最小区域和一个最大区域
fm.ascent 	最小区域的高度，也就是从基线Y轴0那往上计算的，也就是负多少。
fm.descent	最小区域的底边，
fm.top		最大区域的高度
fm.bottom	最大区域的底边。
基线到高度的距离 + 基线到底边的距离 也就是高度了。

TextView的wrapContent包括内容的设定，最终的显示效果，就是最大区域的那样。也就是实际上下都有空隙的。



获取文字的绘制信息：

1、通过float width = paint.measureText("你好")
会返回输入文本的宽度值。


2、Rect rect = new Rect（）
paint.getTextBounds(str，开始点，结束点，rect)
新建一个空的Rect矩形，然后用paint的getTextBounds方法
参数值，第一个是字符串，从第几个开始，到那个结束。

测量后，就会得到一个文字的绘制信息rect了，rect中的上下左右，就是文字在0,0位置上绘制的绘制信息，离上下左右的距离，和宽高值。其中top就是fm.ascent基线到最小区域的高度，bottom就是fm.descent基线到最小区域的底边的距离。

如果要算绘制文字居中显示的XY轴，其中Y轴，要算文字的基线位置才是最准确的。

除以2就是控件的中心点，然后再计算存放文字控件的中心点，中心点X减去文字中心点X，就是中间离的距离，也就是文字左上角的X点；
y点是控件中心点加上(文字中心点的y - rect.bottom(基线下的高度)）。

使用paint.getTextBounds()方法获取的高度，是最精准的，正好包裹文字的高度，也就是最小区域的高度信息。





drawTextOnPath(内容，path对象，偏移量1，偏移量2，paint)
  **沿路径画文本
    path对象，就是添加过路径的路径对象
    偏移量1，就是绘制文本的开始地点，与路径开始点的偏移量，偏移多长才开始绘制
    偏移量2，文本是在路径上面绘制的，相当于是在一条线上，往线下偏移多少。







drawCircle(圆心的X轴值，圆心的Y轴值，圆的半径，paint)
  **画圆形        XY轴是圆形的中心点

drawLine(起点X，起点Y，终点X，终点Y，paint)
  **画线          XY是屏幕真正的XY值

drawLines(float[],paint)
  **画多条直线，用float[]数组内的数值当做XY轴，两个数为一个点，两个点为一个线
如果要画连续的线，两个点为一个线，第三个点需要和第二个点相同。
drawPoint(X轴，Y轴，画笔)
  **在XY轴那画一个点

drawPoints(float[],offset,count,paint)
  **画float数组里面的多个点，offset是跳过前面几个点(一个点两个数值)。
    count是从开始画的数组数值计算，画几个数组数值。


drawArc(绘制区域Rectf，开始角度，加多少角度，是否使用中心，paint)
  **Rectf f = new Rectf(左，上，右，下)    画弧线
开始角度是从0度那里加上填写的开始角度。0度是绘制区域的横向中间线的最右点，也是正常钟表的3点钟那里算是0度的，累计角度是顺时针方向的

最终角度，是从开始角度那里加上多少度，不是从横中分线右边开始计算的。

    是否使用中心，如果是false不使用。就是一段弧线，如果是true，就是个半圆、圆的切片那样的
    弧形的中心点，是RectF区域的中心点
    求弧形的长度，周长乘以π，然后除以所占长度的比例。周长也就是rectf的宽度




drawColor(int)   直接使用一个颜色充满控件


drawOval(绘制区域Rectf，point)
  **画椭圆       在绘制区域内充满一个圆形，如果绘制区域不是正方形，那么圆就被  拉伸成椭圆了


drawRoundRect(绘制区域Rectf，两边X轴弧的总和，两边Y轴弧的总和，point)
  **画圆角矩形，X值是两边圆角的总共，假如是20，那么就是一边是10的圆角


drawPath（path对象，paint）
  **根据path对象，画一个路径
    Path path = new Path()  		新建一个path路径对象
    path.moveTo(X轴，Y轴值)		设置起点
    path.lineTo(X轴，Y轴值)		第二个点的位置
    path.close()                  	闭环，最后一个点和起点连起来
【画线的时候，画笔要是用描边的模式】
   一个path对象是可以存储，多个不相连接的路径的。绘制的途中，再使用一次moveTo，就是另起一条路径了。moveTo的点不会和上次最后一个点，连接在一起的。


    path还可以添加各种路径不用自己一点一点画了。
    可以添加Retcf，RoundRectf，Oval，Circle...
    方法：path.addOval(绘图区Rectf，方向参数)
          **方向参数有Direction.CCW(逆时针)、Direction.CW(顺时针)两种
            这里不需要用画笔了。


path.reset()		重置path，清空所有线路。
PathMeasure measure = new PathMeasure(path,false)
float length = measure.getLength();
测量Path路径的长度。




贝赛尔曲线：
一阶贝塞尔曲线，就是两个点之间的匀速移动轨迹

二阶贝塞尔曲线，就是起点，终点，中间控制点，三个点构成的。
Q0点，从起点到控制点匀速运动，
Q1点，从控制点到终点匀速运动。
在运动中，B点，再从Q0到Q1之间匀速运动，形成的轨迹就是贝赛尔曲线。

三阶贝塞尔曲线，就是起点，终点，中间两个控制点。
轨迹类似上面的一样。



绘制贝赛尔曲线的方法：
path.quadTo(控制点X，控制点Y，终点X，终点Y)
两个点之间，起始点和终点之间，再加一个控制点，就可以画一个曲线了。
这个方法，起始点是以path路径上的最后一个点，为起始点的，现在只需要再设置一个控制点和终点就行了。
触摸绘制贝塞尔曲线的时候：
以上一次点击的点，为控制点。
取上次点和本次点的中间点，为终点。


绘制贝赛尔曲线的另一个方法：
path.rQuadTo(控制点X,控制点Y，终点X，终点Y)
这里控制点和终点的坐标，都是path路径上最后一个点的相对值。比如-100，-100.就是上一个点的XY各减去100.


使用相对值方法，绘制一个简单的波浪贝赛尔曲线。
控制点X每次加100，终点X每次加200.
控制点Y也就是浪高，固定加50。终点Y不变，和起点Y一样高。








drawBitmap(Bitmap对象，X，Y，paint)
  **XY是指离控件的左边和上边的距离值，然后从那里开始绘制。绘制大小用的是图片的大小，图片是多大就绘制多大。不会填充缩放什么的，这样图片如果很小的话，图片就只会占据一点的位置，如果图片很大，图片就只会显示一个角落。
drawBitmap(Bitmap对象，Rect对象，RectF对象，paint)
  **Rect对象里的区域，指的是取图片上的区域，
    比如图片是100*100，区域是从0,0到50,50。就是取图片左上角的部分来显示。
    如果是0,0到200,200.就是把图片缩小显示。
    RectF对象，指的是要，画布上给图片准备的，显示区域。给图片准备的显示区域。图片会自动拉伸填充满区域



取路径交集
先构建一个path，也可以是各种形状的path路径

然后新建一个Region
  Region region = new Region（）；         创建一个空的Region对象
    **还可以放入一个Rectf对象，或者直接传入四个XY区域值

region.setPath(path对象，新的Region对象)
    **给这个空的region设置区域，区域就是path对象和新的Region对象的合集

convas是不能直接画Region的。所以要用一个RgionIterator迭代器来绘制
   RegionInterator iter = new RegionIterator（region对象）
   Rect rect = new Rect（）；
   whilie(iter.next(rect)){
      convas.drawRect(rect,paint)
   }
先新建一个迭代器，构造方法传入这个Region对象进去。
然后再新建一个空的rect
iter.next（rect）  迭代器读取下一个区域给rect，并返回一个boolean值
然后用convas绘制这个rect，一直循环绘制。




取两个区域的各种合集

先新建两个Region，有区域值的，可以用Rectf构建，也可以直接写值

最后用其中一个region，操作和另一个region的合集，方法：
region.op(region2，Op.INTERSECT)
  **取出两个的合集并且赋值给自身。
    Op.INTERSECT      		合集
    Op.DIFFERENCE            	补集 只留自身没有合集的部分
    Op.REPLACE                  替换 把对方的数据赋值给自己
    Op.REVERSE_DIFFERENCE       反转补集  把对方没有合集的部分给自己
    Op.UNION                    并集 把双方的数据都给自己
    Op.XOR                      异并集   把双方没有合金的部分给自己






画布canvas的移动

canvas.translate(X,Y)
  **把画布移动XY值

canvas.rotate(角度，中心X，中心Y)
  **把画布旋转多少角度，以什么中心，不写默认为00

canvas.scale(X缩放度，Y缩放度，中心X，中心Y)
  **把画布XY缩放多少，1是正常，2是一倍


canvas.clipPath(path对象)
  **按照这个路径来剪切一个新的画布
    还可以用clipRect、clipRegion等等绘制一个路径或者区域，然后按照这个区域剪


这些都是改变画布的原点的，比如原始0,0点


canvas.save()
  保存的是当前画布的位置和形状，并不会保存颜色图形什么的。
  保存的时候，是可以多次保存的，是后进先出的

canvas.restore()
  恢复的是栈中最顶层，也是最后一次保存的状态。
  也可以多次restore恢复，就会恢复到指定的状态。


invalidate()重绘视图
postInvalidate（）也是重绘视图
invalidate只能在主线程中使用，
在子线程中，可以使用postInvalidate

View的invalidate（）方法可以直接在外面用对象名.方法名使用的。








image的居中显示样式：
scaleType：matrix     		
  **图片正常比例在控件左上角那开始显示，能显示多少就是多少

scaleType：fitXy            强制拉伸填满控件

scaleType：fitStart        
scaleType：fitCenter	    
scaleType：fitEnd         
  **图片按照正常比例缩放，
算法：
控件宽高除以图片的宽高，就是图片要缩或者放的比例。选出最小的那个比例。
特点：会把图片完全显示出来，不拉伸的填满控件。大了缩小显示完全，小了会放大到至少两条边和控件两条边框一样长。
Start就是图片从控件的左上角开始显示
Center就是图片从控件的中间开始显示
End就是图片从控件的右下角开始显示

imageView默认是使用fitCenter的


scaleType：center           图片正常比例在控件中间显示，能显示多少就多少
scaleType：centerCrop       
  **图片居中显示，填充满控件。
    图片按照正常比例缩放显示，一直缩或放到，最短的两条边和控件边框对齐为止。大了就缩，小了就放。
scaleType：centerInside    
  **图片居中显示，图片内容完全显示。
    是必然要显示完全的。大了，就按照比例缩小显示完    。小了，就正常大小。









***************************************
SurfaceView
比View好的地方是，可以使用新建一个子线程，然后用子线程更新UI了。

新建一个类继承SurfaceView,然后再继承一个接口，SurfaceHolder.Callback
选择实现SurfaceView的构造方法，和Callback的三个方法

在构造方法中，新建并实例化一个SurfaceHolder对象：
hodler=getHolder()
然后添加回调接口方法hodler.addCallback(this)
顺便实例化和设置下画笔Paint



最后在surfaceCreated中加载，绘图的方法或者线程就可以了。

在绘图方法得到Canvas的方法。
Canvas canvas = holder.lockCanvas();


绘图完成后要提交才能显示出来。
holder.unlockCanvasAndPost(canvas);


生命周期 ：
第一次打开：构造方法，创建状态，状态改变
进入主页的时候：销毁状态。   再重新进来是：创建状态，状态改变

两个方法：
surfaceView.setZOrderOnTop(true)
设置surfaceView在顶部

surfaceView.getHolder.setFormat(PixelFormat.TRANSPARENT)
设置为透明的。




****************************************
布局动画
先新建一个动画效果，一会放入到布局动画对象中。

然后再新建一个布局动画效果
LayoutAnimationController lac=new LayoutAnimationController(动画对象，延时)
   **延时就是，让布局内的控件一个一个的显现出来。值是0-1单精度值，是指第一个       控件显出来多少的时候，让第二个来显现出来

布局动画还可以设置内部控件显现的顺序：
   lac.setOrder(LayoutAnimationController.ORDER_NORMAL)  *从上往下
       有三个静态常量可选                *ORDER_RANDOM   *随机
                                         *ORDER_REVERSE  *从下往上

最后把各种布局LinearLayout对象设置上布局动画就可以了：
LinearLayout.setLayoutAnimation(布局动画对象)



布局内容改变动画。
布局内控件改变状态时候，使用的动画
这个直接在XML布局那里设置
android:animateLayoutChanges="ture"



ListView也可以使用布局动画的。
直接setLayoutAnmation（布局动画对象）就可以了
另外GiveView什么也是可以使用的，只要是内部有列表的



静态加载布局动画
用XML新建一个动画。

然后再新建一个动画，当做布局动画XML。这个要手动写的，因为没有这个标签提示
<layoutAnimation  加个命名空间
android:animation="@anim/动画XML地址" 
android：delay=“0.5” />

最后在布局标签那，设置
android：layoutAnimation=“@anim/布局动画XML地址”   就可以使用了









***************************************
MediaPlayer

播放音频
MediaPlayer media = new MediaPlayer();
实例化一个对象。

然后设置一个资源，
media.setDataSource(可以是一个file对象，字符串地址，都可以)
media.prepare();    准备播放

也可以用一个静态方法，实例化对象和设置资源
MediaPlayer media = MediaPlayer.create(uri字符串地址，R地址)
这样就实例化对象和设置咨询和准备状态都做好了。
media.setAudioStreamType（AudioManager.STREAM_MUSIC）	设置音乐类型

media.setLooping(true)	设置是否循环播放
media.start()  		播放
media.pause()  		暂停播放，暂时释放播放资源。调用prepare后，会从停止位				置继续播放
media.stop()		停止后，无法再次播放，必须再调用prepaer（），再调用start

media.reset()		把对象重置到刚刚创建的状态,就是刚new出来的。
media.getDuration()     获取时长  毫秒数
media.seekTo() 		跳转到指定毫秒位置播放
media.getCurrentPosition()	获取当前播放到的位置
media.isPlayer() 	是否正在播放
media.release()		释放资源
  **最后一定要记得写这个释放资源，否则会出错。



media.setOnCompletionListener(new on...)
播放完成的监听器



************************************
VideoView的使用方法，播放视频：
拖拉控件，然后创建对象，实例化绑定id

video.setVideoPath(文件路径字符串)	设置视频源
video.setVideoUri(Uri对象)		根据Uri对象设置视频源
video.start()				播放或者继续
video.pause()				暂停播放
video.resume()				把视频从头播放
video.isPlaying()			判断是否正在播放
video.getDuration()			获取视频文件的时长
video.seekTo()				从指定的位置播放
video.setMediaController(new MediaController(this))
  **设置播放控制按钮







*************************************
SoundPool播放音效

实例化SoundPool对象的方法：
SoundPool sound = new SoundPool(要播放的数量，音效类型，播放质量)
**音效类型选择AduioManager.STREAM_MUSIC.   播放质量选择0

然后加载资源文件
sound.load(上下文，资源地址R地址，优先级(无效参数默认为1))
**load方法会返回一个ID。默认从1开始的。如果多个音效，可以用一个HashMap来装载这些生成的ID。

最后就是播放了
sound.play(生成的资源ID，左声道音量，右声道音量，优先级，是否循环，播放速率)
**生成的资源ID就是load时候生成的，左右声道音量都用1，优先级用0，
  是否循环0是不循环，-1是循环。播放速率0.5到2，正常速率是1.







**************************************
Vibrator震动的使用

要先记得写上震动权限。VIBRATOR

然后新建一个对象，对象需要从系统服务那获取。获取方法：
Vibrator vibrator = (Vibrator)getSystemService(VIBRATOR_SERVICE)

然后就可以使用震动了
vibrator.vibrate(震动参数)
**参数可以直接田多少毫米
  还可以填一个频率和次数进去。频率用一个long型数组表示：
  new long[]{100,400,100,400}
  是指从100秒后开始震动，400秒后停止，100毫米后再开始，400后停止。
  次数-1就是不重复。








*********************************


MediaRecorder录音

先创建实例化一个对象
MediaRecorder mrc = new MediaRecorder()

创建生成一个File对象，用于接收存储录音文件，
可以用getFilesDir(文件名)或者getCacheDir(),获取程序文件夹对象，再配合生成一个file，并且CreateNewFile()创建文件。
或者用getDir(文件夹名)，直接在程序文件夹下生成一个自定义名称的文件夹对象。
再或者用File类的静态方法File.createTempFile(字符前缀名，字符后缀名)。会在程序Cache目录下生成一个临时文件对象。


然后设置MediaRecorder的一些参数：
mrc.setAudioSource(MediaRecorder.AudioSource.MIC)  
**设置录音设备，选取静态变量MIC

mrc.setOutputFormat(MedaiRecorder.OutputFormat.DEFAULT)
**设置录音格式，选择静态变量默认       amr_nb，amr_wb,mpeg_4,raw_amr....

mrc.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT)
**设置录音编码格式，选择默认 

mrc.setOutputFile(file地址)            设置存储位置。

mrc.prepare() 				准备录音
mrc.start()				开始录音
mrc.getMaxAmplitude()	 获取最大的振幅，当前一段时间最大的音量，返回值是0-32767

mrc.stop()				停止录音，停止后
mrc.release()				释放该对象关联的资源
mrc.reset()		恢复到刚new出来的状态。


录音的权限：
RECORE_AUDIO








***************************************
传感器

基本分为三类  动作传感器   环境传感器   位置传感器

可以利用android提供的ASF类可以管理使用这些传感器

传感器也可以分为硬件传感器和软件传感器
硬件传感器就是直接从外部环境中，检测生成数据的。
软件传感器是利用硬件传感器生成的数据，二次处理后，再次生成的数据

传感器在ASF中的类型定义名称：
TYPE_ACCELEROMETER			加速传感器
TYPE_AMBIENT_TEMPERATURE		温度传感器
TYPE_GRAVITY				重力传感器（硬件或者软件）
TYPE_GYROSCOPE				陀螺仪传感器
TYPE_LIGHT				光线传感器
TYPE_LINEAR_ACCELERATION		线性加速传感器
TYPE_MAGNETIC_FIELD			磁场传感器
TYPE_ORIENTATION			方向传感器(软件的，处理至重力和磁场)
TYPE_PRESSURE				压力传感器
TYPE_PROXIMITY				临近传感器
TYPE_RELATIVE_HUMIDITY			湿度传感器
TYPE_ROTATION_VECTOR			旋转向量传感器

TYPE_ALL				所有的传感器



SensorManager 传感器管理员类

SensorManager sensor = （SensorManager）getSystemService（SENSOR_SERVICE）
**通过get系统服务，获得传感器管理员实例对象。

sensor.getSensorList(Sensor.TYPE_ALL)
**获取所有的【传感器对象】，并且返回成一个List集合。

取出一个传感器对象，可以使用传感器对象的方法.getName()   获取传感器类型的名称

sesor.getDefaultSensor(Sensor.TYPE_XXX)
**获取指定类型的传感器





使用一个传感器

要先注册一下传感器，不用的时候再注销。注册后传感器会一直传数据的，很耗电的，所以不用的时候就尽快关闭注销。
所以最好在onResume获取焦点的生命周期中注册，在onPause失去焦点的时候就注销

注销方法：sensor.unregisterListener(监听器对象)；


注册传感器的写法：
sensor.registerListener(动作传感器监听器对象，传感器对象，采集频率)
**动作传感器监听器，可以让本类继承这个接口，传入this，也可以新建一个对象
**传感器对象，可以用sensor.getDefaultSensor(Sensor.TYPE_XX)需要传感器
**采集频率，用静态变量SensorManger.SENSOR_DELAY_xx  可以选择快的，游戏的。



SonsorEventListener传感器监听器有两个方法：
一个是onAccuracyChanged（精度变化时，使用）

一个是onSensorChanged传入传感器变化的值。
实际传入的是Sensor对象，可以用来判断是哪个传感器。
Sensor对象有个Values数组，传感器的值就在数组内。使用方法：
sensor.values[0] ,sensor.values[1], sensor.values[2]
就能提取数据了。
**尽量不要接口内做太复杂的操作。




加速传感器的三个值是XYZ的值
手机正常平放，左右是X值，上下边框是Y值，手机正面到背面是Z值
左下角方向是XY的正值。手机背面是Z的正值





方向传感器
三个参数是围绕XYZ轴的旋转角度，values123，是ZXY

Z轴，手机平放在桌面，手机头部正对着北方的话，旋转角度是0，顺时针转360度

X值，是手机上下着旋转，就是X的旋转角度，竖起来背面对着自己的时候，是正值。值在180到-180之间变动

Y值，是手机左右着旋转。手机背面在左边，是正值，也是180到-180变动








***********************************************
GPS的使用：
LocationManager是一个系统服务类，是管理GPS的

创建实例化的方法：
LocationManager lm = (LocationManager)getSystemService(LOCATION_SERVICE)


提取Provider提供者对象的方法：

1，提取出设备上所有的provider名称
List<Provider> list = lm.getAllProviders();
  **此方法会返回所有privider的【名称】，生成一个list集合来存储它们。
    一般会有个三个provider。passive      gps       network
    这个方法基本没什么用处，也就是提供让看下手机上有什么provider。


2，单独提取指定的LocationProvider位置提供者。
LocationProvider provider = lm.getProvider(LocationManager.GPS_PROVIDER)
  **用getProvider方法，传入静态变量，会返回一个LocationProvider位置提供者对象
    静态变量也是那三个的大写名称。
    这个更是没什么用处的方法


3，提取设置上，现在可用的所有provider名称
List<Provider> list = lm.getProviders(true);
  **传入一个布尔值，指定是否在工作可用的provider。true就是返回所有在工作的    provider。然后自己可以再判定list集合中，是否有gps或者network。也可以用静    态变量名LocationManager.GPS_PROVIDER来判断
    这个才是常用的方法：


4，还可以按照一定的过滤条件，来提取符合条件的所有provider；
List<Provider> list = lm.getProviders(条件，是否可用true);




最重要的一步。
Location location = lm.getLastKnownLocation(provider的名称)
  **提取上一次最后缓存的位置信息，传入provider名称。就是这个provider对象上次    最后缓存的信息，返回一个位置信息。最后会返回一个Location位置对象。


location.getLongitude() 		获取当前位置的经度
location.getLatitude()			获取当前位置的纬度
location.getAltitude()			获取当前位置的海拔
location.getSpeed()			获取当前位置的速度
location.getBearing()			获取当前位置的方向



设置位置移动的监听器
lm.requestLocationUpdates(provider名称，毫秒，米数，LocationListener监听器)
  **第一个参数是，要监听哪个provider。
    第二个参数是，每隔多少毫米监听一次
    第三个参数是，位置变化多少米的时候，调用监听器。并且把新的location传进去
    第四个监听器，可以用各种方法，写这个监听器。这个监听器有四个方法
        onLocationChanged位置变化时候，传入检测到的最新的位置信息。
        onProviderDisabled这个设备被用户关闭的时候会调用，传入的是provider名
        onProviderEnabled设备被用户开启的时候会调用。


不用的时候要尽快关闭监听器，毕竟开了监听器就会不断的检测数据了。
removeUpdates（监听器对象）



获取当前位置是需要权限的：
ACCESS_FINE_LOCATION        

用网络定位的，还需要一个使用网络的权限
ACCESS_NETWORK_STATE               【系统权限】获取网络的权限



***************************

Location的一个静态方法：测量两个经纬度之间的距离
Location.distanceBetween(起点纬度，起点经度，终点纬度，终点经度，float数组)
  **需要新建一个float数组来接收结果。






ViewPager的页头标题下划线滑动效果

使用ViewPager，不用标题栏。
自己新建一个布局当做标题栏

1.怎么设置下划线的长度，为标题的几分之一呢。比如4个标题，那么下划线就占4分之一。
方法：先获取屏幕的宽度，然后在代码中动态设置下划线长度为，屏幕宽度除以几

2.重点，怎么设置Viewpage滑动的时候，下划线也能实时滑动呢
方法：滑动的同时，实时设置下划线的偏移量(leftMargin离左边的距离)。
      怎么设置呢。在ViewPager的监听器中，onPagerScrolled方法中，页面滑动时，        会自动传进去当前显示的页码和滑动的进度值。
      进度值*下划线宽度。就是滑动一点，换算成宽度值，就设置一点偏移量
      如果当前不是第一个页面，每次就加上不等个下划线宽度，当前页码*下划线宽度
      (int)(下划线宽度*进度值 + positon*进度值)   强转成int类型

注意点：动态设置控件的宽高等属性方法，button.getLayoutParams().width=XX
        这种方法只能设置宽高
        如果要设置偏移量，需要把getLayoutParams强转LinearLayout类型的
        LinearLayout.LayoutParams lp=button.getLayoutParams()就可以设置了








************************************************
普通的侧换菜单

使用自定义的HorizontalScrollView

先新建两个页面的XML布局文件，设置成充满父布局的
然后在主布局中，用include标签加入进来
新建一个HorizontalSrcollView，内部只能放一个子控件，那么就先放进去一个LinearLayout布局，然后在内部再放两个布局就可以了

新建类继承HorizontalScrollView，选择两个参数的构造方法就可以了

1.先在内部设置两个布局占的宽度。
  1.1在onMeasur方法中设置子控件的宽高值
  this.getChildAT(0)  就获取到内部控件的对象了，返回的是ob类型的，，需要新建  一个LinearLayout的对象来接收，然后强转。
  然后，LinearLayout.getChildAt（0）和1就获取到第一个和第二个布局的对象了，和  上边一样新建接收在强转。这里用ViewGroup对象
  
  1.2设置，在用getLayoutParams()设置宽度，内容页面就设置成屏幕宽度。侧换菜单  就设置成屏幕宽度减去一些

2.设置初始显示的页面
  在onLayout方法中，设置this.scrollTO(X值菜单页宽度，Y值0)

3.重点，设置滑动效果。
  重写onTouchEvent方法。判定手指离开时，现在滚动的X值是多少。getScrollX()获取   滚动的X值。然后判定是否大于第一个页面的一半。如果是的，也就是现第一个页面的  大部分内容都翻过去了。那就直接滚动到第二个页面去吧。反之就滚动到第一个页面

***最后这里如果还有this.scrollToX就是瞬间到达的，不好看。可以用this.smoothScrollTo(X,Y)是有个缓慢效果的。   需要return true才可以用。







关于自定义一个控件的XML属性，直接给控件，多出来一种属性。像宽高选中状态什么的

先在value文件夹下新建一个attr.xml,resources标签
<attr name=“rightPadding” format="dimension"> </attr>
先定义一个属性名称是rightPadding，接受值是个dimension类型的
  **接收值都是小写的。还可以多个类型，用|分开就可以了。
    refernce是资源类型

<declare-styleable name="自定义属性名">
    <attr name=“rightPadding” > </attr>
</declare-styleable>
给name这个控件指定一个新的属性。下面就是这个属性的名称


然后在布局页面，顶级布局控件那，给属性定义命名空间
xmlns：myAttr="http://schemas.android.com/apk/res/包名"、
然后就可以在xml中使用了：myAttr：名称=


如果使用自定义属性，那么自定义控件类就要改下构造方法了。
控件类会自动使用三个参数的构造方法。把所有的操作代码挪到这个构造方法中。
然后两个参数的，写成this（context，attrs，0）
一个参数的，写成this（context，null）



最重要的，就要提取XML中的所写的值了。在构造方法中：
TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.自定义属性名)
返回的是一个属性名称集合

可以循环遍历提取出来。a.getIndexCount() 返回长度
a.getIndex(0)  提取属性名称   可以用switch判定
case：R.styleable.名称_属性名
a.getDimensionPixelSize(a.getIndex(0),默认值)


a.recycle();最后一定要释放








*****************************
自定义控件的样式
在drawable文件夹下，新建一个xml，选择selector标签。标签内再写
item标签， 属性android:state_pressed="false"   android:drawable="@drawable/XXX"
**就是点击状态是false是，drawable是什么

item标签， 属性android:state_pressed="true"   android:drawable="XXX"
**就是点击状态是false是，drawable是什么

item内还可以选择其他控件的各种状态
**android：state_focused   焦点状态
  android：state_enabled   不可用状态
  
如果和state_enabled可用状态和点击状态，同在的情况下，写xml的时候，必须要把enabled写在最上面。



自定义样式的Shape的使用：
可以先设置自身属性，选择要什么形状：
android：shape = "oval"    	圆形或者椭圆，如果按钮大小是正方形就是圆形
                 "line"    	线状
                 "rectangele"	矩形  **如果不设置，默认就是这个
		 "ring"		环形
环形的独有属性：
在shape标签内设置
android:innerRadius		尺寸，内环的半径
android:thickness		尺寸。环的厚度

android:useLevel            boolean值，如果当做是LevelListDrawable使用时值为true，否则为false.  
使用ring形状，必须要设置上userLevel，设置为false。
android:innerRadiusRatio	浮点型，以环的宽度比率来表示内环半径
android:thicknessRatio		浮点型，以环的宽度比率来表示环的厚度
比如这样的：thcikRdatio = 3；
指的就是环的宽度，是View宽度的3分之1.
这个值就是View宽度的几分之1；

内环宽度和环的宽度，是和View宽度没有什么关系的。设置的时候，应该就是，先设置个指定宽度的内环，没有颜色的。然后内环外，开始设置个为指定宽度厚度的环，然后设置的颜色都是在这个环的厚度里面显示的。
如果环的厚度没有达到View的边缘，那么就空着，如果超出了那就超出。





然后内部的标签属性有5种：
corners				圆角半径
  **android：radius		四个角的半径
    topLeftRadius、topRightRadius、bottomLeftRadius、bottomRightRadius
    左上、右上、左下、右下的半径。dp

gradient			渐变
  **startColor  centerColor  endColor       开始、中间、最后的颜色
    type			
    渐变模式(linear线性渐变（默认），radial放射渐变，sweep扫描渐变)

    angle			渐变角度(只对线性渐变有效，必须45的倍数）
    gradientRadius		渐变半径，使用radial放射渐变的时候，必须设置这个才能使用。半径，也就是说，渐变会在这个半径距离内完成。
   比如一个按钮宽高300px，如果设置渐变半径为100px，那么100px外的颜色，就由最后的颜色来填充了；如果设置渐变半径为200px，那么到按钮边框的时候，渐变颜色还没有完成了呢。
    centerX   centerY	
    仅对扫描渐变有效，设置扫描渐变的中心点。值是0.0-1.0也就是百分比。默认0.5在正中间
    

padding				内边距
  **left  top  right  bottom    
    此功能适用于layer-list中的。
    这个参数是基本理解成裁剪画板的功能。设置方向距离后，就相当于把当前画板的指定位置，减去指定的距离。裁剪后的区域，供下一个item适用
    比如四个方向都为10dp，那么就相当于把画板一圈减去10dp，就是下一个item可绘制的区域。
    如果多层item都有设置padding，那么每层设置的，都相当于把当前可绘制的区域，再减去指定的距离。

size				大小
  **width  height		宽度和高度

solid				填充颜色
  **color			填充颜色

stroke				描边
  **widht			描边宽度
    color			描边颜色
    dashWidth			描边的每段虚线的长度(0就是直线。dp格式)
    dashGap			虚线之间的距离





************************
layer-list:
多层绘制    可以组合多种绘制效果。

一个item标签，是一层，第一个item是最下面的层。逐次往上。

item可以设置的属性，有四个方向，是指和画板的四个方向的距离值。
<item android:top="10dp" android:left="10dp">
还有个drawable属性，可以直接设置个图片资源。

item内可以放各种绘制效果，比如shape。






*****************************************************
HttpURLConnection的使用
发送Http请求有两种方式，一种是HttpURLConnection，一种是HttpClient

HttpURLConnection创建实例的方法：
URL url = new URL（"http://www.baidu.com"）
HttpURLConnection connection = (HttpURLConnection)url.openConnection();
  **使用url的openConnection方法，然后强转就可以了。
    新建url对象的时候，网址最好先用一个字符串接收下，然后新建url对象时候，传入字符串。

然后设置此链接的请求方式：
一种是GET，也就是获取数据；一种是POST，也就是发送数据
connection.setRequestMethod("GET")		默认是get方式
  **后面参数用字符串引号，而且这两个参数都是大写


接下来可以设置一些链接的参数：
connection.setConnectionTimeout(5000)		设置链接超时时间，毫秒数
connection.setReadTimeout(5000)			设置读取超时时间，毫秒数


connection的一些方法：
connection.getResponseCode()		获取请求结果码
  200就是请求正常
connection.getContentLenght()		返回数据长度
connection.setRequstProperty("Range","bytes="+100+"-"+200)
  此方法，用于设置一些服务器的请求参数
  Range就是设置要读取数据的，第多少个字节，到第多少个字节
  如果设置了，部分下载，返回码会是206
connection.setDoOutput(true);  		设置是否需要Output，默认是false；
connection.setDoInput(true);		设置是否需要Input，默认是true；
 



最后调用getInputStream()就可以获取服务器的输入流
getInputStraem（）方法，会自动调用connect（）方法的。
InputStream in = connection.getInputStream()


然后把输入流转换成Reader流，方便读。就可以读出数据了。
实例化构造方法的时候，设置编码为GBK


链接关闭的方法：
connetion.disconnection()


打开网页的时候，是需要是一个Internet权限的
INTERNET      






*********************
如果是POST的话，这个方法改成POST参数就可以了
connection.setRequestMethod("POST")

然后connection.getOutputStream()获取到一个输出流，转成一个DataOutputStream.
然后写入数据。数据要以键值对方式写入，每条数据之间用&分开。

DataOutputStream out = new DataOutputStream(connection.getOutputStream());
out.writeBytes("username=admin&password=123456");





****************************

各种设置参数，必须要在connect（）链接方法前完成。
无论是post或者get，http请求都是在getInputStream（）方法那才发出去的。
post的时候，outputStream（）写入方法，必须要在getInputStream（）方法前完成。
其实outputStream方法，也算是设置参数呢，设置传输值。所以当然要在发出请求前设置了。
最后设置个链接超时的设置。





********************

发起Http请求需要在子线程内，主线程不能发起Http请求。
如果建立子线程，最好在主程序中建立，不要在Http请求工具类中建立。
然后把接收返回值的语句，放在子线程中。
  **如果把子线程放在工具类中，然后接收返回值的语句放在主线程，
    就会造成，执行到接收返回的语句时，跳到工具类后，只是新建了个子线程，然后句跳出返回了，那么返回的结果就是个空了。
    这种情况，可以不使用返回值了，使用个接口回调就行了，得到结果后，调用主程序的接口方法，来传递数据。然后主程序的接口方法再处理数据。






Post和Get的区别：
Get就相当于是把传输的参数，放在了网址中，然后和网址组合成一个新的网址。
比如http:www.baidu.com?name=xiaoming&age=18
网址后先加？问号，然后后面就是键值对，两个键值对之间，加&。

Post的方法，是把
















***************************************


HttpClient的使用

Android自带HttpClient是4.1版本的，使用方法：
HttpClient的实例创建方法：
HttpClient httpClient = new DefaultHttpClient();
httpClient.getParams.setParameter(CoreConnectionPNames.SO_TIMEOUT,2000);
httpClient.getParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT,2000);



3.X的版本使用方法：
HttpClient client = new HttpClient();
设置连接超时方法：
HttpConnectionManager manager = client.getHttpConnectionManager();
manager.getParams.setConnectionTimeout(3000);
manager.getParams.setSoTimeout(3000)


4.3版本的使用方法：
CloseableHttpClient client = Http.createDefault();
RequestConfig config = RequestCofig.cutom.setSocketTimeout(1000).setConnecTimeout(1000).build(); 
httpGet.setConfig(config);


ConnectionTimeout(1000)		网络连接超时
SoTimeout(1000)			读取超时



然后选择是GET还是POST操作：
如果是GET操作，就要创建一个HttpGet对象：
HttpGet httpGet = new HttpGet("http://www.baidu.com")


然后用httpClient执行这个操作：
httpClient.execute(httpGet);           执行一个操作


执行execute后，会返回一个结果HttpResponse对象。服务器返回的信息就在这里面了。
HttpResponse httpResponse = httpClient.execute(httpGet)


接下来要先判断下请求和响应是否成功：
httpResponse.getStatusLine().getStatusCode()      获取到状态码
if是否等于200，是200的话，就是成功了。就可以取内部信息了
   **400    请求有语法错误，服务器不能理解
     401    请求未经授权
     403    服务器收到请求，但是拒绝提供服务
     404    请求资源不存在
     500    服务器发生错误
     503    服务器当前不能处理操作，过会或许可以




*******************
如果是POST操作的话，新建一个HttpPost后，还要在HttpPost对象中写入数据：
需要先新建一个List集合，泛型为NameValuePair来add存放数据。
然后创建实例化一个UrlEncodedFormEntity的对象，用集合来构造创建
最后，用HttpPost的setEntity(entity)方法设置数据

HttpPost httpPost = new HttpPost("http://www.baidu.com")
List<NameValuePair> list = new ArrayList<NameValuePair>()
list.add(new BasicNameValuePair("userName","admin"))
UrlEncodedFromEntity entity = new UrlEncodedFromEntity(list,"utf-8")
httpPost.setEntity(entity);

httpClient.execute(httpPost);







*********************************************************
用Pull方式解析XML

先得到一个XmlPullParserFactory解析工厂的实例对象
可以用它的一个静态方法获得。
XmlPullParserFactory factory = XmlPullParserFactory.newInstance();

然后用这个解析工厂对象的newPullParser()方法获得一个解析对象
XmlPullParser xmlPullParser = factory.newPullParser();

然后把从服务器回应对象中提取的字符串信息，先新建一个StringReader流来构造，最后把String流设置到解析对象中
xmlPullParser.setInput(new StringReader(response))



第一次解析先把游标设置到第一位，直接getEventType(),就返回当前位置的节点类型。
然后可以用一个while循环，设置条件只要不是文档结束，就对当前节点进行操作。
当前节点操作完毕后，就用xmlPullParser.next()方法，返回得到下一个节点的类型，并且把游标移动到下一个节点。

第一次，先获得当前位置的节点类型
int eventType = xmlPullParser.getEventType();
  **节点就相当于是一个游标。getEventType会返回当前位置上的节点类型
    节点类型是有五种的： 
    XmlPullParser.START_DOCUMENT	文档开始	
    XmlPullParser.END_DOCUMENT		文档结束
    XmlPullParser.START_TAG		标签的开始
    XmlPullParser.END_TAG		标签的结束
    XmlPullParser.TEXT			内容




【关于节点的划分：
如果是个标签，那就是一个节点；然后根据有没有斜杠，划分是标签开始还是标签结束
如果两个标签之间有东西，这也是一个节点。那就是内容类型的】

在Pull方式中，两个标签之间的内容，不论是多少行，就只算作一个内容类型节点。
读取的顺序，就是这样一个节点一个节点的读下去的。




如果节点类型是标签开始，或者结束，想获取标签内的名称：
xmlPullParser.getName()
获取标签内的属性值的方法：
String str = xmlPullParser.getAttributeValue(null,属性名)



如果节点类型是TEXT内容，那么就不能用getName()了，获取内容就用：
xmlPullParser.getText();


一般获取内容的方法是这样的，先确定当前的节点类型是个开始标签，然后getName()获取标签名称，然后判断标签名是不是自己需要的名称。
如果是，那么就获取下一个节点的Text内容。开始标签后面，肯定就是内容了，直接使用NextText()就获取到了。







*********************************************
SAX方式解析XML

SAX方式需要新建一个类，继承DefaultHandler，然后重写5个方法；
startDocument()			节点是文档开始的时候调用
startElement()			节点是标签开始的时候调用
characters()			节点是内容的时候调用
endDoucuments()			节点是文档结束的时候调用
endElement()			节点是标签结束的时候调用

用法基本一样，还是根据标签名称，然后获取后面的内容；

标签开始和标签结束的方法，都有个传入参数，qName也就是当前标签的名称。
还有个attributes参数，这个是标签属性的集合。
有几个常用方法，可以提取属性名和属性值。
attributes.getLength()		返回集合的长度 **可以配合for做循环遍历
attributes.getQName(1)		返回指定位置的属性名称
attributes.getValue(1或者名称)	返回根据位置或者属性名得到的属性值



内容方法的传入参数，是个char数组，也就是存放的内容信息。后面是当前内容的开始位置，和长度。这种参数可以用new String(数组，开始位置，长度)转换成字符串



SAX方式，对于节点的划分是有些不一样的。
内容类型这块，是一行算作一个内容类型节点的。所以换行和空格是两个内容节点


如果用先确定开始标签名称，然后读取后面的内容。这样的方式解析，到下一个开始标签之前，会有个三个内容节点。
所以可以每个内容节点，都保存下内容数据。然后判定结束标签名称，来最终保存内容数据。


SAX方法的实际写法：
还是先得到一个SAX解析工厂SAXParserFactory对象
SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();

然后用解析工厂对象，再new出来一个解析对象
SAXParser saxParse = saxParserFactory.newSAXParser();

然后解析对象再get出来一个XML流XMLReader对象
XMLReader xmlReader = saxParser.getXMLReader();

然后给xmlReader对象，设置一个解析器ContentHandler
xmlReader.setContentHandler(继承DefaultHandler类的对象)

最后用xmlReader对象的解析方法，开始解析
xmlReader.parser(InputSource对象) **可以是个inputSource流，也可以是文件地址
新建一个InputSource对象，用一个新建StringReader对象来构造
StringReader对象用网页返回的字符串来构造








******************************************
DOM方式解析：

使用方式：先生成一个解析工厂对象
DocumentBuilderFactory domBF = DocumentBuilderFactory.newIntance()

然后用解析工厂对象，生成一个解析对象
DocumentBuilder domcmentBuilder = domBF.newDoucmentBuilder()

然后用解析对象的parse()解析方法来解析xml文件，生成一个文档对象
Doucment doc = domcmentBuilder.parse(new InputSource(new StringReader()))
  **这个文档对象，就相当于其他方法的文档开始和文档结束。
    然后可以解析这个文档的子节点了。



DOM的解析方式是树形解析的，先解析有多少个子节点，然后再对每个子节点去进行操作，获取子节点的名称。或者子节点的属性名和属性值，或者再解析其子节点。

子节点的分类；
一个完整标签(开始标签、内容、结束标签)，算作一个子节点的。
两个子节点之间的空格换行只算做一个子节点


可以用文档对象，生成所有子节点的集合，然后在用集合遍历子节点
NodeList nodeList = doc.getChildNodes()
也可以根据指定标签名称，生成子节点集合
NodeList nodeList = doc.getElementsByTagName()


佩戴for循环，做遍历。
nodeList.getLenght()			返回集合的长度
Node node = nodeList.item(1)		返回指定位置的节点对象

节点对象的几个方法：
node.getNodeName()			返回自身的节点名称
noed.getNodeValue()			返回自身的内容值*适用于标签属性
node.getNodeType()			返回自身的节点类型
     **节点类型有几个静态常量
       Node.ElEMENT_NODE		标签类型
       Node.TEXT_NODE			文本类型
       Node.ATTRIBUT_NODE		标签属性类型
       Node.DOCUMENT_NODE		文档类型

for循环内，做判断，如果节点对象，是标签类型。就获取标签名称。
还可以往节点内再做解析：
NameNodeMap attrs = node.getAttributes()	返回标签的所有属性集合
NodeList nodeList2 = node.getChildNodes()	返回标签的子节点集合

然后再判定集合长度是不是0，在用节点对象的方法，取出名称和值

关于取出TEXT文本类型的值。
1，可以用标签类型节点对象的一个方法
node.getTextContent()			返回的是次标签下的所有文本内容
2，可以用文本类型节点对象的一个方法：
node.getNodeValue()			返回文本的内容


标签类型的节点对象还有一些方法：
node.hasAttrbutes()			返回是否有属性
node.hasChildNodes()			返回是否有子节点
node.getFirstNode()			返回子节点下的第一个节点



    



**********************************************
JSON数据的解析
一条记录中，属性和属性值中间用：冒号分开；两条属性之间用逗号分开；

用JSONObject方式解析
大括号是表示对象。中括号表示数组。

json.getString("name")		方法参数是key名称，返回对应key的Strig值。
json.getInt/long/double/boolean	同上的使用都一样的。
json.getJsonArray/JsonObject(key)	查找对应key名的JsonArray和JsonObject

Interator<String> iterator = json.keys();
keys方法会返回一个包含所有key的、String泛型的迭代器Interator



如果最外层是个中括号数组，就这样操作：
JSONArray jsonArray = new JSONArray(json内容的字符串)
  **会返回一个JSONArray数组的对象
可以用jsonArray的lenght()方法，返回记录条数。配合for循环遍历

JSONObject jsonObject = jsonArray.getJSONObject(i)  
  **返回第i条的对象记录。然后就可以用JSONObject对象的方式处理了。


如果最外层是个大括号对象的话，就这样操作：
JSONObjec jsonObject = new JSONObject(json内容的字符串)
String str = jsonObjcet.getString("id")
用getXX各种类型的方法，输入键名，就可以得到对应的值了。
也可以getJSONArray(""),返回一个JSONArray数组的对象。







JSON数据的写入：
最外层如果是数组，就新建一个空的数组对象；如果是对象，新建一个空对象的对象
然后再添加数据进去。

JSONObject jsonObject = new JSONObject();
jsonObject.put("id",1);
对象用put(键值对)的方式添加。

JSONArray jsonArray = new JSONArray()
jsonArray.put(jsonObject);
数组用put(对象)的方式添加

就这样逐层次的添加。如果一条记录，有很多的层次，就从最里面一层一层的创建添加




**************************************
GSON方式解析：
新建一个GSON对象，然后用解析方法，会自动把解析数据，存入到一个类中。
新建一个类，设置几个属性的变量名。
GSON gson = new GSON();
APP app = gson.fromJson(json内容字符串，存入的类.class)
  **如果只有一条数据，就可以这样，生成一个指定类的对象
    比如json有多个属性，而类就只有两个属性，这样不会报错，那这样就只会把两个属性赋值过去。

如果是多条数据,这样操作，就会生成对象集合
List<APP> appList = gson.fromJson(json内容字符串，new TypeToken<List<APP>>(){}.getType())

然后遍历一遍，来取出他们的值。










*******************************************************
图片处理Bitmap

Bitmap的实例化，也是加载一个图片，然后生成这个图片对象，实例化是用一个静态方法来构建的
Bitmap bitmap = BitmapFactory.decodeXXX

docedeFile（file对象.getAbsolutePath()）  
   **从一个file对象中加载；但是注意一定要file的绝对路径。

docedResource（this.getResource,R.drawable.XX）
   **从项目资源中加载。

docedByteArray（Byte数组，开始位置，长度）
   **从一个byte数组中加载，从开始位置加载，总长度是长度。

docedStream（InputStream对象）
   **从一个InputStream输入流中加载。

   **构建的时候，输入的地址可以为空。如果为空，不会报错，只是不会加载出来内容

构建的时候，尽量用docodeStream（）方法，一个参数的这个更效率，而且图片不会被缩放。
drawable文件夹下，也可以使用stream流的方式：
InputStream in = getResource().openRawResource(R.drawable.XXX);

ImageView控件，设置图片的时候，setImageResource也会根据文件夹不同而缩放图片的。
decode方法挺耗时间的。

bitmap.getByteCount();		返回图片占用的字节数，B


从bitmap中生成一个bitmap，图片的剪切
Bitmap newBitmap = Bitmap.create(src,x,y,width,height)
从src原有图片中，的XY点那，截取图片，截取指定width宽和指定height高，生成一个新的bitmap

Bitmap.createBitmap(width,height,Config)
创建一个空的bitmap，指定宽高，Config是图片的类型配置，可以用静态参数Config.ARGB_8888,也就是32位RGB色


Bitmap.createBitmap(int[],widht,height,Config)
从一个像素点集合中创建一个bitmap。
int[]就是一个像素点集合，widht，height宽高，Config图片类型


 bmp.recycle()   释放图片资源和内存。


保存图片到本地文件
bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream)
第一个参数是保存的格式，用静态变量
第二个是压缩率，要原图的百分之多少，100就是完全，50就是百分之五十
第三个保存的输入流ouputStream，先创建一个文件的outputStream


bitmap的大小计算方法，就是像素点乘以4。
宽乘以高，就得出所有的像素点。然后再乘以4就是所占用的Byte。
所以一般来说，从文件中，读取成bitmap，一般来说，bitmap的体积肯定是比文件的体积大的。

然后保存到本地的时候，如果用100的质量，新文件的体积会比原文件的体积，大2~4倍左右。
如果用95的质量，一般来说体积就和原本的基本一样了。
90的话，基本就是95的一般，也就是原体积的一半了，90之后，再逐次降低质量，体积一般就是递减一点点而已、

把图片压缩到，保存在原路径上：
保存到一个新建的文件中，	170秒
比覆盖保存在一个旧文件上快。	200秒
覆盖保存，比删除原旧文件，再保存到旧文件路径上快。	250秒








读取bitmap所有的像素点。
bitmap.getPixels(存储数组，起点，一行的数量，X,Y，widht，height)
  存储数组	就是用来存储像素点的数组，需要新建一个，大小和图片像素点数一样。
  起点		就是从第几个读，一般用0
  一行的数量	是一行存储多少个值，
  XY		就是第一个点的XY值，
  width		就是一行读取多个点，
  height	就是读取多少行。

同样也有setPixels方法，参数一样的，可以给一个【空的】bitmap设置上像素点。






获得缩略图的方法：

实例化bitmap的时候，构造参数中，可以加入一个options，来设置实例化的参数：
需要先实例化一个Options对象，来设置各种参数：
Opints options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
  **是否只加载资源的信息。
    设置后，不会加载图片本身不划分内存。只会获取图片的宽高，给options用。


然后把options用于实例化bitmap对象后，options就含有图片的宽高信息了
options.outWidth     options.outHeight      
然后把宽高除以缩略图目标的宽度，就得到缩小倍数，然后对比下，找到最小的那个倍数。以防万一，可以加个判断，是否小于1；


options.inSampleSize=2;
  **设置缩放的倍数。这个数值，只能是2的n次幂，也就是多个2相乘的数，比如2,4,8,16.其实就是一张图每次缩小一半。
    如果是传入的倍数，不是2的n次幂，比如2.几倍，不到4，那实际上源码里就会选2作为缩小倍数。
    

然后把options的inJustDecodeBounds设置为false；
再把options用于实例化Bitmap，生成的bitmap就是缩放一定倍数的图片。

    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height > reqHeight || width > reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        while ((halfHeight / inSampleSize) > reqHeight
                && (halfWidth / inSampleSize) > reqWidth) {
            inSampleSize *= 2;
        }
    }
这段代码的效果，得出的宽高，是肯定比要求的宽高低的。
如果直接使用，目标宽高除以原始宽高得出的缩放比率，这样的话，最终使用的比率，总是小于自身的2的n次幂的。那最终得到的宽高，也总是比要求的宽高，高一些的。






Bitmap.createScaleBitmap(src,宽，高，布尔值)
使用src资源图片bitmap，缩放到指定的宽高，这个算是强制拉伸的效果吧，不管宽高是什么比例，都直接拉伸到缩放的指定宽高。
布尔值，是否使用filter，如果是放大，可以清晰些。

如果使用这种方法的话，可以先算好原始资源，经过一定比例，缩小后的宽高值，然后再使用这个方法就可以了。
这个方法，可以得到准确大小，但是这个方法，需要先加载一次原图的哦。






还可以使用ThumbnailUtils工具类的一个extractThumbnail方法，直接生成一个缩略图

Bitmap bitmap = ThumbnailUtils.extractThumbnail
   (资源bitmap，width宽度，height高度，ThumbnailUtils.OPTIONS_RECYCLE_INPUT)
最后一个参数，就是生成后，释放资源bitmap。

这个是实现的截取功能。有点类似ImageView的ScaleType里面的centerCrop。
会把图片长宽中最窄的，缩放到指定的尺寸；然后把另一个长度，截取到指定的尺寸。

*速度挺快的。大概13秒左右








***************************************
异步任务AsyncTask
AsyncTask是一个抽象类，是用于被继承的

而且是需要指定三个泛型的
第一个是：类中要用的传进来的参数类型
第二个是：任务执行中，返回进度值的类型
第三个是：任务完成后，返回结果的类型
如果不需要参数的话，就传入大写的Void

几个常用的方法：
doInBackground		会自动重写的，这个就是用来操作任务的
onPreExecute		执行任务前，会调用的。
onPostExecute		dolnBackground完成后调用。并且会接受传回来的值
onProgressUpdata	执行任务中，会自动返回任务进度值




创建实例化的方法：
AsyncDemo async = new AsyncDemo();
async.execute(类的第一个泛型类型参数);   这样就是运行Async了


dolnBackground方法中，会接收到一个数组，来存放所有的参数。如果就只有一个参数，取出第一个参数就行了。比如：
Strinhg str = arg0[0];        arg0就是那个数组，取第一个就行了
方法中，任务执行完毕了，是要返回一个，第三个泛型类型的参数的。
返回给onPostExecute方法。

onPostExecute方法是在主线程中的。是用于接收doln..处理的结果，然后把结果更新在UI上的。
也是一样先取出数组中的参数。然后操作就可以了

onProgressUpdata是用于接收，doln..在运行中途，使用publishProgress(Progress...)方法传出来的数据，然后也可以直接更新在UI上。

doIn是运行在子线程中的。其他的方法都是运行在UI线程上的。


Async是一个独立线程的，在Activity销毁后，自身不会销毁的。如果退出后又进入，然后第二次调用这个任务，会等待第一个任务完成后才会开始。

这时候可以在onPause方法中，给async对象设置个取消标识。然后在dolnBackground和onProgressUpdata方法中设置个判断语句，如果是取消状态，就跳出。
这个Activity失去焦点的时候，async的线程也会自动结束了
if(async!=null && async.getStatus()==async.getStatus.RUNING){
   async.cancel(true)}

在判断语句中，可以直接用
if（isCancelled）    是否是取消状态



必须在UI主线程中创建调用Async的方法
只能调用一次，不能重复调用


*********************************************
ListView的图片异步加载：
因为加载网络图片，还要先从网络上下载，所以比较耗时间，总不能一直在哪里等待下载图片吧，那样后面的所有内容都要等待加载了。也不能做别的操作了。

所以在适配器的getView方法中，先只加载item中的文字内容，至于图片就开启一个子线程，就跳过去。给子线程传入当前item视图的img控件和图片地址，然后去下载图片，下载好后，就加载到img控件中。
这样就会一边生成很多item，一边下载图片，不耽误。



*****************************

在ListView中，如果用ViewHolder方式，加载数据。每一项的ItemView就会被复用，
这样图片下载好后，去加载的时候，就会加载错位置了。

比如，一号条目开启了一个子线程，下载后图片后，准备加载到img控件。可是现在img控件在被8号条目用，那这样一号的图片，就显示在8号上了。

为了解决这个问题：
每个条目用的时候，都给img控件加上个使用者身份标识，比如图片地址；
然后下载好准备加载的时候，检查下现在img控件的使用者身份是不是自己。如果现在是别人使用了，就不要再加载了。



******************************

ListView每次滚动的时候，都要重新下载一次图片，这样也太耗流量了。之前下载好的也被浪费了。
这时候可以把第一次下载的图片，直接保存到本地，下次直接从本地加载图片。
另外也可以使用LrcCache来保存之前下载好的图片，这样是保存在系统内存中的。

Lru缓存的使用：
创建实例化：
LruCache<String,Bitmap> mCaches = new LruCache<String,Bitmap>(多大内存空间)；
  **类似HashMap，是用Key和Value存储使用的，需要指定Key和Value的泛型
    构造方法，是有参的，需要传入一个int数值，用于指定多大的内存空间
获取本程序系统分配的最大内存空间：
int maxM = Runtime.getRuntime().maxMemory（）

另外还需要重写一个sizeOf方法，这个方法是用于每次存储内容的时候调用，返回要分配多大的空间，所以要手动输入。这个方法会传入Key和Value，然后用return Value的大小就可以了。

存储和读取，都是和HashMap一样的，put（k,v）  get(key)



******************************
ListView的滚动优化：滚动时，不下载网络图片。滚动停止，才下载当前要显示的几个

在快速滚动的时候，ListView是会不停的给每个item加载图片，如果没有下载过的还要去下载，可是滚动的过程中，被快速滚动过去的item根本不会看的，所以根本不用给它加载图片的，还给它去下载图片的话，就比较浪费性能和流量了。

所以在适配器中，添加一个ListView的滚动监听器接口，然后在构造方法中，要求传递进来ListView，而且给ListView添加上监听器this。
然后在监听器方法中设定，只有滚动状态为停止的时候，执行一个方法：给当前显示的N个Item中，没有图片的去下载图片的方法。(滚动加载的时候，也是给加载图片的，会检查下如果有下载过的缓存，就加载图片，如果没有缓存，是不会去下载图片的。)


第一：怎样获取当前显示的N条Item，的图片地址集合：
先把所有的图片地址，存储到一个List集合中
然后在滚动监听器中，得到当前显示的第一个item的位置信息，和显示数量。然后到了加载图片的方法中，就可以得到当前显示的几条item的图片地址了。

第二：怎么得到img控件呢：
可以使用mListView.findViewWithTag（）得到一个img控件，滚动的时候，每个item都会给img设置了一个url的Tag的。
就是查找mListView这个对象，里面有这个Tag的控件，然后强制生成一个ImageView，加载图片。


第二项重点，要在滚动的时候，把下载任务给取消掉。
可以在下载图片的线程中，在开始和要加载图片的地方设置个flag，为真才执行。如果滚动了，就把flag设置为假，那么就不会再去加载了。
为了谨慎，加载的时候，可以再加个判断，如果bitmap不为空，就是下载成功了，而且查找得到的ImageView不为空，因为滚动后，这个Tag就会被别的给覆盖了，也就查不到返回不了img控件了。
都不为空了，才去加载。










********************************************
Context是掌管全局的资源使用的。
Activity是继承Context的，所有每一个Activity的对象都是context

Application可以供各个Activity之间共享数据
新建一个类，继承Application，然后设置一个变量，set和get方法。

在Activity中，(App)getApplicationContext(),就可以获得类的对象了。


随时获取Context，先在这个类中，创建一个静态Context对象，然后在onCreate方法中，用getApplicationContext()方法赋值给Context对象。
最后新建一个静态方法，return这个Context对象。






************************************************
TabHost的使用：
TabHost下面有个TabWidget，再下面会有个FrameLayout。
再下面就是几个布局文件了。也就是Tab的内容页面

TabHost和TabWidget和FrameLayout的ID名都是@android:id/XX

绑定控件ID的方法：
先绑定TabHost的对象，find的时候，ID名需要这样写android.R.id.XX

绑定初始化后需要host.setup();
Tapspec tab1 = host.newTapSpec("tab名称")	会返回一个tabspec对象
tab1.setIndicator("标题")			设置tab页卡的标题名
    **还可以("标题名"，icon图标)，或者设置(View)进来
tab1.setContent(Intent或者布局id)		设置子tab的内容

最后host.addTab(tab1)	把子tab加载进来了





*************************************************
文本类控件都可以设置，文本改变监听器：
text.addTextChangedListener（new TextWatcher(){} )
有三个抽象方法：
onTextChanger（char，开始位置，before，长度）
  **char是现在文本框内的内容，新增的是从第几个开始的。新增总长度
    如果文本框是空的，char不是null也不是“”，而是Empty。
    可以用一个工具类的静态方法判定：
    TextUtils.isEmpty(char)         会返回布尔值是否为空    

afterTextChanger（Editable）
  **现在文本框内的Editable内容

onTextChanger和afterTextChanger，都是文本输入后的，现在文本框中的所有文字。不同的是，一个是char和统计；一个是Editable。

beforeTextChanged(char,开始位置，长度，after)
  **char是文本改变前的文本内容。比如文本框原本是1，输入个2后。这里的char就是1





******************************************************
在程序中使用照相机拍摄图片的方法：
设置个Intent跳转到照相app的页面就可以了。


Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE)
startActivityForResult(intent,1);
最简单的，这样就可以跳转到照相机了。


接收拍摄的照片的两种方法：
1、重写onActivitResult方法，在方法体内，可以根据请求码和结果码判断，
resultCode的结果码，一般有RESULT_OK成功和RESULT_CANCELED失败这两种。
如果是拍照成功，返回的就是RESULT_OK。
   在返回的Intent对象中，会包含一个bundle，bundle内有个key为“data”的obj数据，就是拍摄的照片。然后用个Bitmap接收就可以了。存储还是使用就再说了。
Bitmap bitmap = (Bitmap)data.getExtra().get("data");
这种返回到都是个缩略图的，没啥用


2、照相机拍了之后直接存储。
   在跳转前，给intent传入一个数据参数：
intent.putExtra(MediaStore.EXTRA_OUTPUT，Uri.formFile(path))
  **第一个参数是指图片存储的位置，后面需要是个Uri对象。
    Uri对象，可以用Uri类的静态方法Uri.fromFile(file对象)生成。
然后在onActivity方法中，判定下是否成功，然后就可以取出来使用了。

存储在系统相册中的方法：
先在系统相册中，插入一条图片信息，然后会返回一个这个图片uri的地址，然后使用uri参数就可以了。
新建一个ContentValues：
ContentValues values = new ContentValues（）
values.put(android.provider.MediaStore.Images.Media.TITLE,文件名)
Uri uri = getContentResolver（）.insert(MediaStore.Image.Media.EXTERNAL_CONTENT_URI,values)
这样就会返回一个uri对象了。
然后在使用ContentResolver，查询这个uri，得到游标，使用游标，提取数据，key是
“_date”得到的就是图片的存储地址。





跳转到选择图片页面：
intent = new Intent(Intent.ACTION_GET_CONTENT);
intent.setType("image/*");
然后使用startActivityForResult跳转就可以了。

在onActivityResult方法中，从intent中取出数据：
Uri uri = data.getData();	返回的是一个uri。选择的文件路径就在uri内。
一般使用：
String path = uri.getPath（）就可以取出来了。


















*****************************

使用照相机拍摄视频的方法：
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
startActivity(intent);

接收数据的方法：
在onActivityResult方法中，现在数据就不是直接存储在intent对象中了。
intent中存储的是一个uri。
然后查询这个uri，得到游标，从游标中，根据属性名“_data”查询结果。会得到一个视频的存储路径字符串。这样就可以加载视频或者其他
Uri uri = data.getDate();
Cursor c = getContentResolver().query(uri,null,null,null,null)
if(c.moveToFirst){
   String path = c.getString(c.getColumnIndex("_data"))
}


使用系统裁剪图片：
Intent intent = new intent（"com.android.camera.action.CROP"）
intent.setDataAndType(uri,"image/*")
  **设置数据和类型，uri，需要使用一个文件file类型包装成的uri。
    后面image/*,是指图片类型的裁剪

intent.putExtra("scale",true)
  **设置scale缩放属性，可以使用
intent.putExtra("crop"，true)	使用裁剪
intent.putExtra("aspectX",1)	X缩放比例1
intent.putExtra("aspectY",2)	Y缩放比例1
intent.putExtra("return_date",true)	返回数据，是的
intent.putExtra("outputX",150)	截取大小 
intent.putExtra(MediaStore.EXTRA_OUTPUT,uri)	保存地址

也是用startActivityForResult启动。
   在返回的Intent对象中，会包含一个bundle，bundle内有个key为“data”的obj数据，就是拍摄的照片。然后用个Bitmap接收就可以了。存储还是使用就再说了。
Bitmap bitmap = (Bitmap)data.getExtra().get("data");




*****************************
获取控件的坐标：
bt.getLeft()、getTop()获取的是控件的左上角的XY点的值
bt.getRight()、getBottom（）获取的是控件右下角的XY点的值；
getwidth（）、getheight（）	获取宽度和高度
  **这个值是指在父布局内的值，getLeft()，类似控件marginLeft()的距离，控件的边框到父布局的边框距离。
    而且这个值，需要布局加载完毕后，才能读取到的。在Activity的onCreate方法中是读取不到的。比如是加载完后，和程序交互的时候，才能读取到。也就是程序初始化的那些方法都是读不到的。



onMeasure方法
在加载的时候，设置布局宽高的方法。
做一些设置宽高的操作，就在这个方法内写
getleft之类的，不是需要在加载完毕的时候，才能获得的吗。但是在自定义控件的时候，在这个方法内，直接就可以获得到了。
这个方法在初始化控件的时候，会多次调用的，可以用个布尔值，来设置调用一次


onLayout方法
自定义ViewGroup的时候，或者ViewGroup的继承类，都有这个方法的
自定义的时候，是必须重写onLayout方法，手动设置子View的位置


onFinishInflate方式
是布局加载完毕后加载的方法。


onKeyDown(int, KeyEvent) 有按键按下后触发
onKeyUp(int, KeyEvent) 有按键按下后弹起时触发


onAttachedToWindow() 当view被附着到一个窗口时触发
onDetachedFromWindow() 当view离开附着的窗口时触发


getPaddingLeft()...
会返回当前布局，在XML中设置的PeddingLeft值

可变参数列表：
方法接受的参数，有可能会是3个，有可能会是4个，这时候就要用可变参数列表了。
在方法接受参数那写，类型...参数名就可以了。比如int...count
调用方法的时候，可以直接写多个参数，中间用逗号隔开，比如count1，count2，count3
也可以用数组的方式传入。
在方法中，用的时候，参数就是个数组了，完全按照数组的方式用就可以了，
比如count[0]就是第一个参数。


Math.min(a,b)  
会返回最小值

setMeasuredDimension(宽，高)
设置控件的宽高值；

bt.setColorFilter（0xff556600）
给控件设置一个滤镜，可以传入一个Color来使用，相当于在控件上层，设置了一个颜色。这个颜色一般需要设置下透明度。

如果用R.raw等等出错的时候，有可能是improt导包的时候，R文件导入错了

Collections.shuffle(list)
把list中的数据顺序，排序成乱序的。
也可以用sort排序，来制造乱序：
Collections.sort(list,new Comparator<泛型>)   
把list排序，按照Comparator对象的方法排序
  然后会重写Comparator的方法，传入两个泛型数据，用于比较。比较后最后返回一个int，返回正数表示大，返回负数表示小，返回0表示相等
  如果第一个大返回正数，就是升序，返回负数，就是降序。
  这时候可以return一个随机数是否比0.5大，如果大返回正的，如果小返回负数



布局内子控件的属性设置：
1、可以用btn.setLayoutParams(LayoutParams对象)
LayoutParams有多种，最基础的是：
LayoutParams lp = new LayoutParams(宽度，高度)     
只能设置宽高值，可以用数值，也可以用静态常量，包括内容和充满父布局的静态常量名

还有各个布局的LayoutParams，比如：
LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(宽度，高度)
然后还能再设置针对LinearLayout的特定属性
Margin四个方向的距离值，和weigth值
比如lp.topMargin = 10;

RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(宽度，高度)
可以设置一些RelativeLayout的特有属性，主要就是相当方向
用法：lp.addRule(规则，值)
规则是RelativeLayout的一些相对方向的属性名，用RL的静态常量
值就是真假，或者相当方向的控件的id
比如lp.addRult(RelativeLayout.ALIGN_PARENT_RIGHT,RelativeLayout.TRUE);
比如lp.addRult(RelativeLayout.BEBOW,image1.getID());
  **【给前一个控件设置id的时候，千万不要设置0，0是RL的静态变量值，意思是不使用这个设置。id数字，最后直接从30开始】
设置相对方向后，还可以再设置margin方向的距离，和LinearLayout的一样用法

静态常量属性名：和XML中的名称是相对应的
RelativeLayout.CENTER_HORIZONTAL   在父控件中水平居中
RelativeLayout.CENTER_VERTICAL   在父控件中垂直居中
RelativeLayout.CENTER_IN_PARENT  相对于父控件完全居中
RelativeLayout.ALIGN_PARENT_BOTTOM  紧贴父控件的下边缘
RelativeLayout.ALIGN_PARENT_TOP  紧贴父控件的上边缘
RelativeLayout.ALIGN_PARENT_LEFT 紧贴父控件的左边边缘
RelativeLayout.ALIGN_PARENT_RIGHT  紧贴父控件的右边缘
 
RelativeLayout.ABOVE  
RelativeLayout.BELOW 
RelativeLayout.LEFT_OF 
RelativeLayout.RIGHT_OF  
RelativeLayout.ALIGN_TOP 
RelativeLayout.ALIGN_BOTTOM  
RelativeLayout.ALIGN_LEFT  
RelativeLayout.ALIGN_RIGHT  
RelativeLayout.ALIGN_BASELINE   

2，也可以用bt.getLayoutParams()会返回一个基础的LayoutParams，然后直接设置LayoutParams的宽高就行了。
LayoutParams lp = bt.getLayoutParams()
lp.width=10;
如果想设置特定布局的属性，可以让用特定布局的LayoutParams来接收，强制下。然后在设置

3，也可以在父布局添加子控件的时候，再加上LayoutParams对象
linearLayout.addView(bt，lp对象)



static修饰的变量，在程序退出后，是不会被清空释放的。
如果做出修改后，退出程序再进入，再次使用变量，变量值是上次修改的值。


控件对象设置Tag，一般用来存储一条信息，也可以存储多个信息的，用key来分辨
bt.setTag("position1")
value是object类型的，也就是什么类型都可以。存进去就变成object，取出来的也就是Object类型的，需要强制成需要的类型

bt.setTag(key,value)
这里key必须是resource资源di，也就是R.string.XX这样的。一般的int数字是不行的
R.id.XX的手动创建方法：
在values-string.xml中，新建一个item标签，type属性，值选择id，name属性自己取。这样就可以在程序中使用R.id.（name）了。

也可以使用R.string.XX
就直接正常的创建一个string标签，有name和属性值。

getTage如果没有存储信息，返回的就是个null。





*************************************

GridLayout的使用：
类似表格的布局，可以设置行列，然后添加进去的view，会自动进行排列
rowCount		行数
columnCount		列数
但是宽高还是需要自己设置的，不会自动分配宽高的。




另外每个控件都可以使用post方法
bt.post(new Runnable(){}),这个方法会在Activity全部加载完后执行，可以用于获取控件的宽高值。






***************************************
使用框架开发
先把androidannotations-3.3.1的jar包放入到libs文件夹下；
然后新建一个文件夹，把androidannotations-ap-3.3.1放进去

然后右击项目属性，选择Java编译器―注释处理，勾选启用。
然后点击子选项，工厂路径，勾选启用，点击添加JAR，选择api的那个文件。


@EActivity
在Acitivity类上面，写@EActivity（R.layout.main）就是绑定布局了。
这个注释，其实相当于新建一个Activity类，把这些帮我给补全了。所以要在AndroidManifest文件中，把Activity的名称给改下，在名字后面加个_,其实这个就是新建的那个类的名称。


@ViewById
在创建控件对象的上面，写@ViewById（R.id.bt1）就是给这个控件绑定id了。另外也可以不写（R.id.bt1）,只是创建的控件对象名和XML中命名的一样就可以了。


@Click
在一个方法上面，写@Click（R.id.bt1）就是给R.id.bt1设置onclick监听器呢
 【切记，访问修饰符，都不能使用private，估计这个原理就是从这个读取数据，到新建那个类中的，如果是私有的就不能读取了】


@AfterViews
在一个方法上，写@AfterViews，这个方法会在绑定控件ID后执行，一般做于给控件初始化数据之类的。




********************************************************





颜色矩阵：
R:  R  G  B  A  0
G:  R  G  B  A  0
B:  R  G  B  A  0
A:  R  G  B  A  0
由一个四行五列的矩阵组成。
每一行是一个颜色，第一个是红色R，
每一行的四个参数，又是以一个RGBA组成，就是这个颜色的设置，最后一个是这个颜色的偏移量。



1  0  0  0  0
0  1  0  0  0
0  0  1  0  0
0  0  0  1  0
这个一样矩阵，正好保留R行的R参数，G行的G参数...

然后新建一个float数组，存储这20个数值。
然后再新建一个ColorMatrix，用这个数组来构造生成，就直接生成一个含有各个设置的ColorMatrix了。
ColorMatrix matrix = new ColorMatrix(float[])

在用paint的setColorFilter方法，构建一个ColorMatrixColorFilter就可以了
paint.setColorFilter(new ColorMatrixColorFilter(matrix))


读取一个bitmap的所有像素点，
先新建一个int类型数组集合，用来保存像素点，数组大小，就用biamap的宽乘高。
然后用bitmap的getPixels方法
bitmap.getPixels(存储数组，起点，一行的数量，X,Y，widht，height)
  存储数组，就是刚才创建的数字
  起点，就是从第几个读，一般用0
  一行的数量，是一行存储多少个值，
  XY就是第一个点的XY值，
  width就是一行读取多个点，
  height，就是读取多少行。

最后数组内，存储的就是每一个点的像素值，然后循环遍历，就可以取出每一个像素点。int a = Color.alpha(color)
int r = Color.red(color)
用Color的方法，就可以取出像素点中的，每一个颜色了。

一些经典的图片处理算法：
底片模式：
把每一个像素点的RGB值，取反，也就是减去255减去本身的值，就是底片模式，也就是颜色翻转了。
r = 255 - r;
g = 255 - g;
b = 255 - b;
用255减去本身的值，得到的新RGB值，用Color的静态方法argb就可以得到一个新的颜色值了
int color = Color.argb(a,r,g,b)



怀旧效果：
r1 = (int)(0.393 * r + 0.769 * g +0.189 * b)
g1 = (int)(0.349 * r + 0.686 * g +0.168 * b)
b1 = (int)(0.272 * r + 0.534 * g +0.131 * b)
每一个颜色，都要三个颜色做出些改变，然后融合成一个颜色。



浮雕效果：
需要使用上一个像素点的RGB值，所以循环的时候，从1开始吧，第一个就可以读取0位置上的像素点了。
r = (r - r1 + 127)
g = (g - g1 + 127)
b = (b - b1 + 127)
  最后，需要加下判断，是否大于255后者小于0，如果大于，就设置为255，如果小于就设置0


****************************************



Matrix图片变换：
矩阵
a  b  c
d  e  f
x  y  1


a、e是缩放大小，a是x轴长度也就是宽度，e是y轴长度也就是高度，默认是1，0就是没有了，改成2就是两倍。

c、f是位移，c是x轴移动的距离，f是y轴移动的距离，每加一是一个像素，比如100，就是移动100个像素。

b、d是错切，b如果是1，就是图片的底部向右移动扭曲一倍，如果是-1，就是向左边移动扭曲一倍。d如果是1，就是图片的右部向下移动扭曲一倍，如果是-1，就是向上移动扭曲一倍




使用方法：
新建一个float数组，长度为9，存储这9个数值。
然后新建一个Matrix对象，用setValues方法，加载这个数组
float [] values = new float[9];
Matrix matrix = new Matrix()
matrix.setValues(values)


矩阵，系统提供的有相关方法，不会手动的一个一个写的。
旋转：
matrix.setRotate(角度，中心X点，中心Y点)

移动：
matrix.setTranslate（x,y）  在自身的XY点，再加上多少个像素点距离

缩放：
matrix.setScale(x,y)     xy缩放的大小，1是正常，0是没有，2是两倍
   **如果是-1就是翻转了。
	还可以指定围绕的中心点，旋转。
matrix.setScale(x,y,x,y)
斜切：
matrix.setSkew(x,y)	xy斜切的数值，同上面


如果要组合设置几个效果，后面的效果需要用加post的方法：
matrix.postScale();
matrix.postTranslate();
组合效果，统一效果也可以累加设置的，不停的用post，最后会把数值给累加起来的。


提前现有设置某一个效果的值：
新建一个长度为9的float数组，然后使用matrix.getValues（数组），现在所有的设置值，就传到数组内了。然后可以使用Matrix的常量，来提取指定位置上的数值。
float[] values = new float[9];
matrix.getValues(values);
values[Matrix.MSCALE_X];


使用方法1：
canvas.drawBitmap(scrBitmap,matrix,paint)
canvas画的图片，就是用矩阵修改过的。


使用方法2：
ImageView控件，使用matrix，来修改图片的形状。
img.setImageMatrix(matirx)

使用方法3：
根据自身的设置信息，把传输进去的RectF对象，绘制成一个新的RectF区域信息。
matrix.postScale()
matrix.postTranslate()
............设置很多信息后；
新建一个区域对象，RectF rectF = new RectF（0,0,650,300）
matrix.mapRect(rectF);		
相当于是用自身设置的各种参数，来测量这个RectF矩阵，然后测量后，会把改变后的矩阵信息记录到RectF中，也就是宽高、和父控件的四个方向的距离。

rectF.with()	这时候就是改变形状后的，新的区域信息了。
【可以用在，ImageView控件设置Matrix后，获取图片资源的位置信息。设置RectF初始值的时候，要设置成图片的原始宽高。】



***********************
<application android:hardwareAccelerated="true" ...>  软件全局禁用硬件加速
<activity android:hardwareAccelerated="false" ...>   Activity禁用硬件加速
setLayerType（LAYER_TYPE_SOFTWARE,null）    view禁用硬件加速













drawBitmapMesh图片变形功能：
类似给图片画上网格，然后记录每个网格点的XY坐标。然后通过改变网格XY点的坐标，让图片变形

准备画多少个点，就让图片的宽或高除以个数，然后记录每个点的XY坐标值。

然后根据算法，改变这些点的位置，就可以让图片变形

canvas.drawBitmapMesh(bitmapp,x轴网格数，y轴网格数，记录网格点的数组，从第几个点开始，改变color的数组，color数组开始的位置，画笔)







********************************
多点触摸:

获取触摸点的个数
int count = event.getPointerCount()

获取多个触摸点的坐标值
event.getX(2)
getX的方法，是可以传入数值的，传入是几，就是获取第几个触摸点的坐标值

获取两个点的距离：
float x = x1-x2
float y = y1-x2
Math.sqrt(x*x+y*y)
第一个点的x减去第二个点的x，得出新x
第一个点的y减去第二个点的y，得出新y
x的2次方，加上y的2次方，然后再把这个值，开方，就是距离值。





*************************************
Camera的使用：
需要在SurfaceView中使用，
新建实例化的方式：
Camera mCamera = Camera.open(）

然后设置要显示的地方：
mCamera.setPreviewDisplay(getHolder())
 参数是一个surfaceView的holder

然后开始的方法：
mCamera.startPreview()	开始显示

最后结束的方法：
mCamera.stopPreview()	停止显示
mCamera.release()	释放硬件资源
  **退出的时候，一定要记得释放，不然系统的照相机就用不到了。

mCamera.setDisplayOrientation(90)	
  **设置显示方向，原本是下左、上右的显示方法，设置90，就是旋转90度。

拍照：
mCamare.takePicture(null,null,new PiceturCallback(){})
  **添加一个接口，接口内方法，会传入一个byte数据，就是拍摄的图片

获取所有支持的预览尺寸：
List<Size> list = mCamera.getParameters().getSupportPicturesSize()
Parameters parameters = mCamera.getParameters()
获取一个参数对象。
parameters.getSupportPicturesSize()	获取一个支持的图片大小List集合
parameters.setFlashMode(Parameters.FLASH_MODE_TORCH)
  **设置闪光灯的模式，手电筒模式


mCamera.setParameters(parameters)
  ***设置参数，必须在startPreview方法之后使用。






需要使用权限：CAMERA 		照相机权限
闪光灯权限：FLASHLIGHT	





*********************************
添加桌面快捷方式的权限：
INSTALL_SHORTCUT

删除桌面快捷方式的权限
UNINSTALL_SHORTCUT

查找桌面快捷方式的权限
READ_SETTTINGS


feature是用于在软件市场，筛选不符合硬件要求的手机的

程序的主题样式，在各个版本上是不一样的。用的AppBaseTheme，在values那定义了三个AppBaseTheme名称的样式的，会根据手机版本自动选择的


检测是否有闪光灯：
getPackageManager（）.hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH)
会返回一个布尔值，如果有，就是真，没有就是假









***************************
自定义ImageView：多点触摸图片
实现：View加载完毕的时候，调用一个方法。用于得到图片和修改图片显示方法

重写两个方法：
onAttachedToWindow（）		控件显示在窗口上的时候，调用的方法
onDetachedFromWindow（）	控件从窗口上消失的时候，调用的方法

在控件显示出来的时候，给控件添加一个，加载完成的监听器
getViewTreeObserver（）.addOnGlobalLayoutListener（new OnGlobalLayoutListener()）
或者让本类继承，都一样

在控件消失的时候，添加一个移除监听器的方法：
getViewTreeObserver（）.removeGlobalLayoutListener（同上）

然后在监听器接口的方法中，实现操作。这样，View加载完成的时候，就会执行这些代码了

手动操作ImageView中的图片缩放模式：
先在构造方式中，设置缩放模式为matrix矩阵模式，防止冲突。
ImageView的getDrawable()方法，会返回一个Drawable的对象。
Drawable drawable = getDrawable()
这个Drawable对象，就是img控件上，设置的资源，有可能是个图片，也有可能是xml类的图片效果。这样就可以操作这个图片了。

int width = drawable.getIntrinsicWidth（）；	
  **获取资源的原始宽度；高度也是一样

然后再获取控件的宽高值，让控件的宽高除以图片的宽高，找到缩放的最小比例。

然后新建一个matrix对象，设置图片移动，XY轴的移动数值是，控件的中间点XY，减去图片的中心点XY，就是图片要移动的偏移量。
把图片移动到中心点后，然后再设置缩放值，就用最小缩放比例，中心点呢，就用控件的中心点，围绕控件中心点缩放。

float minScale = Math.min(width/srcwidth，height/srcheight);
Matrix matrix = new Matrix（）；
matrix.postTranslate(width/2-dwidth/2, height/2-dheight/2);
matrix.postScale(initScale, initScale, width/2, height/2);
setImageMatrix(matrix);

然后设置onTouch触摸方法
新建一个ScaleGestureDetector缩放多点触摸对象，在构造方法中实例化的时候，需要一个上下文，一个监听器OnScaleGestureListener。实现其方法。
然后，在控件的onTouch方法中，把event传递给Scale触摸对象。mScaleGestureDetector.onTouchEvent(event);


然后在Scale多点触摸监听器的方法中，在onScaleBegin中，return true，让触摸事件传递下去，在onScale触摸中，事件中，使用：
float scaleFactor = arg0.getScaleFactor();
会获得本次缩放，是上次缩放的几倍比例吧。


然后接着使用首次加载时，创建的Matrix对象，再给它加上缩放属性。
matrix.postScale(scaleFactor)
setImageMatrix(matrix)
  **还可以加个判断值，有个最小缩放值，和最大缩放值，不能超过他们。
    先获取当前矩阵对象中的，已经设置的属性累加值，再乘以触摸产生的缩放值，然后判定看是否超过最大最小值。
获取当前值的方法：
float[] values = new float[9];
matrix.getValues(values);
values[Matrix.MSCALE_X];
新建一个空的9位单精度数组，然后get数组，把数组放进去。
然后这个数组，就保存了矩阵中的9个值。想去第几个，就用Matrix的静态常量，提取


现在这个matrix已经有三个属性了：
1、先把图片移动到控件的中心
2、用初始缩放比例，缩放图片；缩放中心点，用控件的中心点
3、按照手指触摸缩放的比例，再次缩放图片；缩放中心点，用触摸的中心点；
   **这样的话，图片的中心就不会在控件的中心点了。
     如果图片缩放到，图片宽高，都比控件宽高大的时候，就不会在意图片中心点了。
     关键是：图片的宽高，小于控件了，要再设置下，图片的中心点，在控件中心。

先要计算下图片的坐标点，看是否是超出控件了，也就是大于控件了：
查看经过矩阵变形过的图片，所占据的矩形位置信息：
Matrix matrix1=matrix;
RectF rectF = new RectF();
rectF.set(0, 0, dwidth, dheight);
matrix1.mapRect(rectF);
这样，从rectF中的left，right...就可以得出，图片的左右边和控件的左边的距离。还有图片的当前宽度。

加入图片的宽或者高，小于控件的宽或者高。
rectF.width<getWidth(),rectF.height<getHeight()
就把图片的中心点移动到控件的中心点。

控件半径，减去图片的半径，再减去一个现在图片和控件之间已经存在的距离，就是移动值
x = width / 2 - rectF.width() / 2- rectF.left;
y也是一样。

另外，如果图片的宽高都比控件宽高大的时候，在缩放途中。如果一直缩放图片的角落，以触摸点为中心放大，左右是按照比例缩放的，就有可能图片的边框，没有和控件边框对齐了。
那么，就检测，rectF.left>0也就是图片边框和控件边框有距离，那么就加上个偏差值
x = -rectF.left；
rectF.right<width,也就是图片的右边框搭配控件的左边框的距离，和控件的宽度不一样，那么就加上个偏差值：
x = width-rectF.right
高度也是一样的处理。

计算完后，再给矩阵matrix加上第四个属性，
4、计算偏差值，是否有白边和不在中心点。



触摸的时候，移动图片：
一个手指的话，就是计算，这次移动的点，到上次的点的距离，是否大于一个值，如果大于了，就是移动了。然后把这个移动的偏移量，设置成矩阵移动属性。

如果是多个手指的话，可以计算本次触摸的中心点，到上次触摸的中心点的距离。关于中心点，就是把多个触摸点的X或者Y，相加然后除以数量，就是中心点。

另外如果，当前图片缩放的尺寸，比控件的宽高小，就不让移动了。

还有关于移动距离的判断，可以使用系统的一个参数，判断移动的距离，是否判定成移动
int slop = ViewConfiguration.get(getContext()).getScaledTouchSlop();

还有，移动的途中，也要进行下白边的处理。也是用图片缩放的rectF，判定是否和控件边框有距离，如果有距离，就补上。。



BitmapDrawable drawable = (BitmapDrawable)imgView.getDrawable();
Bitmap bitmap = drawable.getBitmap();
从控件中提取bitmap出来


************************************
自定义View的保存状态，和恢复状态：
onSavaInstanceState方法，保存状态
在方法，新建一个Bundle对象，
新存储一个系统要保存的数据。
Bundle bundle = new Bundle（）
bundle.putParcelable("自定义key",super.onSavaInstanceState())
  **系统保存的数据是Parcelable类型的，所有要用putParcelable
    super.onSavaInstanceState()，就是调用系统的这个保存数据的方法
然后在保存自己用的数据,
最后return改成，返回bundle对象

onRestoreInstanceState()方法，恢复数据
把传入的数据，强转成一个bundle对象，
Bundle bundle = （Bundle）state；
super.onRestoreInstanceState(bundle.getParcelable(自定义key系统数据那个key))
取出保存的系统数据，然后调用系统的恢复方法来处理。
然后再取出自己的数据，处理。







*****************************
计算圆弧的位置
关于角度转换成弧度的方法：
int angle = Math.PI / 180 * 45
Math.PI/180,就是得到每一度的弧度，然后乘以角度，就是弧度值。

int cl(x) = (int) (400 * Math.sin(弧度值);
  圆的半径，乘以sin弧度值，就是圆中心点为0,0的指定弧度的x轴的坐标，

int ct(y) = (int) (400 * Math.cos(弧度值);
  计算Y的值，也是一样的。

最终完成：
如果是0,0点开始，0角度就是在0,0的正下方，然后依次从右边开始弧度向上。

x值如果用cos，y值如果用sin。
如果是0,0点开始，0度就是在0,0的正右方，然后依次往下边开始弧度。







延伸效果1、
  如果想要从别的点新点开始绘制，比如100，500.那么就把cl加上100、ct加上500，就变成围绕100,500这个点绘制圆弧了。
  新点X = cl+100；
  新点Y = ct+500；


延伸效果2、
  如果想要弧形，从圆点的正上方，从右边开始弧度向下。那么cl不变X值不变。只需要修改下ct值，也就是Y值，也就是离上方的高度值。
  比如1号，原本在正下方，现在要变成正上方。那么减去两倍的原始ct值(圆点到1号点的y值)。
  新点Y = Y-ct*2；



延伸效果3、
  如果想要弧形，从圆点的正下方，从左边开始弧度向上。那么就和上边的效果类似。那么就是Y值ct不变高度不变。只需要修改cl值了。
  新点的x值，减去两倍的cl，就会变成对面的等距离了。
  新点X = X-cl*2；


如果想要弧形，正在在原始形状的，斜对面，那就同时修改ct和cl。就行了。


这样基本上，什么样的效果，都可以通过这三个组合出来了。

先定位新的XY点，cl、ct加上新点的XY值。
然后再决定是什么样子的弧形，然后修改ct，或者cl值。就行了







************************
minHeight
button按钮有个最小高度的，就算不写东西，自适应大小，也会有一个高度的。
如果设置minHeight为0dp，那么就会按照实际的内容要自适应大小了。




**************************
转盘游戏的，转到指定位置的策略：

1、先确定要转到的盘块的角度。需要把原图，旋转多少度，才能到达指针那。
有两个角度，一个是初始角度，就是盘块右边的边，也就是过了这个边，就算是指向这个盘块了。一个是最终角度，也就是盘块左边的边。



其实旋转的原理，就是速度(每次旋转角度)的累加：
每次累加一个速度值；
假如速度是20，那么就是：
第一次旋转20度
第二次再加20度，就是旋转40度
第三次再加20度，就是旋转60度
。。。。。
这样依次累加，就产生了旋转的样子。

然后暂停加速的原理：
就是每次，旋转角度自减1，也就是速度没错减1，然后再加上这个速度。
第一次旋转20度
第二次旋转20+19度，也就是在当前的基础上，再旋转19度。
第三次旋转20+19+18度
。。。。
这样就产生，越来越慢的感觉了。


旋转到指定位置的策略核心，就是：
点击暂停后，速度开始每次自减1，然后减到0的时候
最后的累加角度，需要是在指定盘块那。
比如，5号，从原始状态，至少需要旋转270度。
那么就需要，最后的累加角度，是270度。
也就是需要一个值，不断的，加上自减1的值，最终是270度。

这样点击暂停后，把累加角度归零，然后就会从0度，慢慢旋转到270度停止了。
如果想多转几圈，可以再加上几个360度。


这里就需要一个公式，来计算这个值：
(-1+Math.sqrt(1+8*最终角度))/2
  **最终角度，可以从最少多少度，和最多多少度，中间取个随机值。







*****************************************
ViewGroup类的控件可以使用scrollBy和scrollTo方法，来移动内部控件的位置：
scrollTo方法，可以想象成ViewGroup内部有个滚动条。
scrollTo（10,0）就相当于是把x轴的滚动条，向右滚动了10个像素。

ViewGroup自身是不会移动的，移动的是内部的控件。

getScrollX（）获取当前X轴上，已经滚动了多少的值。

让一个控件内部随着手指移动的方法：
获取当前已经滚动的值，加上，两次移动之间的距离。



滑动删除的ListView实现：
关键实现方法：
点击的时候，获取到点击item的根布局对象，然后触摸移动的时候，操作根布局的scrollTo方法，让它移动。

具体实现：
自定义ListView，在onTouchEvent方法中，点击的时候，先获取XY的坐标值，然后使用ListView的pointToPosition(x,y)方法，获取到item的位置。然后判断下是否为无效位置position ！= INVALID_POSITION静态变量。

获取到位置后，然后使用ListView的getItemAtPosition（position），会获取到指定位置的Object对象。其实这个就是Adapter适配器中的，getItem（）方法中，返回的对象。
在适配器的数据源中，每一项都要添加一个item的父布局的对象，在getView中，添加。然后在getItem（）方法中，返回这一项的对象。
这样使用ListView的getItemAtPosition（position），返回的就是个含有父布局对象的对象了。然后提取出父布局对象，

然后在move的时候，使用scrollTo（）方法移动。可以再添加其他处理，比如重新点击的时候，是不是一个新的item。


Adapter中。点击后的处理，尽量放在Activity中。
可以使用接口的方法在实现：
新建Adapter对象，需要传入一个OnClickListener对象。
在Adapter的getView中，设置按钮点击事件的时候，就使用传入的对象。
这样点击事件的方法，就在Activity中了。






scrollTo是没有动画效果的，是瞬间到达的，如果让view缓慢的到达呢

可以使用Scroller类，来提供数据
Scroller类，是一个数值产生器，可以按照设置的距离，时间，加速器，算出每一毫秒的位置。

使用方法：
实例化，构造方法：
Scroller mScroller = new Scroller（上下文，[加速器]）,也可不用加速器

使用的时候，调用一个方法，然后调用invalidate()重绘，
mScroller.startScroll(X值，Y值，X的加值，Y的加值，时间)
  加值，都是从当前的位置，移动多少个位置，不是到那个位置。
invalidate（）；

调用invalidate方法会，是会先调用一个computScroll方法的。
   然后移动的操作，在这个方法内处理就可以。在操作的那一时刻，mScroller会返回，通过计算的，当前这个时刻的，移动值。
   mScroller.getCurrX(),会返回当前产生的数值
   操作之后，再次invalidate（），就又会进入这个方法了。
layout.scrollTo(mScroller.getCurrX(),mScroller.getCurrY())
invalidate()

可以再加个判断，数值使用完后，就不调用invalidate方法了。
if(mScroller.computeScrollOffset()){
   layout.scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
   invalidate();
}
mScroller.computeScrollOffset()会返回一个布尔值，是否还在产生数值。


mScroller.isFinished()	是否滚动结束了
mScroller.abortAnimation()	停止动画，停止计算数值。







*********************************

view类的layout方法，可以用来改变控件的位置，比如：
bt.layout(10,10,200,200)
把view绘制在指定的位置上。
四个参数l,t,r,b，就是控件和上下左右的距离
（后面两个不是控件宽高的）





******************************
OnTouch事件的分发机制：

顶层：
Activity执行dispatchTouchEvent，然后传递给Activity的Window，然后传递给decorView。
最后才到XML布局最外层的ViewGroup。



从ViewGroup开始，会先调用ViewGroup的dispatch方法；
在dispatch方法中，会调用ViewGroup的onInterceptTouchEvent()方法；


onInterceptTouchEvent()方法是用于决定，是否拦截event触摸事件往下传递：
   1.默认是false不拦截的。就会把event传递给子控件的dispatch方法。

   2.如果重写后设置成返回true，就会拦截不往下传递了。同时把event事件传递给，自身的父类View类的dispatch方法来处理。还是一样，先onTouch，然后onTouchEvent的。

   如果不拦截，而且子控件有消费事件，后续事件每次来的流程就是，父dispatch，父类onIntercept，子dispatch。每次都会经过onIntercept方法。
   
   如果不拦截，但是子控件不消费事件，这样就会调用ViewGroup的父类View类的dispatch。那么从down之后的流程：ViewGroupp的dispatch，然后再各种onTouch，和onTouchEvent的判定。这样，既然子控件不要，也就不存在onIntercept要不要再拦截了。也就不走这个方法了。

   如果从down的事件，开始拦截，那么会直接转到自身的onTouchEvent方法，如果是move或者up的事件，开始拦截，不会当时就转到onTouchEvent方法，会在下一次的事件时，从dispatch方法，转到onTouchEvent方法。就不进入onIntercept了。


如果onIntercept方法，在down以后的事件中，拦截了事件；如果子控件不想让父控件拦截触摸事件，那么可以在拦截前，写上这个代码。
getParent().requestDisallowInterceptTouchEvent(true);
执行后，后续的事件，就会从父ViewGroup的dispatch，直接跳转到子控件的dispathc，就不会再执行父ViewGroup的onIntercept方法了。


事件传递到子控件的dispatchTouchEvent方法，如果子控件返回false，不消费。那么父控件就会调用自身父类View类的dispatchTouchEvent方法，还是判断是否设置了setOnTouchListener，如果没有就转给onTouchEvent方法处理。


各种触摸时间处理方法的返回值，只有在Down事件那才有用的。
如果在Down事件那，return false，那么后续时间就不会来了。
如果Down那，return true，然后在Move那retrun false，后续的move和up一样会送来的。
也就是说，只有第一次down的时候，才是决定是否消费事件的。



点击一个控件的时候，event的传递过程：

会先执行控件的View的dispatchOnTouch方法，这个方法，是决定这个控件，是否要消费event触摸事件的。
源码：方法的返回布尔值来决定是否消费event事件
public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}  

会先检查控件是否设置了setOnTouchListener（）方法；
如果设置了，就把event传递给setOnTouchListener（）方法，让它去处理；
如果此方法返回了true，
那么dispatch方法就直接返回true，结束了。
也就是说控件消费了event触摸事件，那么后续的move和up事件也需要的。

如果没有设置setOnTouchListener（）方法，或者onTouch方法返回false不消费事件。
那么就开始执行控件自身的onTouchEvent（）方法。
dispatch最终的返回值是否消费，就由onTouchEvent（）方法来决定了。


小结：setOnTouchListener（）方法的返回值，只能替dispatch返回一个true的结果（不让onTouchEvent执行），如果返回false后，dispatch并不会也返回false，而且dispatche会把event给onTouchEvent，让onTouchEvent来替自己返回一个布尔值。

控件的各种单击长按监听器，都是写在OnTouchEvent（）方法中，会先判断是否为空，也就是是否设置了监听器，如果设置了，就回调此方法。

控件的默认行为,点击效果，滚动等等...都在super.onTouchEvent()方法中执行的。也就是在父类的onTouchEvent方法中写好的。
如果默认让它return super.onTouchEvent()方法，有可能控件本身没有什么效果，默认是返回false的，也有可能默认是返回true的。有效果需要触摸事件的。所以最好，独自执行下super.onTouchEvent().然后在手动return true


onTouchEvent（）的判读是否消费流程，如果控件本身是默认可点击的，比如是Button，那么就会直接返回true，必然要消费的。
还有如果控件设置了各种单击长按监听器，那么也就是会返回true的。
如果不是默认可点击，也没有设置监听器，那么默认是没有消费没有使用的，会返回false。








*************************************
Activity页面之间的切换动画：
使用Theme的方法：
在style文件下，新建一个style标签，设置一个name。
然后选择继承一个系统的主题风格，parent属性。
然后设置一个item属性，android:windowAnimationStyle这个属性，属性内容设置成，自己设置的一个style。

这个内容style，要继承一个系统的style，@android:style/Animation.Activity这个
然后设置四个item属性，名称如下，就是打开进入退出，关闭进入退出时的动画。
属性内容，就设置成，自己在anim文件夹下，新建的动画效果。
动画效果时长，尽量设置成一致的。

<style name="Anim_fade" parent="android:Theme.NoTitleBar">  
      <item name="android:windowAnimationStyle">@style/fade</item>  
</style>  
  
<style name="fade" parent="@android:style/Animation.Activity">  
     页面跳转：新页面进入时候的动画：
     <item name="android:activityOpenEnterAnimation">@anim/fade_in</item>
  
     页面跳转：当前页面退出的动画：
     <item name="android:activityOpenExitAnimation">@anim/fade_out</item> 

     页面关闭：新页面进入的动画： 
     <item name="android:activityCloseEnterAnimation">@anim/fade_in</item>  
   
     页面关闭：当前页面退出的动画：
     <item name="android:activityCloseExitAnimation">@anim/fade_out</item>  
</style>  



使用overridePendingTransition（）的方法：
在startActivity（）方法后，使用

overridePendingTransition（R.anim.XX，R.anim.XX）
第一个是进入的动画，第二个是退出的动画






****************************************
PopupWindow的用法：
PopupWindow pw = new PopupWindow(view,宽，高)
实例化的操作，有很多构造方法，可以选择：
空的；
context；
view；
宽，高；
view，宽，高；
view，宽，高，是否获取焦点；.......

这些也可以用对象单独设置；
pw.setContentView(view)
  **view就是自定义的布局，用layoutInflate生成的view；
    宽高可以使用固定值，也可以使用layoutParams.WRAP_CONTENT静态常量

pw.setFocusable(true);
  **让弹出框获取焦点。如果是false，就是后面的view获取焦点。

pw.setBackgroundDrawable(Drawable对象)
  **给弹出框设置背景，设置了背景后，点back按键或者点击空白处，才能关闭弹出框了。

pw.setOutsideTouchable(true)
  **设置点击空白处是否关闭。

pw.showAsDropDown(view)
  **显示在指定的view下面，从view的左下角开始显示。
pw.showAsDropDown(view,100,100)
  **在view的偏移100,100的位置开始显示。

pw.dismiss()
  **关闭弹出框


pw.setOnDismissListener()
设置关闭的监听器，可以设置关闭的时候干什么。





**************************************************
使用Activity做弹出框的方法：
新建一个Theme的style：
<style name="Anim_fade" parent="android:Theme.NoTitleBar">  
      <item name="android:windowBackground">@android:color/transparent</item>
      <item name="android:windowIsTranslucent">true</item>
      <item name="android:windowAnimationStyle">@style/Anim_scale</item>
</style>  
好像是设置不设置继承父布局，都没什么问题
第一个item是，设置背景色，黑色的。
第二个item是，设置是否透明，true透明的。
    **而且一旦设置了透明了，那么页面切换的时候，当前页面的切换动画就不会使用了。
第三个item是，页面切换时候的动画效果。
    **最好，application那，也重新设置下主题Theme，style那也设置下，一样的动画效果。不然有可能会失效。





**************************************
Movie类用来播放gif
对象创建初始化：
Movie movie = Movie.decodeStream(文件流对象)
  **还可以使用file对象和byte数组对象

int duration = movie.duration()；
获取持续时长

movie.setTime(100)
设置要解析的指定时间的画面

movie.draw(canvas,0,0)
使用canvas绘制当前解析出来的画面

关于怎样在指定时长内，播放完gif。一帧一帧的绘制，最终绘制完，时间肯定大大超过gif的时长，因为绘制一帧肯定大于1毫秒的。
如果手动设置每50或者每100毫米，绘制一次，最终时间绘制完成和gif时长也不会正好对应的。
而且每个机器的性能不同的，绘制一帧的时间不同的。
最终思路就是：
先记录第一帧的时间，到第二帧的时候，再算下两帧的相差时间，然后就播放这个时间的画面。这样速度就和gif时长保持一致了。
为了防止最后一次时间超过gif时长，可以使用时间求余时长就可以了。

long start = SystemClock.uptimeMillis();
if(now==0){
   now=start;
}
int duration = movie.duration();
int time = (int) ((start-now)%duration);

if((start-now)>duration){
   now=0;
}







******************************************************
Volley的用法：
在AndroidStudio中，加入依赖
在目标module的build.gradle中：
    compile 'com.mcxiaoke.volley:library:1.0.+'


先新建一个请求队列：
RequestQueue mQueue = Volley.newRequestQueue(context);
一般这个放在全局Application那。



然后新建一个请求：
StringRequest request = new StringRequest（"http://www.baidu.com/",new Response.Linstener<String>(){实现方法}，new Response.ErrorListener<String>(){实现方法}）；
需要三个参数，第一个是请求的网站，第二个是请求响应的监听器，第三个是请求错误的监听器。

然后添加到请求消息对象中，就可以了
mQueue.add（request）；
还可以使用一个添加tag的方法
request.setTag("tag1");



后面可以取消特定tag的网络请求
mQueue.cancelAll("tag1")；
mQueue.cancelAll(this)；	取消全部网络请求



发送POST请求：
StringRequest request = new StringRequest（Method.POST,url,listener,errorListener）{重写getParams()方法}；
先选择四个参数的构造方法，第一个填写什么类型的请求，后面还一样。
然后再重写StringRequest的getParams（）方法，新建一个hashMap，填写上请求的数据，最后return这个map就可以了。



************

发送JSONObjectRequest请求：
JSONObjectRequest request = new JSONObjectRequest（url，jsonobject，返回监听器，错误监听器）；
jsonobject填null就行。监听器和上面的一样。返回监听器那，返回的是一个jsonobject的对象。

发送JSONArrayRequest请求也一样。


************
发送ImageRequest请求：
ImageRequest request = new ImageRequest（url，监听器，0,0，Config.ARGB_8888,错误监听器）
0,0是运行图片的最大宽高值，如果设置一个值，那么就是如果超过这个值，就压缩。如果是0就是不设置的意思。
Config.ARGB_8888,就是图片质量，可以使用Config的静态常量。



************
使用ImageLoader请求，可以使用缓存的图片请求：
先新建一个ImageLoader对象：
ImageLoader imgloader = new ImageLoader（请求队列对象，Imagecache对象）
ImageCache是个接口，可以新建一个类，承接它。
然后会重载两个方法，一个putBitmap，和getBitmap方法
这时候可以使用LruCache缓存技术和它配合，新建一个LruCache对象，在构造方法中，初始化它。
然后在put方法中，用传入进来的地址和图片，用LruCahe的put方法存储进去。
在get方法中，return返回LruCache提取处理的图片。


然后再新建一个ImageListener对象：
ImageListener listener = ImageLoader.getImageListener(img控件对象，加载时显示的吐图片地址，加载错误时显示的图片地址int地址)

最后使用imageLoader的get方法就可以显示了：
imageLoader.get(url,ImageListener对象)
get还有个四个参数的方法，最后两个是限制大小的。



*************
使用NetworkImageView加载图片：
这个是个自定义控件，继承之ImageView的
在xml中，直接添加控件：控件名：
com.android.volley.toolbox.NetworkImageView

在代码中，可以设置
netimg.setDefaultImagResId(R.drawable.XXX)	加载中显示的图片；
netimg.setErrorImageResId(R.drawable.XXX)	加载失败时显示的图片；
netimg.setImageUrl（url，imageLoader对象）	设置要加载显示的网络图片

关于图片大小，可以在xml中设置控件的大小就可以了。



***************
自定义Request，接受xml文件。
新建一个类，继承Request<XmlPullParserFactory>,泛型是xml解析器。
内部仿造StringRequest的代码。
在解析返回数据的仿造中，把接受到的String字符串，转成一个xml解析器，最后return这个xml解析器。
这样，发起网络请求的时候，成功监听器那，返回的数据就是xml解析器了。


**************
解析Gson
也是一样，只是泛型设置为T。
新建一个gson对象，再修改下构造方法，需要接收一个Class<T>类型的对象，然后新建一个这个对象，接收构造方法中的。
最后在返回的方法中，return返回Gson解析的类对象。







******************************************
MD5加密的用法：
实例化对象：
MessageDigest md = MessageDigest.getInstance("MD5")

然后传入内容byte数组，进行加密
md.update(byte[])

最后取出生成的MD5码：
byte[] bytes = md.digest();

把MD5码转换成16进制的码就可以使用了。用for循环，取出每一位的byte，用Integer的方法转成16进制，如果只有一位数，那么前面就加个0.每次生成的都加入到一个字符串中就可以了。





**************************************************
DiskLruCache的使用：
前期需要在src文件夹下，新建一个名称全称为libcore.io的包，然后把DiskLruCache.java文件放进去就可以了。

实例化对象：
DiskLruCache dlc = DiskLruCache.open(directory, appVersion, valueCount, maxSize)
directory:是要存放缓存的文件夹地址
appVersion：是当前程序的版本号。
valueCount：同一个key可以对应多个文件，一般用1.
maxSize：就是给缓存设置的大小，10*1024*1024 就是10MB。

获取package信息：
PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
packageInfo.versionCode;	获取版本号

当版本号改变的时候，dlc默认是会把所有缓存数据都清理掉的，然后重新下载然后缓存



实例化的时候，会检查日志文件是否存在，如果存在，就读取日志中的记录，把已经存储的key给记录到一个map中。
后续这个map的增删，是直接操作的时候，就添加删除了。不是从日志中读取的。
【也就是说如果两个DiskLru同时操作，记录就会冲突了。实例化的时候倒是会从日志文件那同步下操作，但是如果后续再操作就乱了。】





写入缓存：
Editor editor = dlc.edit(key)
把要存储的图片地址，通过MD5，转成MD5码当做key，也就是缓存的文件名。
通过dlc的edit方法，传入一个key，就会生成一个Editor的对象。

OutputStream outputStream = editor.newOutputStream(0)
通过一个editor的newOutputStream方法，得到一个输入流。
参数0，是指要存储这个key的第几个文件，0就是第一个。之前也是设定了一个key可以存多个

图片或者数据下载后，然后往里面写入数据就可以了。

写入后，需要提交也可以完成编辑的。
editor.commit()

写入失败，也可以取消 editor.abort()




读取缓存：
Snapshot snapshot = dlc.get(Key)
通过dlc的get（key）方法，传入key（也就是存储的文件名），来获取一个Snapshot的对象

通过判断snapshot是否为空，就可以判断是否有存储这个文件。如果为空，就是没有这个文件。

InputStream is = snapshot.getInputStream(0)
通过snapshot的getInputStream（0）方法，参数，是指要提取第几个文件，最终提取这个文件的输入流。



删除一个key的缓存文件：
dlc.remove(key)



其他api：
long size = dlc.size();
返回缓存文件的大小，比byte为单位

dlc.flush();
这个方法是用于操作日志的。
内部操作日志的主体，是个FileWrite写入流，每次的操作记录，都是先写入到缓存中的，如果不调用flush（）方法，日志是不会直接写入文件中的。


dlc.close();
关闭dlc，不在进行操作。在Activity的onDestroy（）方法中调用就可以了。

dlc.delete();
删除dlc中的所有缓存数据。
删除后，需要重新实例化DiskCache对象。不然会报错。






****************************************
自定义ViewGroup：

【自定义各种ViewGroup类的控件的时候，如果要findview实例化子控件，必须要在onLayout方法内，才能查找得到】。

ViewGroup的测量子控件的方法流程:
在measureChildren（）方法中，for循环，每次取出一个子控件，送进去一个measureChild（）方法。方法参数送入子控件，和当前ViewGroup的宽、高测量模式。


在measureChild（）方法中，先获取child的LayoutParams。然后利用getChildMeasureSpec（）方法，算出子控件的宽、高测量模式。比如宽的测量模式，方法参数传入ViewGroup的宽测量模式、ViewGroup的宽左右边距，子控件的宽。


在getChildMeasureSpec（）方法中，判断，
如果子控件的宽，是指定值的，那么测量大小就是指定值，测量模式是EXACTLY。

如果父类是EXACTLY，子类是充满父类，那么子类的测量模式就是EXACTLY；子类是包括内容，那么子类测量模式就是AT_MOST；测量大小都是父控件的大小。

如果父类是AT_MOST，那么子类不管是充满还是包括，测量模式都是AT_MOST，大小都是父类大小。
如果父类是UNSPECIFIED的，那么子类的测量大小就是0，模式也是这个。
最后把大小和模式，通过makeMeasureSpec（）方法，组装成一个测量模式返回去。



这时候，在measureChild（）方法中，最后分别接收到测量模式后；
就会调用子控件的measure()方法，方法中，会再次调用onMeasure（）方法。
默认的View的onMeasure（）方法：
在onMeasure（）方法中，会调用setMeasureDimension（）方法。
使用getDefaultSize（）方法，返回两个宽高值，然后设置。

在getDefaultSize（）方法中，如果测量模式是AT_MOST或者EXACTLY,那么值就是测量值。如果测量模式是UNSPECIFIED，那么值就是设置的MiniWidth值，或者view的背景图大小。



ViewGroup类的onMeasure方法中，会遍历每一个子view，设置子View的大小。

我觉得，各种功能view类控件，应该在onMeasure方法中，还会重写一些设置，比如根据内容来设置真正的控件大小。



在初始化的时候，强制获取View的宽高：
int width = View.MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
int height = View.MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
view.measure(width, height);
view.getMeasuredWidth()


getWidth和getMeasureWidth都是这显示出来，绘制后才能得到的。在显示出来前是得不到的。
比如先生成View，加载图片；最后在ViewPager里面显示。那么在生成的时候是获取不到的，因为没有去绘制去显示。



自定义：
先重写一个方法generataLayoutParams方法，修改return的LayoutParams
return new MarginLayoutParams(getContentx(),attrs)
viewGroup在加载的时候，会先调用这个方法，得到一个layoutparams给子控件用，然后再接受子控件设置的参数，但是默认的LayoutParams只能接受宽高值的。所以手动改成一个MarginLayoutParams就可以接受设置的margin值了。


然后重写onMeasure方法，用于测量子View。和设置自身的宽高
mesureChildren(widthMeasureSpec, heightMeasureSpec)
测量所有子View的宽高。这两个参数是方法的接收参数。


getMeasureWidth，其实就是onMeasure方法里面的最终方法，setMeasureDemension（）设置的两个参数值得来的。
getWidth是通过onLayout中的，右边的X或者Y值，减去左边的X或Y值获取到的。
所以：
在测量所有子View的宽高，就可以获取子View的，getMeasureWidth（）了。
在onLayout方法后，才能获取子View的getWidth（）


也可以用for循环，一个一个的测量子控件，
measureChild（view，spec，spec）、


这两个参数是，上级的布局，传给自身的，推荐宽高和测量模式。
使用一个静态方法，可以得出推荐宽高值，和测量模式
int width = MeasureSpec.getSize(widthMeasureSpec)
int widthMode = MeasureSpec.getMode(widthMeasureSpec)
测量模式，有三种：
MeasureSpec.EXACTLY	自身设置为match_parent,或者指定具体尺寸的时候。
MeasureSpec.AT_MOST	自身设置为warp_content的时候

如果自定ViewGroup的宽高设置为warp_content的时候，从接受参数中，解析出来的推荐宽高值就不准了。需要自己测量。包裹内容也就是根据内容的宽高设置自身宽高了。
那就根据需要，测出来宽度和高度。比如说，多行，也找出最宽的那一行的宽度，累加一行的所有子View的宽度，子View的宽度加上marginleft的值。子View的宽度需要使用【getMeasureWidth()】不能使用getWidht（）；
最后用 setMeasuredDimension设置viewGroup的宽高值。如果是match_parent,就使用解析出来的推荐宽高值就行了。


最重要的是onLayout方法，是用于设置每个子View的位置的。不设置是不会显示的。
view.layout(l,t,r,b)
根据想要的效果，来设置每个子View的两个对角的坐标值，左上角，和右下角
可以根据getWidth父布局的宽度，和子view的宽高度getMeasureWidth，和marginLeft信息，来设置坐标
一般就是设定l和t，l也就是离父布局左边框的距离，也就是x轴值，t也就是离父布局上边框的距离，也就是y轴值。
r和b就是l和t的值，再加上子控件自身的宽高值了。
【onLayout是会多次调用的，关于一些变量的赋值之类的，一定要注意。】
可以利用方法接受到的changed值，这个值，只有第一次才是true。后面的都是false的。





ListView的一个方法，overScrollBy（）
这个方法，是在ListView上下滑动，超过边界的时候，会调用的一个方法。

overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)
一共有这么多的参数：

daltaX和daltaY是每一次滑动的距离

scrollX和scrollY是滑动超出边界，本次滑动之前总共超出的距离值。

maxOverScrollX和maxOverScrollY是允许内容和边界的距离最大值。这个默认是0的
（这里面的X轴的参数，都是没用的。）

如果是最大值默认是0，那么只有daltaY每次会参数数值，也就是每次滑动的距离。

这个方法，会return父类的这个方法，把这些参数给父类处理。如果修改maxOverScrollY的数值，比如修改为300，那么就会允许，下拉300个像素距离。
如果需要求现在滑动的总距离，需要scrollY加上deltaY。这个值最大值也是300.

求是否滑动到底或者到顶的方法：
 int newScrollY = scrollY + deltaY;  
    final int bottom = maxOverScrollY + scrollRangeY;  
    final int top = -maxOverScrollY;  
    if (newScrollY > bottom) {  
        maxOverScrollY = 0;  
    } else if (newScrollY < top) {  
        maxOverScrollY = mContentMaxMoveHeight;  
    } 







************************************
Handler的用法：

非UI线程不能更新UI数据的，这时候需要用handler的post方法
在别的线程中，把要做的操作，直接写到post方法就可以了
handler.post(new Runnable())

handler.postDelayed(Runnable,1000)      多少毫秒后执行这个runnable

**************
Handler发送消息
先创建实例化一个Message对象
最后，handler.sendMessage(msg);就发送msg对象了
传递整形可以用agr1
msg.agr1=10;
msg.obj=              可以传递一个obj类型的数据

**********
创建实例化Message对象的时候，还可以这样创建
handler.obtainMessage()   就是创建一个服务于这个handler的Message对象
**内部源代码obtainMessage的代码，就是return一个Message.obtain(this)方法
Message.obtain代码是，创建一个Message对象，然后设置这个msg的服务对象msg.traget=handler。最后返回这个msg对象。

这样创建之后,还可以使用另一种方法，来发送这个msg消息.用msg自己发送
msg.sendToTarget();   就是发送消息给自己的服务对象了。



*************
handler.removeCallbacks(runnable)   
可以移除一个执行中runnable




Callback的用法：
在实例化Handler的时候，可以放入一个Callback接口对象匿名内部类，也会实现一个HandleMessage方法，并且有返回值的，返回boolean值。
可以拦截handler发送的消息。如果把返回值设置为true。hanlder就收不到了。



HandlerThread开启UI子线程
新建一个HandlerThread，然后实例化new HandlerThread("名称")
最后HandlerThread.start();

然后新建一个Handler，实例化new Handler(HandlerThread.getLooper())
以后再用这个Handler对象处理数据，就是在子线程中处理了。






更新UI的多种方法，
Handler可以用post和sendMessage
另外还可以用Activity的runOnUiThread(Runnable)
还有控件对象的.post(Runnable)
都是可以在子线程中更新UI数据的




在onResume创建之前，子线程还是可以直接更新UI数据的，应该判定是否是主线程的东西，在onResume那才创建出来、

实例化Handler的时候，构造方法可以传入一个Looper对象。没有传的话，默认传的是主线程的。但是如果在子线程中实例化的话，就不会默认传进去主线程的Looper了，就会报错了。所以一般要在主线程中实例化。


如果在子线程中，实例化handler也可以传入主线程的Looper对象，
Handler handler = new Handler（Looper.getMainLooper()）;




handler的源码分析：

handler的构造方法内会，调用Looper.myLooper()方法，来生成一个looper对象。赋值给自身的Looper类型变量。使用的Looper的Queue，赋值给自身的MessageQueue变量。

 mLooper = Looper.myLooper();  
    if (mLooper == null) {  
        throw new RuntimeException(  
            "Can't create handler inside thread that has not called Looper.prepare()");  
    }  
    mQueue = mLooper.mQueue;  
    mCallback = null;  


Looper.myLooper()方法，是从sThreadLocal中取出来的。
如果sThreadLocal里面没有looper对象，那么返回的looper对象就为空，就会报错。

public static final Looper myLooper() {  
    return (Looper)sThreadLocal.get();  
}  

sThreadLocal是什么时候存的looper对象呢？
是在Looper.prepare()方法的时候存入的looper对象。如果sThreadLocal里面已经有了，就报错，如果没有，就set存储一个new Looper对象。Looper对象创建的时候，会创建一个MessageQueue消息队列的对象。赋值给自身的变量。

public static final void prepare() {  
    if (sThreadLocal.get() != null) {  
        throw new RuntimeException("Only one Looper may be created per thread");  
    }  
    sThreadLocal.set(new Looper());  
}  

private Looper(boolean quitAllowed) {  
        mQueue = new MessageQueue(quitAllowed);  
        mRun = true;  
        mThread = Thread.currentThread();  
}  

所以如果要在子线程中，创建一个Handler对象，需要调用Looper.prepare()方法，创建一个Looper对象，然后在创建Handler对象的时候，才能取出Looper对象使用。

而在主线程中，系统在main方法中，已经调用了Looper.prepare()方法，所以可以直接创建Handler对象。而且也调用Looper.loop()方法


Handler的发送消息和处理消息的机制：
各种发送消息的方法，最终都会调用sendMeassageAtTime（）方法。

public boolean sendMessageAtTime(Message msg, long uptimeMillis)  
{  
    boolean sent = false;  
    MessageQueue queue = mQueue;  
    if (queue != null) {  
        msg.target = this;  
        sent = queue.enqueueMessage(msg, uptimeMillis);  
    }  
    else {  
        RuntimeException e = new RuntimeException(  
            this + " sendMessageAtTime() called with no mQueue");  
        Log.w("Looper", e.getMessage(), e);  
    }  
    return sent;  
}  

有两个接收参数，msg就是发送的msg对象，第一个是发送消息的时候，就是系统开机时间加上延迟的时间，如果没有延迟，就是系统开机到现在的毫秒数。

MessageQueue是消息队列，是在looper构造的时候，创建的一个消息队列。在创建Handler对象的时候，会把创建的MessageQueue对象，传入Handler的MessageQueue对象。

这时候会调用queue.enqueueMessage()入队方法，会按照消息的时间来进行排序入队。把消息放入到queue队列里面。也就是Looper对象的变量，MessageQueue对象中。


消息的出队方法，Looper.loop()
会从looper对象的变量MessageQueue对象中，取出msg来处理。
调用  msg.target.dispatchMessage(msg)
msg.target就是msg的目标，也就是Handler了。也就是调用handler.dispatchMeassage()方法来处理。

public void dispatchMessage(Message msg) {  
    if (msg.callback != null) {  
        handleCallback(msg);  
    } else {  
        if (mCallback != null) {  
            if (mCallback.handleMessage(msg)) {  
                return;  
            }  
        }  
        handleMessage(msg);  
    }  
}  

如果有callback就调用callback的方法，如果没有，就调用handler的handleMessage（）方法。也就是创建Handler对象是，重新的那个接收方法，



Handler的post方法分析：

public final boolean post(Runnable r)  
{  
   return  sendMessageDelayed(getPostMessage(r), 0);  
} 

会先调用getPostMessage()方法，把runnable对象转换成Message对象。
getPostMessage（）方法的源码：

private final Message getPostMessage(Runnable r) {  
    Message m = Message.obtain();  
    m.callback = r;  
    return m;  
}  

先新建一个服务于自身Handler的Message对象，然后把runnable对象，设置成msg的callback。最后return这个msg。
后面的就和之前一样了，现在走的的sendMessageDelayed（）方法。最终也会入队，出队，调用dispatchMessage（）方法，处理消息。
这时候，检查msg.callback不为空，就调用handleCallback（）方法了。

private final void handleCallback(Message message) {  
    message.callback.run();  
}  

也就是直接调用这个msg的callback的run方法。msg的callback也就是runnable了。




各个view控件的，post方法，和Activity的runOnUiThread方法，内部也就是调用handle的post方法。








******************************************

DrawerLayout侧滑菜单

是需要把DrawerLayout当做根布局的

<android.support.v4.widget.DrawerLayout>

内部只能有两个子布局，
第一个布局是显示内容的布局，也就是打开程序，显示的界面。
第二个布局是菜单布局，也就是侧滑后，显示的菜单布局。

必须要在第二个布局中，设置android:layout_gravity="start"，就是左侧菜单，end就是右侧菜单。
第一个布局，内容布局宽高要充满父类

在菜单布局的监听器中，可以设置下点下选项后就关闭菜单：

drawer.closeDrawer(Gravity.LEFT)  	填写菜单放心，就关闭指定方向菜单了。
当然也有打开菜单的方法:
drawer.openDrawer(Gravity.LEFT)
drawer.isDrawerOpen(菜单布局对象或者ID)    检查菜单是否打开状态




DrawerLayout在Actionbar上左边，显示一个菜单icon按钮的方法：
setDrawerListener（ActionBarDrawerToggle对象）

创建实例化一个ActionBarDrawerToggle
a=new ActionBarDrawerToggle(this，DrawerLayout对象，图标，open名，close名)
   **图标和open名称、close名称，都需要用资源文件，R.XX.XX

实例化的时候还可以再重写两个方法
{ onDrawOpend()          设置打开或者关闭的时候做什么处理。
  onDrawClosed()
}


在Toolbar上的使用：
创建实例化一个ActionBarDrawerToggle对象
a=new ActionBarDrawerToggle(this，DrawerLayout对象，open名，close名)
也就是使用不需要图标的构造方法。
然后使用一个方法：
a.syncState()
这样就会在Toobar左边，生成一个有动画效果的菜单按钮了。






*****************************************************
NavigationView的用法：
先在build.gradle中添加：
compile‘com.anndroid.support:design:22.2.0’

可以单配DrawerLayout使用，作为其的菜单布局：
先在根布局，添加命名空间xmlns:app="http://schemas.android.com/apk/res-auto"

主要属性：
app:headerLayout="@layout/layoutXX"
app:menu="@menu/XXX"

headerLayout就是头部的布局，可以任意设定。
menu就是下面的菜单布局。
  **在menu文件夹下，新建一个xml文件。
可以使用一个group标签，这样组内的菜单就可以有选中状态，点击之后，下次打开菜单，上次点击的菜单还是选中状态，group再设置个属性，只能有一个是选中状态。每一个item标签就是一个菜单项：
<group android:checkableBehavior="single" >
    <item android:id="@+id/today" android:title="今天记录"/>
    <item android:id="@+id/count" android:title="全部记录"/>
</group>

如果想有分割线，就这样设置：
 <item android:title="Sub items">
        <menu>
            <item
                android:icon="@drawable/ic_dashboard"
                android:title="Sub item 1"/>
            <item
                android:icon="@drawable/ic_forum"
                android:title="Sub item 2"/>
        </menu>
    </item>
这样就会有个分割线了。但是子菜单，是没有选中状态的。
其他item还有些属性，checked="true"设置选中状态，
checkable=“true”是否可以选中状态。

其他属性：
app:itemBackground=""		设置背景
app:itemIconTint=""		设置icon颜色
app:itemTextColor=""		设置字体颜色
   字体颜色默认是Theme里面的colorPrimary属性的值。也就是bar的颜色

setNavigationItemSeclectedListener（new XX）
设置菜单item点击的监听器，方法内，会送入一个MenuItem对象






*****************************************************
Toolbar的使用：

md的主题有：
在manifest中这样写
@android:style/Theme.Material (dark version)
@android:style/Theme.Material.Light (light version)
@android:style/Theme.Material.Light.DarkActionBar
与之对应的Compat Theme:

Theme.AppCompat
Theme.AppCompat.Light
Theme.AppCompat.Light.DarkActionBar

在xml中，使用系统主题，这样写：
<style name="AppBaseTheme" parent="android:Theme.Holo.Light.NoActionBar">


一般可以设置几个属性，来定制Theme
<item name="colorPrimary">@color/material_blue_500</item>
<item name="colorPrimaryDark">@color/material_blue_700</item>
<item name="colorAccent">@color/material_green_A200</item>

colorPrimary 		对应ActionBar的颜色。
colorPrimaryDark	对应状态栏的颜色
colorAccent 		对应EditText编辑时、RadioButton选中、CheckBox等选中时的颜色。



android.support.v7.widget.Toolbar
包名
xml属性：
android：background="?attr/colorPrimary"
  使用Theme中定义的颜色，当然也可以自己写颜色。#ff0000

app:title=""		设置标题
app:titleTextColor="	设置标题字体颜色
app:titleMargins=""	设置标题和四面之间的距离
app:titleMarginTop=""	可以单独设置四个方向的不同的距离值
app:subTitle		设置子标题
app:subTitleTextColor	设置子标题字体颜色
app:logo=""		设置logo
app:navigationIcon=""	设置侧滑菜单的按钮图标








****************************************
Actionbar的使用：

系统Theme中，Theme.Holo及其子类都是有Actionbar的，Theme.Light和Theme.Black都是标题栏，不是Actionbar。

隐藏Actionbar的方法：
ActionBar actionbar = getAction（）	获取actionbar对象
actionBar.hide()			隐藏

ActionBar会默认使用app的name和icon作为图标和标题
可以在application或者activity标签中，设置logo属性，就会ActionBar设置图标了
也可以：
actionBar.setLogo();或者actionBar.seteIcon();
icon是方形的，logo什么形状都可以
其他：
actionBar.setTitle()		设置标题
actionBar.setSubTitle()		设置子标题
actionBar.setDisplayShowTitleEnabled（false）	设置标题可见，false隐藏
actionBar.setDisplayShowHomeEnabled(false)	设置icon可见，false隐藏




在ActionBar上显示菜单图标
可以在menu的xml文件中，设置android：showAsAction=“never”，就显示了。always表示永远显示在ActionBar中，如果屏幕空间不够则无法显示，ifRoom表示屏幕空间够的情况下显示在ActionBar中，不够的话就显示在overflow中，never则表示永远显示在overflow中。


通过ActionBar导航：
actionBar.setDisplayHomeAsUpEnabled(true)
这样就会在ActionBar的坐标显示一个向左的箭头。
可以给它设置个响应事件，这个也算是个菜单项的。
在系统菜单监听器中，判断ID，ID为android.R.id.home。判断后可以调用finish（）方法。


更改ActionBar的背景颜色和文字颜色：
<style name="CustomActionBarTheme" parent="@android:style/Theme.Holo.Light">  
        <item name="android:actionBarStyle">@style/MyActionBar</item>  
        <item name="android:titleTextStyle">@style/MyActionBarTitleText</item>  
</style>  
  
<style name="MyActionBar" parent="@android:style/Widget.Holo.Light.ActionBar">  
        <item name="android:background">#f4842d</item>  
</style>  

<style name="MyActionBarTitleText" parent="@android:style/TextAppearance.Holo.Widget.ActionBar.Title">  
        <item name="android:textColor">#fff</item>  
</style>  






*******************************************
Activity的xml布局文件中，最终的根布局FrameLayout的id是：android.R.id.content


在4.4版本后，可是设置状态栏透明，
<item name="android:windowTranslucentStatus">true</item>

但是头部的view最好设置个属性android:fitsSystemWindows="true"
不然头部View会从状态栏开始显示的。


改变状态栏颜色的方法：
找到最终根布局content，然后添加个高度为状态栏高度的view，颜色设置成自己想要的颜色就行了。

查找状态栏的高度：
int id = getResources().getIdentifier("status_bar_height", "dimen", "android");
float dimension = getResources().getDimension(id);

查找根布局content：
ViewGroup content = (ViewGroup) findViewById(android.R.id.content);







************************************
监听back键的方法：
重写activity的onBackPressed（）方法。方法内会执行父类的onBackPressed（）方法。父类Activity的方法，就是finish（）退出。
如果注释掉父类的方法，就不会退出了。


跳转到手机程序列表页的intent：
Intent i = new Intent(Intent.ACTION_MAIN);
i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
i.addCategory(Intent.CATEGORY_HOME);
startActivity(i);







面试
1.avtivity的生命周期，两个acitity之间跳转会执行的几个方法？
第一个acitivity会先执行onPause，然后执行第二个acitity的oncreate、onStart、onResume、最后在执行第一个activity的onStop。

五大布局
linearLayout、relativeLayout、frameLayout、TableLayout、absoulteLayout


内存泄露：
当一个对象不再使用的，本该被回收时，而另一个正在使用的对象持有他的引用，导致不能被回收。就造成内容泄露了，持续这样会导致APP的占用内存加大，从而导致00M。

使用上下文对象时候，尽量使用Application的，而不是Activity的。
监听器不用的时候，及时注销。

平时，主要是由在Activity中创建的匿名内部Handler类对象，它会持有当前Activity的引用，当Activity被销毁时。如果消息队列中还有这个handler未处理的消息。那这个handler又持有Activity的引用。就会导致Activity的内存资源无法被回收。

可以创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用。在Activity的onDestroy的生命周期中，执行移除Handler所有的消息。


内存溢出OOM
根据控件大小，设置图片的缩放比例。
设置图片的解码格式。
图片的复用。
在自定义View的onDraw方法中，不要创建对象。
使用大量字符串的时候，使用StringBuffer。


布局尽量扁平化，不要嵌套太多。
多线程尽量使用线程池
图片缓存，采用内存缓存LRUCache和硬盘缓存DiskLRUCache


==用于比较基本类型的内容是否一致，比较类的时候，就是比较的是两个类的内存地址是否一样。
eqauls是比较两个类逻辑上是否一致。比如一个人18岁，另一个也18岁。在类中就可以自定义比较方法。如果都是18岁就判定是一致的。
如果没有自定义比较方法，那就用Object的方法，还是比较内存地址是否一致。


i++和++i都是i=i+1的意思
i++是让用i的老值。用完之后，i再加上个1.
++i是i先加上1，用i的新值再执行语句。



GET和POST的区别
Get主要是用来获取数据，请求的数据会附在URL之后。
Post是用来提交数据的。



接口和抽象类的区别
接口是对动作的抽象，抽象类是对根源的抽象。
接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
而且一个类，可以继承继承多个接口，但是只能继承一个父类。



线程和进程
进程是一个应用程序，线程是进程的一部分，可以共享进程的所有资源。








五大数据存储方法
File  Sqlite  sharedPreferences(XieRui PuRaiFeiRuiCSi)、contentprovider（proWaiDe） 网络

四大组件
Activity、Servicer、BroadcastReceiver、ContentProvider


两个启动service的方法。
是一种长生命周期的，没有可视化界面，运行于后台的一种服务程序
startService和binderService（BaiInDe）
startService会执行oncreate和onstartCommand方法，后续每次启动，只会启动onstartCommand方法。

binderServier会执行onCreate和onBinder方法、。

startService启动方法，avtivity如果不调用stopService，service会一直在后台的。而且activity和service的关联不太好的。通信不便。
binderService，可以让activity和service有更好的关联。而且avtivity销毁的时候，绑定的service也会自动销毁的。
绑定的时候会执行onBinder方法，返回一个Ibinder对象。


重载和重写
重载是子类覆盖父类的方法，
重写是自身的同一个名称的方法，多个参数的设定吧。




touch事件的传递机制
事件会先传给父类的dispatchTouchEvent方法，然后父类会再调用onIntercept(in te sai pu te)TouchEvent方法，看是否拦截事件，默认是不拦截的，如果拦截了。然后子控件的dispatchTouchEvent方法，会先判断是否设置了setOnTouchListener，如果设置了就传给监听器的onTouch方法，如果没有没有设置了，就传给OnTouchEvent方法。
如果子控件的dispatchTouchEvent最终返回了false，那么就会调用父类ViewGroup的父类View的dispatchTouchEvent方法。


handler looper  messageQueue的关系
looper主要是创建一个MessageQueue消息队列，然后不断的从消息队列中取出消息去处理。
looper主要有两个方法，一个是prepare方法，用于生成一个looper对象。
一个是loop方法，不断的从消息队列中，取出消息。
looper会与当前线程绑定，保证一个线程只有一个looper实例，同时一个looper实例，只有一个消息队列。

handler是负责发送消息和处理消息的。
handler实例化的时候，会把looper对象和消息队列和自身的属性关联上。
handler每发送一个消息，就会把消息放入到消息队列中。

looper的loop方法，会先取出消息，然后使用消息的target目标对象的dispatchMeassage方法来处理消息。
如果handler实例化的时候，有定义callback，就使用callback的handlemessage方法，如果没有就调用handler的handlemessage方法。

如果handler发送的消息是个runnable对象的话，会先创建一个message对象，然后把message对象的callback属性，赋值为runnable对象。

最后在dispatchMessage的方法中，会检测msg的callback是否为空，如果不为空，就直接执行callback的run方法。


android是如何检测非UI线程是不能更新UI的
更新UI的时候，会检查所在线程是否是主线程。

为什么有些时候非UI线程是可以更新UI的
在onResume方法之前，子线程也是可以更新的


缩放图片的原理：
先添加一个缩放手势监听器，然后在监听器中，会获得缩放值，然后使用matrix(mei tui ke s)矩阵，设置缩放值，也可以先提取设定一个最大缩放值和最小缩放值。
另外就是缩放的过程中，保证图片缩放的时候，一直保持在控件的中心位置，和放大的时候，图片边框和控件边框保持一致，不会产生白边。
实例化一个Rect对象，用图片的原始大小，来构建。然后使用matrix的.mapRect方法，来获取到缩放后的图片位置信息，检测是否是在控件中心，或者存在白边，如果是就进行移动调整。如果不在控件中心。。就移动到控件中心，


ListView异步加载图片：
使用LruCache缓存图片，和diskCache。
在生成item View的时候，给每一个item的imageView设置个唯一的tag。
在滚动的过程中不去下载图片，在滚动停止的时候，按照当前显示item的位置，开始下载图片，

大图片oom的问题：
先使用BitmapFactory.options，设置只加载图片信息，获取到图片的宽高，然后拿控件的宽高除以图片宽高，获取到最大的那个缩小比例，然后设置缩放信息，再加载图片。

断点续传
先获取到下载文件的大小，然后建立一个randomAccessFile文件，设置文件的长度，然后每次写入的时候，记录下累计写入长度。如果暂停了，下次再下载的时候，从记录的累加长度那开始写入。

如果使Activity变成窗口样式
在mainfest文件中，定义theme，使用dialog的theme，或者自定义

后台的Activity被系统回收怎么办
重写onSavaInstanceState（si dei te）方法，保存需要保存的信息，然后在onCreate方法中恢复。

anr
如果对输入事件的响应超过5秒，brocaseReceiver超过10秒仍未执行完毕，就会造成anr
在主线程中，如果耗时的任务，最后是再开一个子线程去处理。
在广播接收者中，耗时任务，可以开启一个service去执行。

activity是一个包含界面，可供用户操作的界面，
service是一个没有长生命周期，没有界面的，服务后台的一个程序。

四种启动模式
默认的standard(si dan de)
singleTop
singleTask
singleInstance


自定义View的实现方式：
自绘控件、组合控件、继承控件



多Tab的fragment界面，在后台低内存的时候，Activity会被回收。但是Fragment的实例并没有被回收，会在调用onSavaInstance（）方法时保存起来。在Ativity再次重建的时候。会通过保存的状态恢复出来。但是原本的Fragment变量为空了，又会重新创建新的Fragment实例。所以会导致重叠。

解决方法：
Fragment附加在Activity上的时候，会调用Activity的一个生命周期方法onAttchFragment
在第二次恢复启动全部加载的时候，也会一一调用这个方法的。
然后判断传入的fragment对象是哪个Fragment类的实现，然后就把fragment对象赋值给那个类的变量。
然后再通过管理员对象全部隐藏，显示需要显示的那个。

如果需要恢复页码的话，可以通过onSaveInstanceState方法来保存下页面，最后在onCreate方法中，提取页码。然后再显示这个页码的页面。











***************************************
soap的基础：
是一种类似soap的数据，头部会有个soap：Envelope，来代表这是个soap协议

内容是用<soap:Body>来定义的
内部第一个是可以是命名空间，再内部就是属性和值了。







*****************************************
线程池的使用：
java通过Executors提供四种线程池：

ExecutorService cacheThreadPool = Executors.newCacheThreadPool();
1，newCacheThreadPool创建一个可缓存线程池。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
cacheThreadPool.execute(new Runnble())
每次使用execute()方法会运行一个线程，方法传参是一个Runnable对象。然后线程内就会自动运行Runnable对象的run方法。


ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
2，newFixedThreadPool(3)创建一个定长线程池，可控制最大的并发数，超出的线程会在队列中等待。


ScheduledExecutorService scheduledThreadPool = Excutors.newScheduledThreadPool(5)
3，newScheduledThreadPool（5）是创建一个定长线程池，并且支持定时及循环任务。
scheduledThreadPool.execute(Runnable对象，2，TimeUnit.SECONDS)
表示两秒后执行。2是延迟执行的时间，最后一个参数来表示时间单位。

scheduledThreadPool.execute(Runnable对象，2,3，TimeUnit.SECONDS)
表示两秒后执行，之后每3秒执行一次


ExecutorService singleThreadExecutor = Exectors.newSingleThreadExecutor();
4.newSingleThreadExecutor()创建一个单线程的线程池，只能一个线程，所有任务只能按照指定顺序来依次执行.



Executors的三种ExecutorsService的线程池构造方法，其实返回的都是ThreadPoolExecutor对象



ThreadPoolExecutor构造方法:
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, RejectedExecutionHandler handler) 

corePoolSize： 线程池维护线程的最少数量 
maximumPoolSize：线程池维护线程的最大数量 
keepAliveTime： 线程池维护线程所允许的空闲时间 
unit： 线程池维护线程所允许的空闲时间的单位 
workQueue： 线程池所使用的缓冲队列 
handler： 线程池对拒绝任务的处理策略 

线程池开始会建立corePoolSize个核心线程来出来任务。
如果任务请求大于核心线程数，就先把任务放到workQueue任务队列中。
核心线程空闲了，也会去任务队列中取任务来处理。
如果任务队列已经满了，就开始新建线程处理任务。
如果现在的任务线程数量，已经超过maximumPoolSize个，就用RejectedExecutionHandler来做拒绝请求。
keepAliveTime就是，当线程数大于coorPoolSize时候，多余的线程会等待keepAliveTime秒，如果到时间没有任务，就销毁。



workQueue的类型：
1、SynchronousQueue直接提交，当有任务要添加的时候，必须等待另一个的任务的移除。我理解的就是一个容量为1的任务队列。按照原则，任务队列满了，就会创建线程来处理。所有使用这个队列，也就是来了任务就直接新建线程来处理了。所以一般配合超大的maximumPoolSize来使用

2、LinkedBlockingQueue无界队列。也就是队列的容量是无限大的。永远都放不满的。也就不会新建线程来处理任务，只能等待核心线程处理完来执行

3、ArrayBlockingQueue有界队列，也就是可以设置个队列的数量。
new ArrayBlockingQueue<Runnable>（3）	这样就是表示，可以存储3个任务。




ThreadPoolExecutor的submit方法
使用submit方法可以返回一个Future对象，这个Future对象可以来接受返回值或者控制线程；
Future <?> future = threadPool.submit(Runnbale或者Callback对象)

future.get()
调用future.get()方法，就可以得到线程返回的值了。
如果在主线程中，调用get方法，那么主线程就会一直阻塞在那，等待子线程完成，然后返回值。
如果子线程是个runnbale对象，那么返回值就是个空null

Callable的使用方法：
类似Runnable的一个类。
Callable <String> callable = new Callable<String>(){
	public <String> call throws Exception{
		return null；
	}
}
当做线程体的时候，会自动执行call方法。比着runnable，这个是可以有返回值的。

这样futrue调用get方法，就可以获取到返回值了。


future的cancel方法：
future的两个功能之一，控件线程
future.cancel(true)
cancel方法就是要，取消任务。如果任务还没有运行，就直接阻止再运行了。
后面的参数布尔值，就是说，如果任务已经运行了，是否还阻止任务，true就是阻止，false就是不阻止了。
cancel方法的原理，起就是给线程的一个属性interrupt设置为为true。
在线程中，可以判断当前现在的interrupt属性是否设置为true，阻止状态了，如果是，就做出怎么的处理
boolean b = Thread.current.isInterrupt()


future.isCancelled()
future.isDone()
cancel调用返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。 







*****************************************************
MOB SMSSDK的使用：

把下载的sdk中的lib文件夹中的文件，全部复制到自己项目的lib中。
然后在Mainfest中添加权限，在Application中添加Activity。

在代码中，初始化SDK
SMSSDK.initSDK(this，key，密钥)

然后新建一个EventHandler，给SMSSDK注册上。

EventHandler eventHandler = new EventHandler(){
	@Override
   public void afterEvent(int event, int result, Object data) {
	super.afterEvent(arg0, arg1, arg2);
	Message message = new Message();
	message.arg1 = event;
	message.arg2 = result;
	message.obj = data;
	handler.sendMessage(message);
	}
    };
SMSSDK.registerEventHandler(eventHandler);

这个是用来接收返回的结果的，因为是在子线程中，所以还需要自己新建一个handler来转发这个信息到主线程中处理。


申请发送验证码的方法：
SMSSDK.getVerificationCode(国家码，手机号码)
都是String类型的，国家码中国就是86


校验验证码的方法：
SMSSDK.submitVerificationCode(国家码，手机号码，验证码)



最后在handler的handlerMessage方法中，可以判断event和result来做处理

result是状态，如果是SMSSDK.RESULT_COMPLETE，就是返回成功
否则就是失败了。

event是类型，来判断是什么请求返回的。
	SMSSDK.EVENT_SUBMIT_VERIFICATION_CODE		提交验证码
	SMSSDK.EVENT_GET_VERIFICATION_CODE		发送验证码
	SMSSDK.EVENT_GET_SUPPORTED_COUNTRIES		获取国家列表
hanlder中的data就是返回国家列表信息。


最后在ondestory中，解除注册EventHandler
SMSSDK.unregisterAllEventHandler();










***********************************
PullToRefresh的使用：
导入PullToRefresh项目的时候，必须把这个项目复制到工作区。

然后在自己项目内，导入library。

设置监听器：
mListView.setOnRefershListener(new OnRefershListener<ListView>)
有个onRefresh方法，可以在里面写，更新刷新操作。
下拉的时候，会触发这个监听器。

更新后，需要调用onRefreshComplete方法，来关闭加载动画。【这个必须有延时后才能成功的】
mListView.setOnRefreshComplete()

mListView.setMode(Mode.BOTH);
设置刷新模式
Mode.PULL_FROM_START);		//向上拉刷新
Mode.BOTH);			//两端刷新
Mode.PULL_FROM_END);		//向下拉刷新
设置刷新模式，最好在getLodingLayoutProxy()之前。否则getLoding的时候，只能获取到头部Layout，设置各种参数，也都是只设置在头部Layout上了。

如果要单独获取头部Layout或底部Layout来设置，可以用getLodingLayoutProxy(true,false)方法，
两个参数就是是否要头部和底部的。


ILoadingLayout layoutProxy = mListView.getLoadingLayoutProxy();
layoutProxy.setPullLabel("使劲拉");			
layoutProxy.setRefreshingLabel("正在使劲加载呢...");
layoutProxy.setReleaseLabel("松手去加载啦！！");
layoutProxy.setLoadingDrawable(getResources().getDrawable(R.drawable.icon_head2));
这个是设置加载时显示的图片

layoutProxy.setLastUpdatedLabel("2015年");
这个可以在刷新加载的时候，设置上上次加载的时间。


刷新模式设置成下拉刷新的时候，需要设置OnRefershListener监听器
如果设置成两端刷新或者上拉刷新，需要设置OnRefershListener2监听器，加载上拉和下拉的两个监听方法。


设置独有参数：
ptr:ptrAnimationStyle = "flip" 或者rotate   翻转和旋转。会出现不同的提示图片
需要添加一个命名空间 xmlns:ptr="http://schemas.android.com/apk/res-auto" 
ptr:ptrDrawable =""	设置上下拉时候，显示的提示图片
ptr:ptrHeaderBackground="@color/default_bg"	  设置头部view的背景色
ptr:ptrHeaderSubTextColor="@android:color/black"
ptr:ptrHeaderTextColor="@android:color/black"






上下拉提示布局的使用：
最上面是一个ImageView和一个ProgressBar，下面两个是提示文字和二级提示文字。
ImageView就是在拉的过程中，运行翻转或旋转动画的部分。
而在加载过程中，播放动画的是：

progressbar是在设定翻转模式下，来播放动画的，默认就是一个系统progress样式。
在旋转模式下，就直接是让ImageView来旋转的。

layoutProxy.setLoadingDrawable（）方法，设置的就是ImageView的图片。
progressbar的样式，可以自己手动去xml中定义了。








**********************************************
新浪微博的api使用：
先去注册开发者账号，然后创建应用。

重要的应用信息：
android包名：就是com.XX.XXX
android签名：使用新浪提供的签名工具，生产签名

应用地址：授权回调页：取消授权回调页：
这三个要使用同一个地址。先使用微博提供的默认地址吧


导入SDK的library，最后让SDK和项目在同一目录下，在引入Library
加入要求的权限



1、Auth登录授权
1）.初始化AuthInfo信息：
Auth auth = new AuthInfo(Content，微博key，redirectUrl地址，scope)	可以看文档

2）.初始化SsoHandler对象：
SsoHandler ssoHandler = new SsoHandler（Content，auth对象）

3）.开始授权：
ssoHandler.authorizeClientSso（WeiboAuthListener接口监听器对象）
	**仅客服端登陆
ssoHandler.authorizeWeb(监听器对象)
	**仅web登陆
ssoHandler.authoirze(监听器对象)
	**All in one如果有客服端，就客服端，如果没有就网页。
如果需要网页登陆授权，需要在manifest文件中，添加一个微博网页的activity：
<activity 
     android:name="com.sina.weibo.sdk.component.WeiboSdkBrowser" 
     android:configChanges="keyboardHidden|orientation"
     android:windowSoftInputMode="adjustResize"
     android:exported="false" >
</activity>

还需要重写Activity的onActivityResult方法，调用ssoHandler的callBack方法：
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (mSsoHandler != null) {
        mSsoHandler.authorizeCallBack(requestCode, resultCode, data);
    }
}

【我认为，应该是初始化的时候，就添加两个参数，上下文和auth对象，然后发送请求授权的时候，在请求授权方法的同时，顺便添加一个设置接口的方法而已。在请求授权方法的内部，应该是用一开始传入的Content对象，跳转到微博授权页面，然后跳转回来的同时，ssoHandler再使用一个callback方法，把数据传输到监听器方法中。】

监听器接口的三个方法：
public void onCancel()					用户取消授权
public void onComplete(Bundle arg0)			授权成功
public void onWeiboException(WeiboException arg0)	授权错误arg.getMessage是错误信息


在授权成功的方法中，arg0就是返回的信息，使用一个sdk提供的静态方法，提取Token对象
Oauth2AccessToken mAccessToken = Oauth2AccessToken.parseAccessToken(arg0)

mAccessToken.isSessionValid()			是否有效
long time = mAccessToken.getExpiresTime()	
	**返回token的有效时间，是以秒为计算的。	
String token = mAccessToken.getToken()		获取token值

如果mAccessToken是无效的，可以从arg0中提取错误码，arg0.getString（"code"）





2、分享微博
需要在要接受消息，发送分享的Activity的manifeset标签中，加入一个intent-filter
<intent-filter>
    	<action android:name="com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY" />
    	<category android:name="android.intent.category.DEFAULT" />
</intent-filter>

然后在onCreate函数中，初始化接口对象，并进行注册；
IweiboShareAPI weiboAPI = WeiboShareSDK.createWeiboAPI(Content,申请的key)
weiboApi.registerApp()	进行注册


唤起微博客服端进行分享：

新建一个文本消息对象：
TextObject textObject = new TextObject();
textObject.text = "这是一个文本消息"

然后新建一个微博消息对象：
WeiboMultiMessage weiboMessage = new WeiboMultiMessage()
把文本消息赋值给微博消息对象的文本消息对象
weiboMessage.textObject = textObject

最后新建一个微博消息请求对象
SendMultiMessageToWeiboRequest request = new SendMultiMessageToWeiboRequest（）
给两个变量赋值：
request.transaction = String.valueOf(System.currentTimeMillis());
request.multiMessage = weiboMessage;
transaction赋值上当前时间当做唯一标识。

最后发送就可以了
mWeiboShareAPI.sendRequest(WBShareActivity.this, request);









QQ分享类型：

分享到QQ空间：
有两种类型，一种就是分享一个链接，和分享到qq好友基本一样，类型什么的都一样。会显示一个小card的形式。
最后发送必须用shareToQzone方法，使用的是QzoneShare的静态参数

另一种是发表说说，可以发表心情（图文），和发表视频。
发送使用publishToQzone方法。使用的是QzonePublish的静态参数


params.putInt(QzoneShare.SHARE_TO_QZONE_KEY_TYPE, shareType);
设置分享类型
类型有：
QzoneShare.SHARE_TO_QQ_TYPE_DEFAULT 			分享图文 
QzoneShare.SHARE_TO_QZONE_TYPE_IMAGE_TEXT
QzoneShare.SHARE_TO_QQ_TYPE_IMAGE 			分享纯图
QzoneShare.SHARE_TO_QZONE_TYPE_APP;			分享app

QzonePublish.PUBLISH_TO_QZONE_TYPE_PUBLISHMOOD		发布心情（图文）
QzonePublish.PUBLISH_TO_QZONE_TYPE_PUBLISHVIDEO;	发布说说视频











ImageLoader的使用：
下载jar包，然后放在lib下。
给jar包连接sources和javadoc
先把这资源和文档jar包，放在一个文件夹内，可以新建一个libsrc文件夹，放进去
然后在libs文件夹中，新建一个文件，命名为xxxxx.jar.properties
里面写以下内容。
src=../libsrc/universal-image-loader-1.9.5-sources.jar
doc=../libsrc/universal-image-loader-1.9.5-javadoc.jar
然后重启就可以了。


在Android studio中引入依赖：
compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.5'



然后在Application的onCreate中，配置ImageLoader。
ImageLoaderConfiguration configuration = ImageLoaderConfiguration.createDefault(this);   
ImageLoader.getInstance().init(configuration);  
创建一个默认的配置，然后给ImageLoader。

也可以自己创建一个配置对象。
ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)
.memoryCacheExtraOptions(480, 800) // default = device screen dimensions 内存缓存文件的最大长宽
.diskCacheExtraOptions(480, 800, null)  // 本地缓存的详细信息(缓存的最大长宽)，最好不要设置这个 
.taskExecutor(...)

.taskExecutorForCachedImages(...)

.threadPoolSize(3) // default  线程池内加载的数量

.threadPriority(Thread.NORM_PRIORITY - 2) // default 设置当前线程的优先级

.tasksProcessingOrder(QueueProcessingType.FIFO) // default

.denyCacheImageMultipleSizesInMemory()

.memoryCache(new LruMemoryCache(2 * 1024 * 1024)) //设置内存缓存，不设置默认是1/8

.memoryCacheSize(2 * 1024 * 1024)  // 内存缓存的最大值，不设置默认是1/8

.memoryCacheSizePercentage(13) // default

.diskCache(new UnlimitedDiscCache(cacheDir)) // default 可以自定义缓存路径  

.diskCacheSize(50 * 1024 * 1024) // 50 Mb sd卡(本地)缓存的最大值

.diskCacheFileCount(100)  // 可以缓存的文件数量 

.diskCacheFileNameGenerator(new HashCodeFileNameGenerator())   默认就是Hash...这个

.imageDownloader(new BaseImageDownloader(context)) // default

.imageDecoder(new BaseImageDecoder()) // default
.defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default
.writeDebugLogs() // 打印debug log
.build(); //开始构建 


基本上都不用设置的，都用默认的就可以，只设置一个本地缓存的大小就行。




显示图片，先获取对象;ImageLoader imageLoader = ImageLoader.getInstance();

下载图片功能：
Loadimage（）
imageLoader.loadImage(地址，ImageSize对象，options，监听器)
ImageSize mImageSize = new ImageSize(100, 100);  用于指定大小呢。
监听器ImageLoadingListener接口，有4个方法，开始，取消，成功，失败的回调。

如果不指定options对象，会自动调用一个默认的对象的。


options对象，用于指定图片的一些设定：


DisplayImageOptions options = new DisplayImageOptions.Builder()
.showImageOnLoading(R.drawable.ic_stub) // 设置图片下载期间显示的图片
.showImageForEmptyUri(R.drawable.ic_empty) // 设置图片Uri为空或是错误的时候显示的图片
.showImageOnFail(R.drawable.ic_error) // 设置图片加载或解码过程中发生错误显示的图片
.resetViewBeforeLoading(false)  // default 设置图片在加载前是否重置、复位
.delayBeforeLoading(1000)  // 下载前的延迟时间
.cacheInMemory(false) // default  设置下载的图片是否缓存在内存中
.cacheOnDisk(false) // default  设置下载的图片是否缓存在SD卡中

.preProcessor(BitmapProcessor preProcessor)   //设置图片加入缓存前，对bitmap进行设置 
.postProcessor(BitmapProcessor postProcessor)   //设置显示前的图片，显示后这个图片一直保留在缓存中 
.extraForDownloader(Object extra)     //设置额外的内容给ImageDownloader  
.considerExifParams(false) // default
.imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default 设置图片以如何的编码方式显示
.bitmapConfig(Bitmap.Config.ARGB_8888) // default 设置图片的解码类型
.decodingOptions(...)  // 图片的解码设置
.displayer(new SimpleBitmapDisplayer()) // default  普通的
         new RoundedBitmapDisplayer(20)  还可以设置圆角图片
.handler(new Handler()) // default
.build();


一般设置下保存在内容和sd卡这两个，和下载失败的显示图片，和圆角普通，和缩放类型。



.imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default 设置图片以如何的编码方式显示
imageScaleType(ImageScaleType imageScaleType)  
imageScaleType:  
EXACTLY :图像过大时，会把宽度或高度，缩小到和控件的宽或高完全一样大小，另一个尺寸会按照同比例缩小，但是图片小于控件的话，是不会放大的。
EXACTLY_STRETCHED:和上面一样，只是太小的时候，会放大的。

IN_SAMPLE_INT:图像将被二次采样的整数倍  
IN_SAMPLE_POWER_OF_2:图片将降低2倍，直到下一减少步骤，使图像更小的目标大小  
这两个就和手动缩小图片那个方法一样，会2的倍数会缩小。

NONE:原始大小  

Imagelader加载图片的时候，是会先查看ImageView的宽高的，然后根据宽高去缩放。如果ImageLoader获取不到宽高，缩放就会失败了。可以使用：
imgView.post()方法，把加载方法写在post的runable中，这样ImageLoader就可以获取到宽高了。



.displayer(new SimpleBitmapDisplayer()) // default  还可以设置圆角图片new 
displayer(BitmapDisplayer displayer)  
displayer：  
          RoundedBitmapDisplayer（int roundPixels）设置圆角图片  
          FakeBitmapDisplayer（）这个类什么都没做  
          FadeInBitmapDisplayer（int durationMillis）设置图片渐显的时间  
　　　  SimpleBitmapDisplayer()正常显示一张图片　　



显示图片功能：
DisplayImage（）
也是这几个参数，图片地址，控件对象，设置，监听器

ImageLoadingProgressListener接口，进度条回调，会传送进来进度值

如果图片地址，不是网络地址，而且本地的，使用方法：
//图片来源之本地file
String imageUrl = Scheme.FILE.wrap(imagePath);  

//图片来源于assets  
String assetsUrl = Scheme.ASSETS.wrap("image.png");  
          
//图片来源于  
String drawableUrl = Scheme.DRAWABLE.wrap(R.drawable.image + “”);  

String imageUri = "http://site.com/image.png"; // from Web  
String imageUri = "file:///mnt/sdcard/image.png"; // from SD card  
String imageUri = "content://media/external/audio/albumart/13"; // from content provider  
String imageUri = "assets://image.png"; // from assets  
String imageUri = "drawable://" + R.drawable.image; // from drawables (only images, non-9patch)  


ListView滑动过程中，不加载图片的设置;
PauseOnScrollListener OnScrollLis = new PauseOnScrollListener(loader, false, false);
创建一个PauseOnScrollListener对象；
这个对象应该是继承之OnScrollListener的。也就是ListVew设置滑动监听的那个接口。
后面两个参数，滑动的时候是否加载，飞速滑动的时候，是否加载。

然后给ListView对象设置上就可以了。
listVIew.setOnScrollListener(pauseOnScrollListener);







D/dalvikvm(  745): GC_CONCURRENT 
freed 199K, 53% free 3023K/6343K,external 0K/0K, paused 2ms+2ms 
GC_CONCURRENT表示触发垃圾收集的原因，有以下几种：



GC_MALLOC, 内存分配失败时触发
 

GC_CONCURRENT，当分配的对象大小超过384K时触发
 

GC_EXPLICIT，对垃圾收集的显式调用(System.gc)
 

GC_EXTERNAL_ALLOC，外部内存分配失败时触发

freed 199K表示本次垃圾收集释放了199K的内存， 

53% free 3023K/6343K，其中6343K表示当前内存总量，3023K表示已用内存，53%表示可用内存占总内存的比例。 

external 0K/0K，表示可用外部内存/外部内存总量 
paused 2ms+2ms，第一个时间值表示markrootset的时间，第二个时间值表示第二次mark的时间。如果触发原因不是GC_CONCURRENT，这一行为单个时间值，表示垃圾收集的耗时时间。 













**************************************************************
系统剪贴板：

ClipboardManager cm = context.getSystemService(Context.CLIPBOARD_SERVICE);  

复制文本到剪贴板
cm.setText(String)

读取剪贴板的内容
cm.getText().toString();


********************


获取控件的位置XY坐标：
int[] location = new int[2];
txt.getLocationInWindow(location);
txt.getLocationOnScreen(location);
这样location数组就包含了XY坐标值了。location[0]就是X的值
这个XY值指的是，View控件的左上角的XY值。

getLocationInWindow（）是获取在Window对象中的坐标值，
getLocationOnScreen（）是获取在屏幕上的绝对坐标值。
一般情况下Window是充满全屏的，那么两个值就是一样，如果Window不是全屏的，那就不一样了，比如在Dialog中。


********************

view.performClick(); 	模拟点击效果

关闭屏幕后，没有完成的操作还是会接着进行的。

ViewConfiguration.getTapTimeout()
获取点击点击事件的超时毫秒数。在这个毫秒数内，就算是点击的。


********************

PowerManager的使用：
PowerManager pm = getSystemService(Context.POWER_SERVICE)

WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP , "tag");
使用这个方法得到一个WakeLock对象，方法参数1是类型，2是自己设置的tag标签
类型有下面几种：
PARTIAL_WAKE_LOCK :保持CPU 运转，屏幕和键盘灯是关闭的。

SCREEN_DIM_WAKE_LOCK ：保持CPU 运转，允许保持屏幕显示但有可能是灰的，关闭键盘灯

SCREEN_BRIGHT_WAKE_LOCK ：保持CPU 运转，保持屏幕高亮显示，关闭键盘灯

FULL_WAKE_LOCK ：保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度

ACQUIRE_CAUSES_WAKEUP: 一旦有请求锁时，强制打开Screen和keyboard light
应该是强制唤醒屏幕，实际需要配合上面的几种使用。

ON_AFTER_RELEASE: 在释放锁时reset activity timer

wl.acquire();
然后调用WakeLock对象的acquire方法，就执行了。
屏幕在亮着的情况下，就会按照选择的类型，保持亮度。


在手机锁屏熄屏的情况下，要让手机屏幕亮起。需要使用ACQUIRE_CAUSES_WAKEUP和其他类型配合。
pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | (PowerManager.ACQUIRE_CAUSES_WAKEUP , "tag");


wl.release();
使用后，要及时的释放掉，不让屏幕就会一直这样的。不会熄屏了。
注意：如果没有执行过acquire方法，就使用这个方法，是会报异常的。


权限
<uses-permission android:name="android.permission.WAKE_LOCK"/>  
<uses-permission android:name="android.permission.DEVICE_POWER"/>  



********************

锁屏的管理
KeyguardLockManager的使用：

KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
实例化对象

boolean b = km.inKeyguardRestrictedInputMode()
此方法会返回当前锁屏状态，返回true就是锁屏，返回false就是没有锁屏。





setClickable:设置控件是否可以被点击，如果为false就是不可以点击的；
PS：如果设置这个属性后，再设置控件的OnClickListener，就会失效了，因为设置点击监听事件时，会自动把Clickable设置成true的。
也就是说，如果想让这个设置有效，那么就要在点击监听事件之后再设置，才会有效的。

setEnabled:设置控件是否可用

setFoucusable：设置控件是否可用获得焦点






*******************************************
点九.9切图。
左边和上边的选择区域，是用来控制放大拉伸的区域
右边和下边两个交叉的区域，就是用来显示内容的，也相当于是设置内容的padding内边距。







接口名都以I前缀
成员变量以m开头，静态变量以s开头；
@Deprecated放在一个方法或者类上，就会让IDE弹出提示，不再建议使用。

注释：
同类型的可以分块并紧凑定义
字段的顺序，显示公有的常量，私有的常量，子类可以继承的变量，私有的变量
方法的顺序，也是尽量这个顺序。
传递参数的说明都对齐。
    /**
     * 公有方法描述...
     * 
     * @param param1  参数1描述...
     * @param param2  参数2描述...
     * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）
     */
方法内部的注释标签类型：
     // TODO  使用TODO来标记代码，说明标识处有功能代码待编写
     // FIXME 使用FIXME来标记代码，说明标识处代码需要修正，甚至代码是
     //       错误的，不能工作，需要修复
     // XXX   使用XXX来标记代码，说明标识处代码虽然实现了功能，但是实现
     //       的方法有待商榷，希望将来能改进

if语句，必须写上{大括号}，内部只有一行，也要写上，多重条件判断，要是用小括号（）要避免运算优先级的问题。

switch语句，每一个case之间，空一行。必须要有default语句；

for语句，尽量是用foreach语句

类默认注释：
Window-Preferences-Java-Code Style-Code Template-Types 点编辑
使用这个格式
/**
 * @author XDH
 * @date ${date}
 */







DecimalFormat数字格式工具：
DecimalFormat format = new DecimalFormat("0.00")
String str = format.format(1.22324);

使用指定的格式，来格式化数字。
主要分成小数点前后两部分，主要使用0和#。0是不够了，会自动补0，#是不会补0的
小数点前的是指至少要有几位，00.00就是至少要有两位，如果格式化的数只有1位，如果使用0了，就自动前面补0。#就不补了。如果有3位，那就不管了。
小数点后的，是限定必须有几位的，如果不够就补0，如果多了就四舍五入。使用#的话，就不会自动补0.

.前面的部分还可以使用-负号的。
如果不加.的话，就是不要小数点后的部分了。
如果直接.000就是不限制前面的部分


0,000.00
，就是用来做分隔符的。

####，##，00
如果使用多组规格的话，整个数字会重复使用最后一段的规则。








排序方法：
冒泡排序方法：
简单思路：
让第一个和第二个比较，把最大数给第二个，然后第二个和第三个比较，把最大数给第三个...一遍比较完毕，最大数就在最后一位了。
第二遍再次从第一个相邻比较，把最大的放在倒数第二个。

另一个基本一致的思路：
拿第一个和，后面所有的数，比大小，如果后面的小，就把小的放在第一个；
拿第二个和，后面所有的数，比大小，如果后面的小，就把小的放在第二个；






观察者模式：
先新建一个监听接口，写一个操作方法，规定下传入的参数。这个方法，就是接到接听后，所有注册监听的类，要完成的操作。
新建一个观察者类
一个注册监听器接口，把传入的监听器对象，放入到list中。
一个注销监听器接口，把传入的监听器对象，从list中移除。

触发监听的方法：
遍历监听器list，挨个调用监听器的操作方法。




**************************




自动弹起输入法软键盘：
final InputMethodManager imm= (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
tv.postDelayed(new Runnable() {
	@Override
	public void run() {
		imm.showSoftInput(tv, 0);
	}
}, 500);

先获取软键盘管理器对象，然后使用showSoftInput方法就可以了。
inputMethodManager.showSoftInput(tv, 0);
参数是要对焦的文本控件。
加postDelayer是因为，加载的时候有可能会正在创建而失效。


获取打开状态
boolean isOpen=imm.isActive();//isOpen若返回true，则表示输入法打开  

隐藏软键盘，后面参数是flag
imm.hideSoftInputFromWindow(CopyOfMainActivity.this.getCurrentFocus().getWindowToken(), 0);
为了防止报空，可以先判断下getCurrentFocus（）是否为空，再做隐藏操作。
if (null != mContext.getCurrentFocus()) {
	imm.hideSoftInputFromWindow(mContext.getCurrentFocus().getWindowToken(), 0);
。}

切换软件状态，如果是显示的，就隐藏，参数都是flag
imm.toggleSoftInput(0, 1); 



点击EditText时，不弹出输入法的方法：
text.setOnTouchListener(new OnTouchListener() {

	@Override
	public boolean onTouch(View v, MotionEvent event) {
		int inType = mWeightTv.getInputType(); 
		mWeightTv.setInputType(InputType.TYPE_NULL);  
		mWeightTv.onTouchEvent(event); 
		mWeightTv.setInputType(inType);			
      	 	return false;   
	}                    
});


进入含有EditText的页面时，禁止自动弹出输入法的方法：
在EditText的父布局上，写上：
android:focusable="true"
android:focusableInTouchMode="true"





********************************







windowSoftInputMode属性
在mainfest文件中，activity的标签，可以设置android:windowSoftInputMode属性

***********
如果不设置属性默认为adjustUnspecified
EidText所在布局没有使用SrollView：
如果输入框在布局的下面：
输入法弹出的时候，会把布局往上推一些，调整到EditText正好在输入法的上面。这时候布局是不能滚动的。


EditText所在的布局使用了SrollView：
输入法弹起的时候，就会把SrollView的，高度缩小为SrollView上面的控件到输入法之间的距离。
ScrollView上面的控件是不会变动的。只会压缩ScrollView的高度的。而且SrollView可以自由滚动的。

如果EditText在布局的下面：
会把SroolView滚动到EditText正好在输入法的上面。
如果EditText在布局的上面：
那就是简单的缩小SrollView的高度，也不用滚动ScrollView调整位置了。




***********
如果设置属性为adjustPan
EidText所在布局没有使用SrollView：
效果同adjustUnspecified的（EidText所在布局没有使用SrollView：）一样。


EditText所在的布局使用了SrollView：
也是把输入框调整到输入法的上面，但是不会把滚动控件缩小显示范围，而且滚动控件也可以完全滚动了。只能上下移动一点布局。




***********
如果设置属性为adjustResize ：
EditText所在的布局没有使用SrollView：
布局完全不会动的，如果输入框在布局的下面，那么输入法弹出后，就直接遮盖住EditText了。

EditText所在的布局使用了SrollView：
效果同adjustUnspecified的（EditText所在的布局使用了SrollView）一样。




***********
如果布局是，ListView下面有个布局，布局内有EdiText。
那么点击EditText弹出输入法的时候，输入法会弹起显示在所有布局的下面，不是EidtText的下面哦。EdiText的所在布局不会缩放什么的，整个布局中会自动缩小ListView的高度来适应。




一般EditText 点击后，输入法自动调整布局，默认是调整到，输入法正好在文字之下的，如果EditText高度不是wrap_content，那输入法就不是在EditText下面了。这样并不太好看的。
可以设置paddingBottom，设置后，输入法就会显示在，文字+paddingBottom之下了。





****************************




EditText的imeOptions属性
设置后，可以让输入法的回车键变成指定的样式；
actionNext		会变成“下一步”，点击后会自动跳转到下一个输入框
actionDone		不会变，还是个回车图标，点击后会隐藏输入法
actionGo		会变成“开始”
actionSend		会变成"发送"

使用的时候，要把控件设置为单行的
android:singleLine="true"

在代码中设置
editText.setImeOptions(EditorInfo.IME_ACTION_SEARCH);  

设置监听：
setOnEditorActionListener （new OnEditorActionListener）
	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
		return false;
	}
通过判断actionId来判断 是点击了什么样式。EditorInfo.IME_ACTION_NEXT
return返回的是否拦截消费，系统会点击后隐藏或者调整到下一个，如果返回true就拦截了系统的操作。







**************************
Html.fromHtml()方法
可以给TextView设置html格式的文本
Html.fromHtml("<font color = #ff0000 >" + "测试" + "</font><br>" + "字体"））
<font>设置字体颜色
<br>换行






SpannableString的用法：
SpannableString span = new SpannableString("这是个测试字符串");
先用一个字符串来构造生成，然后调用setSpan方法，就可以设置文本效果了。

span.setSpan(object,start,end,flags)
object就是各种文本效果对象。
start，end就是要设置文本的开始位置和结束问题，包前不包后
flags，效果有效的范围，SpannableStringBuilde插入时用，或者在EditText那里用。
Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括，即在指定范围的前面和后面插入新字符都不会应用新样式
Spannable.SPAN_EXCLUSIVE_INCLUSIVE ：前面不包括，后面包括。即仅在范围字符的后面插入新字符时会应用新样式
Spannable.SPAN_INCLUSIVE_EXCLUSIVE ：前面包括，后面不包括。
Spannable.SPAN_INCLUSIVE_INCLUSIVE ：前后都包括。


字体颜色设置：
FroregroundColorSpan
span.setSpan(new ForegroundColorSpan(0xff0000), 0, 2, Spannable.SPAN_EXCLUSIVE_INCLUSIVE)
这样就使用了。其他的效果也是类型的。

字体背景颜色：
new BackgroundColorSpan(0xff0000)


字体大小：
new AbsoluteSizeSpan(16)


粗体斜体：
new StyleSpan(Typeface.BOLD_ITALIC)


删除线：
new StrikethroughSpan()


下划线：
new UnderlineSpan()






***************************
WheelView的使用：
下载代码，然后把代码拷贝到自己项目中。

修改中间选中框的样式：
修改WheelView类中的drawCenterRect方法
//centerDrawable.setBounds(0, center - offset, getWidth(), center + offset);
//centerDrawable.draw(canvas);
Paint paint = new Paint();
paint.setColor(mColorLine);
canvas.drawLine(0, center - offset, getWidth(), center - offset, paint);
canvas.drawLine(0, center + offset, getWidth(), center + offset, paint);
上面原有两行注释或者删除，然后下面新增代码绘制两条线。


修改前景色：就是这上部和下部显示遮罩效果的。这三个是渐变色
修改WheelView类静态变量数组：
SHADOWS_COLORS  = new int[] { 0x00000000,0x00000000, 0x00000000 }
如果不需要的话，把这个都设置为透明就可以了。
也可以设置成自己需要的渐变色。比如下面这个，白色渐变的
{ 0xFFFFFFFF,0xAAFFFFFF, 0x77FFFFFF }

遮罩层高度的话，默认是1.5个item高的。
如果要修改的话，修改WheelView类中的drawShadows方法
修改高度为指定个item高。





修改wheelView类中的参数：
wheelBackground = 0x00000000


修改最多显示多少个：
wheelView.setVisibleItems(7);
这个方法，只能适用于控件高度设置与包括内容才行的。
如果是指定高度和充满的话，就是安装当前的文字大小，然后设置出现的个数。

设置文字的大小：
新建一个adapter，extends继承之AbstractWheelTextAdapter
然后自己手动重写个方法：中间有行就是这种字体大小的
	@Override
	public View getItem(int index, View convertView, ViewGroup parent) {
		if (index >= 0 && index < getItemsCount()) {
			if (convertView == null) {
				convertView = getView(itemResourceId, parent);
			}
			TextView textView = getTextView(convertView, itemTextResourceId);
			textView.setTextColor(Color.BLACK);
			textView.setText(getItemText(index));
			textView.setGravity(Gravity.CENTER);
			textView.setLines(1);
			textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16);
			return convertView;
		}
		return null;
	}

还有两个方法：
getItemCount（）	就是返回总数的
getItemText（）		这个参照ArrayWheelAdapter这个类，复制过来就可以了。



其实也可以使用ArrayWheelAdapter这个自带的。
然后设置字体大小和颜色。
ada.setTextSize();
ada.setTextColor();

还可以设置两个：
ada.setItemResource(R.layout.item_style)
给item设置一个自定义的布局。		
ada.setItemTextResource(R.id.text_style);
给Item设置TextView的自定义布局

这两个必须要同时设置的。
要设置自定义布局的时候，自定义布局中一定要有个TextView控件，然后也要设置TextView的id进来。


setViewAdapter		设置适配器
addChangingListener 	设置滚动监听器，接口会返回到当前居中的item号position


数据集合一旦用于Wheel的adapter数据源后，数据可能会被破坏，数据丢失什么的。滚动后，再获取里面的数据时，就会发现有可能某个位置那没有数据了。
所以数据集合要多生成一个备用。


wheelView.setCurrentItem()	手动指定当前item位置





资源文件夹对应的尺寸大小：
mdpi		120dpi-160dpi
hdpi		160dpi-240dpi
xhdpi		240dpi-320dpi
xxhdpi		320dpi-480dpi
xxxhdpi		480dpi-640dpi

系统会根据手机dpi来找对应文件夹的资源。
dpi是由手机物理尺寸和分辨率组成的。
通过这个方法，可以返回dpi。getResources().getDisplayMetrics().densityDpi
小米note 5.7寸手机，1080p分辨率，是440的dpi










VelocityTracker速率检测
初始化：
VeloctiyTracker vt = VelocityTracker.obtain();

添加进去MotionEvent触摸事件。
vt.addMovement(event)
这个是要每次触摸都要添加的，直接写在onTouchEvent方法中。

添加速度单位：
vt.computeCurrentVelocity(int units, float maxVelocity)
units，就是指自己求的是，多少毫秒内运动的像素。比如1000，就是计算返回1秒内走了多少像素。
maxVelocity,就是返回的最大值，如果指定毫秒内运动的像素值超过了最大值，就返回最大值

获取指定轴上的计算值：
float xVerlocity = vt.getXVelocity()
获取X轴的移动值。正常翻下一页的操作，手指从右往左滑动，返回的值是负的。从左向右返回的正值。一般以800-1000的速度算作是快速滑动算作想翻页呢。






*****************************************
AndroidStudio使用

按住Ctrl键，然后点击标签页，会显示当前标签页所在文件目录

Ctrl+Alt+方向左键，跳转到上次编辑的位置

Alt+Enter	快速修复（类型转换等）

Ctrl+Shift+Enter，代码自动补全

Ctrl+N		快速查找类

Ctrl+Shift+N	快速查找所有文件

双击Shift	查找任意

Alt+左键+拖动	拖动可以选择多行代码，然后批量改写

F2		快速跳转到错误处

Ctrl+E		最近浏览过的文件

Ctrl+F12	显示当前类的元素

Ctrl+P		显示方法的参数类型
                                                                                         Shift+F6	重命名变量名或方法名                      

Ctrl+G		快速跳转到指定行

Ctrl+Alt+O	快速导包

Ctrl+Shift+I	在方法上按此快捷键，显示方法内容，和所在类

Ctrl+X		删除当前行

Ctrl+Shift+空格	代码提示

Ctrl+Alt+L	格式化代码

Ctrl+R		替换

Alt+Insert键	快捷操作菜单

fori会提示快速生成for循环

Ctrl+J		显示代码补全


GetSet
Alt+Insert键，选择Getter and Setter，然后按住Ctrl多选。




GsonFormat使用
Alt+Insert，然后选择GsonFormat，下次使用直接按Alt+S








*********************************************************
Glide的使用
依赖    compile 'com.github.bumptech.glide:glide:3.7.0'


基本加载图片：
Glide.with(Context).load(图片地址).into(ImageView);
	图片地址可以是：资源id；网址字符串；File对象；File路径字符串；


设置加载中占位符和加载错误图片：
Glide.with(Context).load(图片地址).placeholder(图片地址).error(图片地址).fallback(图地址).into(ImageView);
	placeholder是占位符，error是加载错误图，fallback是加载图片地址为null是显示的图片，这三个图片地址都只能是资源ID或者Drawable对象


缓存策略
Glide.with(Context).load(图片地址).diskCacheStrategy(DiskCacheStrategy.ALL).into(ImageView);
DiskCacheStrategy.ALL		会保存原资源和转换后的资源
none				什么都不保存
source				保存原资源
result				保存转换后的资源


加载动画：
Glide.with(Context).load(图片地址).animate(Animator).into(ImageView);
	可以自定义属性动画对象传入
默认动画是.crossFade()淡入淡出，还可以在自定义持续时间.crossFade(400)，默认的是300毫秒
不需要动画的话，设置.dontAnimate()


缩略图：
Glide.with(Context).load(图片地址).thumbnail(0.2f).into(ImageView);
	会先加载缩略图，然后再加载全图


设置缩略尺寸
Glide.with(Context).load(图片地址).override(735,300).into(ImageView);
	会根据传入的宽高，计算要缩放的比例，按照缩放比率最小的那个比率，来缩放图片的尺寸


显示方法：
.centerCrop()	.fitCenter()	就相当于XML布局中scaleType的一样


显示Gif：
Glide.with(Context).load(图片地址).diskCacheStrategy(DiskCacheStrategy.SOURCE).into(ImageView);
	加载Gif，需要设置缓存策略为保存原资源，或者None这两个，另两个经测不显示
	只显示Gif的第一帧图片，设置.asBitmap()


设置优先级：
priority(Priority.HIGH)
设置加载有限，有四个选择，LOW,NORMAL,HIGH,IMMEDIATE，从低到高。


监听方法：
.listenner(new RequestListener<图片地址类型，GlideDrawable>)
	要求重写两个方法，一个加载成功的，一个是加载失败的。参数中有原始的图片地址


下载图片功能：
Glide.with(Context).load(图片地址).asBitmap().into(new SimpleTarget<Bitmap>()）； 
先加入.asBitmap(),确定加载的是bitmap对象。然后写入加载监听
在重写的方法中，就会返回一个Bitmap对象了。
还可以设置图片大小，new SimpleTarget<Bitmap>(200,200)


使用自定义图片处理效果：
.transform
新建类继承BitmapTransformation，实现其方法，在这个方法中对图片处理。
  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
pool是图片缓存池，需要新建bitmap对象的时候，可以先试着从pool里面取。比如
Bitmap bitmap = pool.get(100,200,Bitmap.Config.ARGB_8888)
如果返回的bitmap对象为空，再重新创建bitmap对象。

toTransform就是需要加载的原图片（大小是原图的大小）
outWidth和H，是目标ImageView的大小

然后根据需求对原图进行圆角或圆形等等处理。需注意滤镜图层要使用原图的大小来创建

最后需要返回处理过的图片。（Glide会把处理的图片，放大或缩小到ImageView的大小去显示）






****************************************************
Android 6.0的权限申请：

在6.0的版本，隐私类的权限，需要主动申请。
Dangerous Permissions:
group:android.permission-group.CONTACTS
  permission:android.permission.WRITE_CONTACTS
  permission:android.permission.GET_ACCOUNTS
  permission:android.permission.READ_CONTACTS

group:android.permission-group.PHONE
  permission:android.permission.READ_CALL_LOG
  permission:android.permission.READ_PHONE_STATE
  permission:android.permission.CALL_PHONE
  permission:android.permission.WRITE_CALL_LOG
  permission:android.permission.USE_SIP
  permission:android.permission.PROCESS_OUTGOING_CALLS
  permission:com.android.voicemail.permission.ADD_VOICEMAIL

group:android.permission-group.CALENDAR
  permission:android.permission.READ_CALENDAR
  permission:android.permission.WRITE_CALENDAR

group:android.permission-group.CAMERA
  permission:android.permission.CAMERA

group:android.permission-group.SENSORS
  permission:android.permission.BODY_SENSORS

group:android.permission-group.LOCATION
  permission:android.permission.ACCESS_FINE_LOCATION
  permission:android.permission.ACCESS_COARSE_LOCATION

group:android.permission-group.STORAGE
  permission:android.permission.READ_EXTERNAL_STORAGE
  permission:android.permission.WRITE_EXTERNAL_STORAGE

group:android.permission-group.MICROPHONE
  permission:android.permission.RECORD_AUDIO

group:android.permission-group.SMS
  permission:android.permission.READ_SMS
  permission:android.permission.RECEIVE_WAP_PUSH
  permission:android.permission.RECEIVE_MMS
  permission:android.permission.RECEIVE_SMS
  permission:android.permission.SEND_SMS
  permission:android.permission.READ_CELL_BROADCASTS

判断是否获取到了权限
ContextCompat.checkSelfPermission（Context，String）
	String，传入静态参数，例如Manifest.permission.WRITE_EXTERNAL_STORAGE
会返回一个int值，可以通过系统变量对比，是否获取到了。
PackageManager.PERMISSION_GRANTED	已经获取到了
PackageManager.PERMISSION_DENIED	没有获取到权限


发起申请
必须在manifest中写明权限的，不写的话，只发起申请没用的。
ActivityCompat.requestPermissions(Activity，String[],int)
	申请的权限参数，需要用字符串数组。int是发起申请的识别码code，自定义
比如new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}，可以写入多个权限，系统会弹框让用户一一确认的。
	同一组内的权限，只申请一个，如果同意，那么同组其他的就会全部获得权限了。

	理论上是可以多次发起申请权限的。但是实际上，如果上次用户同意了，还可以发起，但是如果上次用户拒绝了，在实际手机系统上，可能就不能再发起申请权限了。


发起申请的回调方法：
直接重写Activity的onRequestPermissonsResult方法，会传入三个参数
int requestCode, String[] permissions, int[] grantResults
第一个就是申请识别码code
第二个是申请的权限字符串数组
第三个就是申请权限的结果，顺序都是按照申请时的顺序来的。



在原生系统中有效的方法：
ActivityCompat.shouldShowRequestPermissionRationale(Activity,String权限)
判定该权限是否已经被用户拒绝过一次了。
如果上次弹出申请权限，用户已经拒绝了，但是没有选"以后不再询问"，就会返回true。（下次还可以再次弹出申请框）
如果选了“以后不再询问”，那么就会返回false。（以后不会再弹出申请框，但是申请回调方法还会执行）

在miui系统中，权限申请框，如果选择拒绝，就默认是勾选了“以后不再询问”的。也就是会永远返回false。





*************************************************
AndPermission权限申请库使用
依赖    compile 'com.yanzhenjie:permission:1.0.7'

添加设置使用Lambda表达式
在defaultConfig中添加：
        jackOptions {
            enabled true
        }
在android中添加：
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

AndroidPermission.with(Activity)
		 .requestCode(int)
		 .permission(String)	权限字符串
		 .callback(PermissionListener)	接口两个方法，一个成功的，一个失败的
		 .rationale( ) 用于用户拒绝后，没有勾选“不再询问”的时候，显示的对话框传入这个(requestCode,rationale) ->
        AndPermission.rationaleDialog(MainActivity.this,rationale).show()
		 .start()


提示用户到设置页开启权限的对话框
可以写在监听器的失败方法中
AndPermission.defaultSettingDialog(this, REQUEST_CODE_SETTING).show();
也可以自定义对话框样式。
             AndPermission.defaultSettingDialog(this, REQUEST_CODE_SETTING)
                     .setTitle("权限申请失败")
                     .setMessage("我们需要的一些权限被您拒绝或者系统发生错误申请失败，请您到设置页面手动授权，否则功能无法正常使用！")
                     .setPositiveButton("好，去设置")
 		     .setNegativeButton(R.string.btn_dialog_no_permission, null)
                     .show();










***************************************
OKhttp的使用：
添加依赖：compile 'com.squareup.okhttp3:okhttp:3.2.0'

生成对象
okHttpClient mHttpClient = new okHttpClient（）

生成网址请求
Request request = new Request.Builder().url(“”）.build（）还可以设置多个参数

生成请求
Call call = mHttpClient.newCall(request)


异步GET请求（发起请求，并传入监听，返回结果方法都是在子线程中的）
call.enqueue(new Callback())
	public void onFailure(Call call, IOException e) 
        失败监听
        
        public void onResponse(Call call, Response response)
	成功监听。response就是返回的结果

response.isSuccessful()		返回是否是200
response.headers()		返回Headers对象，是一个头部信息集合，可以使用for循环遍历。headers.name(i),headers.value(i)读取头部信息。
response.body().string()	返回的内容
	       .byteStrem()	返回的byte流，可以用于下载东西







POST请求
RequestBody body = new FormBody.Builder().add(name,value).add().build();
add传入键值对，生成body

Request request = new Request.Builder().url(“”）.post(body).build（）
就成了post请求了。


上传文件
也相当于是POST请求，只是要创建一个上传文件类型的BODY。
RequestBody body = RequestBody.create(MediaType.parse("text/x-markdown;charset=utf-8"),File)

FormBody也是相当于是用这个包装的
“application/x-www-form-urlencoded”就是表单的
“application/json;charset=utf-8” 后面传入json字符串，就是一个json的body了。




设置超时和缓存
OkHttpClient.Builder builder = new OkHttpClient.Builder()
	.connectTimeout(15,TimeUnit.SECONDS)
	.writeTimeout(15,TimeUnit.SECONDS)
	.readTimeOut(15,TimeUnit.SECONDS)
	.cache(new Cache(File,10*1024*1024))
 








******************************************************
Http

一个Http请求，由请求行，请求头，空行，请求体组成

URL的构成
http://localhost/index.html?key1=value1&key2=value2
协议   主机      路径       参数







Retrofit的使用：
依赖    compile 'com.squareup.retrofit2:retrofit:2.0.2'

Retrofit retrofit = new Retrofit.Builder().baseUrl("https://api.douban.com/").build();
新建对象，baseUrl传入接口的主机地址，也就是第一个/前面的，结尾一定要加上/

新建一个请求接口
    public interface DoubanService{
        @GET("v2/book/1220562")
        Call<ResponseBody> getBook();
    }
@GET后面是接口地址的路径部分，如果路径中有需要变动的，可以用占位符
    @GET("v2/book/{id}")
    Call<ResponseBody> getBook(@Path("id") int id);
{}就是占位符，@Path就是路径占位所需要的传入值。


GET查询参数的请求：/?wd=retrofit这样的
        @GET("s")
        Call<ResponseBody> getBook(@Query("wd") String str);
用@Query注解，添加参数，括号内写入key名称，后面是value值的类型。
也可以把请求参数直接写入@GET那么。@GET(“s?wd=retrofit”）




POST请求
@POST("weather/ip")
@FormUrlEncoded		用于指定Content-Type，这个就是表单格式，也就是最普通的map参数
Call<ResponseBody> getBook(@Field("ip") String ip,@Field("dtype") String dtype);

也可以使用map参数。
Call<ResponseBody> getBook(@FieldMap Map<String,String> map);



使用retrofit对象，创建接口对象
LoginService loginService = retrofit.create(LoginService.class);

然后调用上面定义的请求方法
Call<ResponseBody> call = loginService.getBook(传入对应的参数);

使用生成的Call对象，执行网络请求，传入监听对象，生成监听方法。
call.enqueue(new Callback<ResponseBody>())



使用Gson解析数据：
添加依赖   compile 'com.squareup.retrofit2:converter-gson:2.0.2'
自定义的接口类方法，返回参数泛型改为数据Bean类  Call<WeaterBean>
添加Gson转换器
Retrofit retrofit = new Retrofit.Builder()
      .baseUrl("http://localhost:4567/")
      //可以自己创建一个Gson对象传入，也可以不传。会用默认的
      .addConverterFactory(GsonConverterFactory.create())
      .build();

然后在成功监听方法中，返回的Response泛型就是自定义的类了。
response.body()方法返回的对象，就是数据类对象










****************************************************
RxJava的使用
创建一个观察者：Subscriber对象
Subscriber<String> subscriber = new Subscriber<String>(){
    @Override
    public void onNext(String s) {
    
    }

    @Override
    public void onCompleted() {
     
    }

    @Override
    public void onError(Throwable e) {
        
    }
};
实现3个方法，onNext,是接受消息的方法；onCompleted是消息发送完毕的方法，onError就是错误提示了。


创建一个被观察者，也就是发送消息的，Observable对象
Observable observable = Observable.create(new Observable.OnSubscribe<String>() {
    @Override
    public void call(Subscriber<? super String> subscriber) {
        subscriber.onNext("Hello");
        subscriber.onNext("Hi");
        subscriber.onNext("Aloha");
        subscriber.onCompleted();
    }
});
在方法内发送消息。


最后，建立订阅关系，由被观察者来绑定订阅
observable.subscribe(subscirber);



创建被观察者，还有更简洁的方法：
Observable observable = Observable.just("test1","test2","test3")；
这样就相当于在内部调用了三次onNext发送消息的方法，和一次发送完毕的方法。

或者，使用from方法，遍历集合，依次传递每一个数据。
Observable observable = Observable.from(new String[]{})；
可以传入数组，和list










创建观察者，也可以单独定义某个方法的快速构建
Action1<String> onNext = new Action1<String>(){
    @Override
    public void call(String s) {
        
    }
};
Action0 onCompletedAction = new Action0() {
    @Override
    public void call() {
        Log.d(tag, "completed");
    }
};
Action1对象就相当于Subscirber的onNext和onError方法，可以自定义泛型来决定哪个方法
Action0对象就相当于onCompleted方法。


然后订阅时，observable.subscribe(onNext)就直接建立绑定关系了。
内部的大概实现：
public Subscription subscribe(Subscriber subscriber) {
    subscriber.onStart();
    onSubscribe.call(subscriber); //onSubscribe就是创建Observable传入的，看上面创建方法
    return subscriber;
}




Observable<Long> interval = Observable.interval(3, TimeUnit.SECONDS)
创建一个类似定时器的被观察者，后面传入的是，每隔几个时间单位，发送一次数据，发送的是整数，从0开始的。



rangeObservable = Observable.range(10, 5);
这个会发送10,11,121,13,14,15.从10开始的5个整数。

timeObservable = Observable.timer(3, TimeUnit.SECONDS);  //3秒后发射数据，数据为0


repeatObservable = Observable.just("repeatObservable").repeat(3);//重复发射3次






map的使用 	转换
map的功能，是把发送的数据，拦截到自己这，转换处理一次，再接着发出去
Observable.just(String).map(new Func1<String,Bitmap>)	
map方法需要传入一个Func1对象，泛型为原始数据类型，和最终传入数据类型。
需要实现一个call方法  public Bitmap call(String s) 
传入原始数据，最后要return一个处理后的目标数据类型。





flatmap的使用：
主要功能也是拦截数据处理再发出，但是这里最后返回发出的是一个Observable被观察者对象。
后面再做处理或者订阅的话，相当于处理的就是这个返回的对象。




filter的使用：
主要功能，相当于个for循环加if判断。会把发送的数据传入，然后自己做操作，最后需要return个Boolean值。也就是只有返回true的数据。才会接着往下传递。
ps：上面这几个拦截器，都有顺序关系的，是会一个一个往下传递的。




buffer的使用：
buffer(2)设置缓存大小，当传入的消息数量，达到指定数量后，会封装成List再往下发出。



take的使用
take（4）设置只发送前四个消息



distinct的使用		去掉重复的消息







观察者的onStart准备工作方法，是发生在调用subscribe（subscriber）的线程的。
可以使用doOnSubscribe方法，这个方法，只能传入一个Action0的对象，这个对象就相当于观察者的onStart方法了。然后在他之后设置subscribeOn（）方法，就会执行离它最近的线程控制。




和Retorfit的配合使用：
定义接口方法返回值的时候，可以定义成Observable类型的，也就是被观察者的。然后返回后，就可以直接使用被观察者的这些方法了。





Subject的使用：有四个实现类，都是使用create方法创建。
AsyncSubject
AsyncSubject<String> asyncSubject = AsyncSubject.create();
asyncSubject.onNext("asyncSubject3");  
asyncSubject.onCompleted();
上面是创建和使用方法
特点是如果不调用onCompleted方法，就不会发送数据；调用了，观察者也只会接受到onCompleted方法前的最近一个消息。并且之后的消息也不会在接受。



BehaviorSubject
观察者会从订阅方法前的最近一个消息开始接收。onNext1，onNext2,subscribe，onNext3.就会接受到2,3两条。而且不调用onCompleted也可以。



PublishSubject
只会接受订阅后发送的数据



ReplaySubject
会发送所有的消息，不管订阅前后的。
 ReplaySubject.createWithSize(2);
这样就只会从订阅前的2条开始发送。

ReplaySubject.createWithTime(1,TimeUnit.SECONDS,Schedulers.computation());
从订阅前的1秒钟开始发送。







线程控制：Scheduler
指定发送消息和接受消息，都在哪个线程执行
还是被观察者来调用的observable.
subscribeOn()		设置被观察者发送消息所在的进程
observeOn（）		设置观察者接受消息所在的进程

传入的指定线程参数
Schedulers.immediate()		当前线程
Schedulers.newThread()		新线程
Schedulers.io()			类似一个线程池，会重用空闲的线程，节省开销
Schedulers.computation()	计算型线程，会充分利用CPU性能
AndroidSchedulers.mainThread()	Android的主线程


observeOn设置的是之后的操作所在的线程，相当于设置后就到了指定线程了，之后的操作就在这个线程里进行了。









*****************************************************
EventBus的使用：
依赖    compile 'org.greenrobot:eventbus:3.0.0'


新建一个类，创建变量。


在发送消息的页面：
其实发送的是一个类对象
EventBus.getDefault().post(new SendMsg("test msg"));


在要接受数据的页面:
注册监听 EventBus.getDefault().register(this);
接触监听 EventBus.getDefault().unregister(this);


创建接受消息的方法：
@Subscribe(threadMode = ThreadMode.MAIN)	添加注解
public void onMessageEvent(SendMsg event){	接受消息的方法，方法参数是发送的对象。

注解参数，用来指定线程，共有四个类型
POSTING		默认的，和发送时同一个线程
MAIN		主线程
BACKGROUND	如果发送的在主线程，那就在子线程接受；如果发送的在子线程，那就线程不变
ASYNC		总是新开子线程来执行



发送粘性事件:
也就是说，可以先发送消息，消息会存在EventBus中，然后再注册监听，监听方法一样可以收到之前存放的消息。
 EventBus.getDefault().postSticky(new SendMsg("test msg"));


接受消息的监听方法那，注解添加参数
@Subscribe(threadMode = ThreadMode.MAIN，昨天sticky = true)  是否接收粘性事件







***********************************************
AppBarLayout
继承之LinearLayout垂直方向的一个app bar布局，主要是配合CoordinatorLayout和滚动类View(RecycleView、NestedScrollView)，在滚动时，来指定内部View的滚动动作。
必须要放在CoordinatorLayout的直接子View。


一般是来指定Toolbar的滚动动作,设置属性app：layout_scrollFlags=
"scroll"		
	这样toolbar就相当于和滚动框融为一体了。正常滚动

"enterAlways|scroll"	
	往下翻是没变的。往上翻的时候，是会先滚动toolbar的；等到toolbar完全显示的时候，才会接着滚动显示下方的滚动view

"enterAlways|scroll|enterAlwaysCollapsed"
	往下翻也是正常的。往上翻的时候，先会滚动toolbar，但是toolbbar显示到最小高度的时候，toobar就先不滚动了；会接着滚动下方的滚动view内容，滚动view全部显示后，会接着滚动显示toolbar到完全高度。

"scroll|exitUntilCollapsed"
	往下翻，toolbar滚动到最小高度的时候，就不滚动了；也就是说会留个标题栏，下方滚动view继续滚动；往上翻，下方滚动view全部显示时，toolbar开始滚动到完全显示。

"scroll|snap"
	正常的翻动的话，和scroll一样的，和下方滚动view融为一体的。但是这个有个回弹效果的，如果滚动到toolbar显示大半的情况下松手，会自动再滚动到toolbar消失，如只滚动一点也会自动回滚到完全显示



监听器
addOnOffsetChangedListener（）
返回参数，int verticalOffset，为滚动时，实时传入的当前滚动距离。

removeOnOffsetChangedListener 
移动监听

getTotalScrollRange（）
返回appbarlayout的可滚动高度。

setExpanded（true，true）
设置appbarlayout是否展开，是否需要展开动画






************************************************
CollapsingToolbarLayout
xml引入android.support.design.widget.CollapsingToolbarLayout
作用是提供了一个可以折叠的Toolbar，内部继承之FrameLayout的
内部可以包括一个Toolbar和其他View

app:contentScrim	设置折叠后的背景颜色。
app:expandedTitleMarginStart="100dp"	设置展开状态下，toolbar标题向右边偏移的距离。


内部View的设置属性
app:layout_collapseMode="pin"
设置滚动时，view是否滚动。pin是不滚动，parallax是滚动

设置parallax滚动后，可以设置视差因子0-1
   app:layout_collapseParallaxMultiplier="0.5"


mCollapsingToolbarLayout.setTitle(" ");
设置标题。用这个控件的话，toolbar再设置标题是没用的。

mCollapsingToolbarLayout.setExpandedTitleColor();
设置展开时，标题字体颜色

mCollapsingToolbarLayout.setCollapsedTitleTextColor();
设置收缩时，标题字体颜色。






信息加密：
消息的接受者为保证信息传送过程中，保证是真实的发送方发送的，而且不会被篡改，所采用的方法

消息的发送者会先生成一对公私钥匙。
然后把发送的原始信息，使用MD5等摘要算法，提取出消息摘要。
把信息摘要再用自己的私钥加密，就成了所谓的数字签名

然后会发送两部分，一个是原始消息，一个是加密的摘要(数字签名)

接收方就收到后，会先对原始消息，也提取信息摘要；然后用公钥解密数字签名得出摘要。看是否一致，如果一致，就说明没有篡改。








************************************************
CardView的使用：
compile 'com.android.support:cardview-v7:25.3.1'
android.support.v7.widget.CardView

是一个父布局，内部是继承之FrameLayout的，所以一般实际使用再嵌套个布局。


一些属性：
app:cardElevation = "5dp"		设置阴影的高度
app:cardCornerRadius = "4dp"		设置布局圆角的弧度
app:cardBackgroundColor = "#ff0000"	设置背景颜色，普通的设置背景色是无效的
app:cardUserCompatPadding = "true"
设置true后，实际边框距离到绘制边框那中间，会给阴影留出距离。







**********************************************
SwipeRefreshLayout的使用：
是一个父布局，内部只能有一个子控件。
android.support.v4.widget.SwipeRefreshLayout

setColorSchemeColors(int...) 
设置加载中滚动图标的颜色，最多可以传入四个颜色，这四个颜色会轮换显示。

setSize（SwipeRefreshLayout.LARGE）
设置滚动图片的大小，只能大和默认两种。

setDistanceToTriggerSync（int）
设置下拉的距离，触摸下拉多长距离，才会达到刷新效果。

setOnRefershListener（）
设置监听器，监听下拉动作，在监听方法OnRefresh中做具体操作。

setRefreshing（true）
通知加载完成，隐藏滚动动画。





**********************************************************

RecyclerView的使用：
添加依赖 compile 'com.android.support:recyclerview-v7:25.3.1'
XML组件名 <android.support.v7.widget.RecyclerView

设置方面:
需要设置一个LayoutManager对象，新建一个线性管理器
LinearLayoutManager layoutManager = 
new LinearLayoutManager(Context context, int orientation, boolean reverseLayout)
	orientation 	设置内部Item是横向还是竖向排列，也可单独设置
			layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL)   横向排列
	reverseLayout  	设置是否是逆向布局，如果设置为true，第一条数据就会显示在最下方，然后从下往上排列，滚动条也是滚动到最下方的。


mRecyclerView.setLayoutManager(layotManager);



如果要使用Grid布局，可以生成GridLayoutManager对象，设置上
GridLayoutManager layoutManager = new GridLayoutManager（this，4）  
如果设置成竖向排列，那就是有4列，item排列从左到右
如果设置成横向排列，就是有4行，item排列从上到下



StaggeredGridLayoutManager瀑布流
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);      每行数量，和翻页方向







adapter的使用：
新建类继承RecycleView.Adapter<ViewHolder>  后面泛型是自定义的ViewHolder

public class MyAdapter extends RecyclerView.Adapter<MyAdapter.MyViewHolder> {

会重写三个方法
返回item的总数
    @Override
    public int getItemCount() {

先inflater item的布局，生成View对象，然后新建自定义ViewHolder对象，构造方法需要传入item的View对象。
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return null;
    }

给传入的holder对象的控件对象设置数据。
    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {

    }

自定义ViewHolder的使用：
新建类需要继承RecyclerView.ViewHolder,然后会重写构造方法，构造方法必须传入一个View对象
        public MyViewHolder(View itemView) {
            super(itemView);
            然后在这里绑定生成item内的控件对象。
        }



adapter的数据更新：
除了notifyDataSetChanged（）更新全部数据外；
还有其他：
更新指定位置的item
	notifyItemChanged(int position)	
更新指定位置的item，从第几个开始，更新多少个	
	notifyItemRangeChanged（int positionStart，int itemCount）
删除指定位置的item，或者从第几个开始，删除多少个
	notifyItemRemoved（position，itemCount）



ViewHolder的方法：
获取当前点击的item的实际位置.
	getLayoutPosition();
获取当前点击的item在adapter中的位置。这个会有16毫秒的延迟，所以一般用上面那个为准。
	getAdapterPosition();
设置当前Item是否可以被回收：
	setIsRecyclable（false）
查看当前item是否可以被回收
	isRecyclable（）







****************************************************
BaseRecyclerAdapterHelper的使用：
引用：compile 'com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.22'

然后在Project的gradle的文件中加入
allprojects {
    repositories {
        jcenter()
        maven { url "https://jitpack.io" }
    }
}


新建adapter继承之BaseQuickAdapter<数据源类泛型，BaseViewHolder>
构造方法，需要传入布局id和List的数据源

convert方法，会传入一个BaseViewHolder对象，和一个数据源对象。

    @Override
    protected void convert(BaseViewHolder helper, String item) {
        helper.setText(R.id.tx1,item);
	TextView tv = helper.getView(R.id.tx1);
    }
这样就可以给item布局设置数据了。
也可以手动获取到布局内控件。


开启加载动画
adapter.openLoadAnimation(BaseQuickAdapter.ALPHAIN);  默认是这个
SCALEIN 
SLIDEIN_BOTTOM 
SLIDEIN_LEFT 
SLIDEIN_RIGHT 

自定义动画：
new BaseAnimation（）会重新一个getAnimators方法，要求返回一个Animator[]。自定义两个属性动画返回即可。

动画是否只执行一次，传入false，每次加载就使用动画
adapter.isFirstOnly(false);

添加头部尾部视图：
adapter.addHeaderView（view）
adapter.addFooterView (view)



添加上拉加载更多监听器：
setOnLoadMoreListener（new BaseQuickAdapter.RequestLoadMoreListener() , mRecyclerView）
内部添加数据的操作，需要在子线程中操作。
数据加载的时候，会显示滚动圈和正在加载中...
数据添加进数据源内，可以使用adapter的方法：adapter.addData()可以传入一个数据或者一个数据集合。
最后要通知适配器数据加载完成。
adapter.loadMoreComplete();	加载中布局消失，刷新数据。
adapter.loadMoreEnd();		全部数据加载完成，底部显示"没有更多数据"
adapter.loadMoreFail();		显示"加载失败，点击重试",点击后会重新执行加载数据的方法


设置自动加载更多：
adapter.setPreLoadNumber(5);
当列表滑动到倒数第几个的时候，自动调用加载更多的方法。


自定义加载中布局：
adapter.setLoadMoreView(LoadMoreView子类)
新建类继承之LoadMoreView。实现其四个方法，返回加载中布局的layoutID，和加载中、加载完成、加载失败的布局id。
自己新建一个xml布局，内部嵌三个布局就可以了。



设置上拉加载
adapter.setUpFetchEnable(true)	开启下拉加载
adapter.setUpFetchListener()	下拉加载监听器
在监听器中，先设置当前为下拉加载中
adapter.setUpFetching(true)

操作结束后，设置为加载完毕
adapter.setUpFetching(false);

设置开始加载的位置，滚动到什么位置就开始加载：
adapter.setStartUpFetchPosition（2）




设置空View，没有数据时显示的视图
adapter.setEmptyView(view);




设置拖拽改变位置，侧滑删除
Adapter需要继承之BaseItemDraggableAdapter
ItemDragAndSwipeCallback callback = new ItemDragAndSwipeCallback（adapter）
ItemTouchHelper helper = new ItemTouchHelper（callback）；
helper.attachToRecyclerView(mRecyclerView);

开始拖拽：
adapter.enableDragItem(helper);
adapter.setOnitemDragListener(new OnItemDragListener())

开启侧滑删除：
adapter.enableSwipeItem();
adapter.setOnItemSwipeListener(new OnItemSwipeListener())

设置拖拽后移动的方向：
callback.setDragMoveFlags(ItemTouchHelper.UP)
这个就是拖拽后只能往上移动。四个方向的标记，垂直布局的可以使用上下标记，水平的可以使用左右标记。

设置侧滑删除的方向：
callback.setSwipeMoveFlags(ItemTouchHelper.START)
设置从开头的方向还是结尾的方向侧滑删除。



多布局的使用：
数据类需要继承接口MultiItemEntity
实现一个抽象方法，返回自定义的ItemType。
adapter继承之BaseMultiItemQuickAdapter
在构造方法中，调用addItemType方法，设置各类型的布局，比如：
        addItemType(MultiItemEntityBean.TYPE1,R.layout.adapter_base_recy);
        addItemType(MultiItemEntityBean.TYPE2,R.layout.adapter_my);
在convert方法中，调用helper.getItemType，根据类型设置不同的数据。








******************************************************
git的使用：
设置用户名和邮箱:
git config --global user.name "xdh"
git config --global user.email "xdh443465224@163.com"

显示设置的用户名和邮箱
git config user.name


把当前目录设置成仓库：
git init


添加新文件到仓库(第一次添加和后续更新都需要先添加)：
git add 文件名.后缀

提交更新：
git commit -m "更新描述"		每次提交会生成一个提交id

返回信息[master (root-commit) cb926e7] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
1个文件改变，插入两行数据


git status
查看仓库状态

git diff
查看改动的部分

git log
查看每次commit操作的信息，用户名、日期和更新描述
git log --pretty=onlinee
只显示提交id和每次更新的描述


git reset --hard HEAD^
回滚到上一个版本。	HEAD^^就是上上个版本，HEAD~10就是上10个版本
git reset --hard 提交id	回滚到指定id的版本

reset回滚，回滚到的指定id后，会把之后的id给隐藏掉。再用git log和在远程仓库那查看历史提交信息，是不会显示当前id后面的id。
但是用git reflog还是会显示以前的所有操作id的，还可以通过这个看到后面的提交id。





git reflog
查看每次的操作记录，包括回滚什么的
log太多时，按回车键显示下面的部分。按Q+Enter键退出


仓库中可见的文件，也就是工作区。隐藏的.git文件夹就是版本库，版本库里面有暂存区和分支。
add操作就是把工作区文件添加到暂存区。
commit是把暂存区的东西提交到master分支那。
status就是查看暂存区的状况呢。


Changes not staged for commit
工作区文件有改变，没有使用add添加到暂存区

Changes to be committed:
暂存区有文件等待提交


git checkout -- 文件名
撤销当前未提交的修改。如果还没有add到暂存区，就恢复到上次保存前的状态，如果已经提交到暂存区后做的修改，就恢复到刚提交暂存区时的状态。
相当于把仓库里存的文件拿来替换工作区的文件。


git reset HEAD 文件名
把提交到暂存区的文件，给退回到工作区。


删除文件，可以手动删除，然后使用git add aa.txt提交到暂存区。最后commit提交
也可以直接使用git rm aa.txt。这个就相当于手动删除加add操作了。
如果手误删除，想要恢复。
可以依照上面reset操作，把暂存区的文件退回工作区。最后再checkout替换。






创建切换分支：
git checkout -b dev
创建一个"dev"分支并切换到分支，相当于：
git branch dev		创建分支
git checkout dev	切换到指定分支  checkout 加上-b表示创建并切换



查看当前分支
git branch	会列出所有分支，当前分支带星号


合并分支：
git merge dev	快速合并
合并时，如果没有冲突，会使用Fast-forward快速合并模式，会丢掉分支信息。
合并分支有冲突时，会有提示，需要手动解决冲突，再使用add 命令和commit提交。
两个分支文件的同一行内容不一致就会产生冲突。

合并分支，会把被合并分支的各种commit id都带过去的啊。


禁用Fast-forward模式合并：
git merge --no-ff -m "描述信息" 分支名




删除分支：
git branch -d 分支名




隐藏工作区文件：
切换分支时，当前工作区的文件需要提交到分支仓库区，如果不commit提交，就不能切换分支的。

当出现紧急情况，需要切换分支，但是当前的操作还不能提交，也就不能切换分支了，这时可以使用命令隐藏工作区文件，然后就可以切换分支了。
git stash
文件上新增的操作就没有了，就如同上次提交后的样子。

等操作完毕，再回到分支上时，使用命令，恢复隐藏的内容。
git stash pop



强制删除分支：
如果分支没有合并，使用-d是删除不了的。需要使用-D命令删除








**********************************************************
使用Github仓库的话，中间传输文件，需要SSH来确认安全的。

检查是否有ssh，在git bash中输入：
ls -al ~/.ssh
或者在c盘用户目录下看是否有.SSH文件夹

如果没有，创建ssh的方法：
ssh-keygen -t rsa -C "youremail@example.com"
一路确认下去就可以了。

然后在Github中添加SSH就可以了。



在Github中新建一个空仓库
在本地仓库中添加远程仓库：
git remote add origin git@github.com：用户名/仓库名.git

删除远程仓库：
git remote rm origin


首次把本地文件推送到远程仓库：
git push -u origin master
加-u是把本地的master分支和远程的master分支相关联。

后面再推送文件使用：
git push origin master

git push origin master -f
强制上传，当远程仓库比本地文件版本高的时候，会提示先让pull的，不想pull的话，可以直接用强制上传，来替换远程的文件。




从Github仓库克隆文件到本地仓库：
git clone git@github.com:用户名/仓库名.git
(仓库的链接地址有两种：git@github.com这种是SSH协议；另一种https://github.com是https协议的，每次推送都要输入账号密码)




推送分支到远程仓库
git push origin 本地分支名
首次推送分支到远程仓库时，远程不存在对应分支的话，会自动建立同名分支。
但是本地分支和远程分支并没有建立连接，使用pull拉数据的话会报错的。
需要设置分支间的连接


设置本地分支和远程分支的连接
git branch --set-upstream-to=origin/dev dev



git remote -v
查看远程仓库的信息


git branch -a
查看所有分支，本地和远程的


git branch -vv
查看本地分支和远程分支的连接信息



从远程仓库拉取分支：
git checkout -b dev origin/dev
需要先更新远程仓库的分支信息，才能拉取分支并建立连接。
使用git fetch。或者下面这个命令。


更新远程仓库的分支信息：
git remote update origin --prune



删除远程仓库的分支：
git push origin  :dev





标签是用来关联commit id的，平常commit id很不好记，用标签来记就方便多了，相当于是ip地址和网址的关系吧。
创建标签：
git tag v1.0
在上一个commit上打上标签


查看所有标签：
git tag


指定commit id打标签
git tag v1.0 62234567


查看标签详细信息:
git show v0.9		会显示相应的commit id信息


创建有说明信息的标签
git tag -a 标签名 -m"说明信息" <commit id>


删除本地标签：
git tag -d v0.1


推送标签到远程仓库：
git push origin v1.0


推送全部标签到远程：
git push origin --tags


删除远程仓库的标签
git push origin：refs/tags/v1.0





配置git，忽略特殊文件的上传：
配置一个.gitignore文件，里面写入不要提交的文件后缀名。
然后把这个文件，添加奥版本库里。
github这里已经提供了一份各个语言的忽略配置文件
https://github.com/github/gitignore






在AndroidStuio中使用Git
Settings--VersionControl 设置当前项目使用的版本控制工具

设置后，目录文件变成红色，说明未添加add操作。
选择成Project目录架构后，右击项目名，选择Git--Add。全部添加
目录文件变成绿色，已Add但是未commit
修改文件后，文件名会变成蓝色的

提交可使用Git--Commit Directory，也可以点击工具类的VCS上传按钮
点击commit and push，提交加上传，第一次操作的话，需要设置远程仓库


点击下载按钮，可以选择merge合并。
就是拉取代码并且合并



从github下载项目：
VCS--Checkout from Version Control--Github
会让输入账号密码。
第二步会让输入项目地址、本地存放目录、目录名称


把当前项目分享到Github：
VCS--import into Version Control--Share Project to Github






















